# Лекция 8. Git. Удаленный репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.

### Оглавление курса

- Блок 1 — Python Basic (1–6):
  - [Лекция 1. Введение. Типизации. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.](lesson02.md)
  - [Лекция 3: None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter.](lesson05.md)
  - [Лекция 6. Рекурсия. Алгоритмы. Бинарный поиск, сортировки](lesson06.md)
- Блок 2 — Git (7–8):
  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md)
  - ▶ **Лекция 8. Git. Удаленный репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.**
- Блок 3 — Python Advanced (9–14):
  - [Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты.](lesson09.md)
  - [Лекция 10. Множественное наследование. MRO. Magic methods.](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - [Лекция 14. Проектирование. Паттерны. SOLID.](lesson14.md)
- Блок 4 — SQL (15–17):
  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи.](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. Group by. Joins.](lesson16.md)
  - [Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup](lesson17.md)
- Вне блоков:
  - [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv.](lesson18.md)
- Блок 5 — Django (19–26):
  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy.](lesson21.md)
  - [Лекция 22. Django ORM.](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication.](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
- Блок 6 — Django Rest Framework (27–30):
  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework.](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST аутентификация. Авторизация. Permissions. Фильтрация.](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API.](lesson30.md)
- Блок 7 — Python async (31–33):
  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Асинхронное программирование в Python. Корутины. Asyncio.](lesson32.md)
  - [Лекция 33. Сокеты. Django channels.](lesson33.md)
- Блок 8 — Deployment (34–35):
  - [Лекция 34. Linux. Все что нужно знать для деплоймента.](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
- Вне блоков:
  - [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


## Удалённый репозиторий

**Удалённый репозиторий** – это версия вашего проекта, которая хранится в интернете или другой сети. Он позволяет вам и
другим разработчикам совместно работать над проектом. В Git удалённые репозитории обозначаются как "remotes".

## Зачем нужны удалённые репозитории?

Удалённые репозитории в Git играют ключевую роль в командной разработке и управлении проектами. Вот основные причины, по
которым они необходимы:

- Совместная работа:

> Пример: Представьте, что команда из пяти разработчиков работает над одним проектом. Без удалённого репозитория каждый
> разработчик будет вынужден обмениваться изменениями вручную, что сложно и чревато ошибками.


![git_team.jpg](pictures/git_team.jpg)

- Резервное копирование:

> Пример: Если локальный репозиторий на компьютере разработчика будет повреждён или утерян, все данные проекта будут
> утеряны. Удалённый репозиторий обеспечивает надёжное резервное копирование.

- Доступ из любой точки:

> Пример: Разработчик может работать над проектом из дома, офиса или в пути, имея доступ к последней версии проекта
> через
> удалённый репозиторий.

- Интеграция с CI/CD и другими сервисами:

> Пример: Удалённые репозитории могут интегрироваться с системами непрерывной интеграции и доставки (CI/CD), что
> позволяет автоматизировать тестирование и развёртывание приложений.

- Контроль версий и история изменений:

> Пример: Удалённые репозитории сохраняют всю историю изменений, позволяя просматривать и восстанавливать предыдущие
> версии проекта.

Управление разрешениями и безопасность:

> Пример: Удалённые репозитории позволяют управлять доступом и разрешениями для различных пользователей и команд,
> обеспечивая безопасность проекта.

## А какие бывают платформы для хранения репозиториев?

Существует довольно много различных платформ для хранения репозиториев,
например `GitHub`, `GitLab`, `Bitbucket`, `Azure Repos`, `AWS CodeCommit` и другие.

Но годами самые популярные платформы — `GitHub`, `GitLab`, `Bitbucket`. Большинство известных мне проектов используют
именно их.

> Проектов, которые не используют Git, я не знаю, и в ближайшем будущем сомневаюсь, что такие появятся!

### GitHub

![](https://miro.medium.com/v2/resize:fit:1125/0*N1fmHtI8gmkH_2Vu.png)

**GitHub** – это одна из самых популярных платформ для хостинга Git-репозиториев. Она предоставляет мощные инструменты
для совместной работы, такие как pull requests, issues и GitHub Actions.

### Bitbucket

![](https://www.kaashivinfotech.com/blog/wp-content/uploads/2023/09/bitbucket9553.jpg)

**Bitbucket** – это платформа для хостинга Git-репозиториев, которая также поддерживает Mercurial. Bitbucket предлагает
интеграцию с Jira и другие инструменты Atlassian для управления проектами.

### GitLab

![](https://media.zenfs.com/en/globenewswire.com/443dc008fa79aaaac01e22267ab1ec43)

**GitLab** – это платформа для хостинга Git-репозиториев, которая также предоставляет CI/CD, issue tracking и множество
других функций для DevOps.

### И что с этим делать?

Любая из этих платформ предполагает, что вы должны на ней зарегистрироваться и войти в аккаунт.

После этого появится возможность создать свой собственный новый репозиторий

> Ну, или если мы говорим о коммерческой
> разработке, то скорее всего репозиторий уже создан, и ваш аккаунт просто добавят к существующему репозиторию

## Публичные и приватные репозитории

![](https://cdn.corporatefinanceinstitute.com/assets/private-vs-public.jpeg)

### Публичные репозитории

`Публичный репозиторий` – это репозиторий, доступ к которому может получить любой пользователь. Публичные репозитории
обычно используются для открытых проектов и open-source разработки.

#### Преимущества публичных репозиториев

- Открытый доступ:

    - Любой пользователь может клонировать, просматривать и использовать код вашего проекта.
      Подходит для проектов с открытым исходным кодом, где важно участие сообщества.
      Вклад сообщества:

    - Позволяет другим разработчикам вносить свой вклад в проект через pull requests.
      Облегчает привлечение новых участников и сторонних разработчиков.
      Популяризация проекта:

    - Проект становится видимым и доступным для широкой аудитории.
      Упрощает демонстрацию вашего кода потенциальным работодателям или партнёрам.

#### Недостатки публичных репозиториев

- Ограниченная приватность:

    - Весь код и история коммитов видны всем пользователям.
      Могут возникнуть проблемы с защитой интеллектуальной собственности.

- Открытость уязвимостей:

    - Все уязвимости и ошибки в коде также видны всем пользователям.
    - Может потребоваться более тщательный контроль качества и безопасности кода.

### Приватные репозитории

`Приватный репозиторий` – это репозиторий, доступ к которому ограничен только определённым пользователям или командам.
Приватные репозитории обычно используются для закрытых проектов и коммерческой разработки.

#### Преимущества приватных репозиториев

- Контроль доступа:

    - Доступ к коду имеют только авторизованные пользователи.
    - Упрощает управление доступом и ролями в команде.

- Защита интеллектуальной собственности:

    - Код и информация о проекте остаются конфиденциальными.
    - Подходит для коммерческих проектов и внутренних разработок.

- Безопасность:

    - Уязвимости и ошибки в коде видны только определённым пользователям.
    - Облегчает внедрение мер по защите кода и данных.

#### Недостатки приватных репозиториев

- Ограниченное участие сообщества:

    - Вклад сообщества ограничен или невозможен.
    - Сложнее привлечь сторонних разработчиков и участников.

- Стоимость:

    - Многие платформы требуют плату за использование приватных репозиториев (например, GitHub).
    - В некоторых случаях требуется покупка лицензий или подписок.

### Примеры платформ и их подходов к приватности

#### GitHub:

- Поддерживает как публичные, так и приватные репозитории.
- Публичные репозитории бесплатны, за приватные может взиматься плата в зависимости от тарифного плана.

#### GitLab:

- Поддерживает публичные и приватные репозитории.
- Предлагает бесплатные приватные репозитории с базовым функционалом, а также платные планы с расширенными
  возможностями.

#### Bitbucket:

- Поддерживает публичные и приватные репозитории.
- Обычно приватные репозитории доступны бесплатно для небольших команд, а для больших команд и организаций могут
  потребоваться платные планы.

> Выбор между публичными и приватными репозиториями зависит от специфики вашего проекта и ваших требований. Публичные
> репозитории подходят для open-source проектов и привлечения сообщества, тогда как приватные репозитории обеспечивают
> защиту интеллектуальной собственности и конфиденциальность.
>
> Понимание различий между этими типами репозиториев поможет вам сделать правильный выбор для вашего проекта и
> эффективно
> управлять доступом к коду.

Для обучения мы будем использовать публичные репозитории, на работе скорее всего будут приватные репозитории.

## Варианты доступа к Git-репозиториям. HTTPS vs SSH

![](https://learn.microsoft.com/ru-ru/devops/_img/git_repositories.png)

Git-репозитории могут быть доступны через два основных протокола: `SSH` и `HTTPS`. Мы не будем пока что разбирать их
особенности, сделаем это намного дальше по курсу. Каждый из этих способов имеет свои особенности, и выбор между ними
зависит от ваших требований и предпочтений.

### Доступ через HTTPS

![](https://timeweb.com/ru/community/article/3c/3c7872a45aa48d237485875cbc7c604a.png)

`HTTPS` (*HyperText Transfer Protocol Secure*) – это протокол, который использует шифрование SSL/TLS для защиты
передаваемых
данных. Доступ к Git-репозиториям через HTTPS требует аутентификации (логин+пароль или токен, в зависимости от платформы).

Пример URL для доступа через HTTPS:

```shell
https://github.com/username/repository.git
```

- Преимущества HTTPS:

    - Простота настройки: Для доступа через HTTPS достаточно иметь логин и пароль. Это удобно для новичков и быстрого
      начала
      работы.
    - Работа в ограниченных сетях: HTTPS легко проходит через брандмауэры и прокси-серверы, что делает его хорошим
      выбором для
      работы в корпоративных сетях.
    - Универсальность: HTTPS доступен на любом устройстве и операционной системе без дополнительной настройки.

- Недостатки HTTPS:

    - Неудобство частого ввода пароля: При каждом взаимодействии с удалённым репозиторием требуется вводить логин и
      пароль,
      что может быть неудобно.
    - Ограниченная безопасность: Хотя HTTPS обеспечивает шифрование данных, использование логина и пароля может быть
      менее
      безопасным по сравнению с SSH-ключами.

### Доступ через SSH

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSWiur6gBG_EmmM5xTGMxqrR8IkWkuKJRdlBw&s)

`SSH` (*Secure Shell*) – это протокол, который предоставляет защищённый способ доступа к удалённым системам. Доступ к
Git-репозиториям через SSH осуществляется с использованием пары SSH-ключей (открытого и закрытого ключа).

Пример URL для доступа через SSH:

```shell
git@github.com:username/repository.git
```

- Преимущества SSH:

    - Безопасность: SSH использует криптографическую пару ключей, что обеспечивает высокий уровень безопасности. Пароль
      не
      передаётся по сети, что уменьшает риск его перехвата.
    - Удобство использования: После первоначальной настройки SSH-ключей нет необходимости вводить пароль при каждом
      взаимодействии с репозиторием.
    - Гибкость: SSH позволяет настраивать доступ для разных пользователей и ключей, что удобно для управления командой
      разработчиков.

- Недостатки SSH:

    - Сложность настройки: Настройка SSH-ключей требует некоторых технических знаний и больше времени по сравнению с
      HTTPS.
    - Ограничения на уровне сети: В некоторых корпоративных сетях доступ через SSH может быть ограничен или
      заблокирован.

## Примеры использования и настройки

### Настройка доступа через HTTPS

Клонирование репозитория через HTTPS:

```shell
git clone https://github.com/username/repository.git
```

> На GitHub вместо пароля используется токен (Personal Access Token, PAT).
> Чтобы не вводить его каждый раз, можно настроить менеджер учётных данных (credential manager).

### Настройка доступа через SSH

#### Создание SSH-ключей:

Самый простой способ для создания пары ключей для `SSH` это использовать консоль линукса. Если вы используете Windows,
то вы можете использовать консоль которая была установленна вместе с GIT. Там эти команды тоже будут работать.

```shell
ssh-keygen -t ed25519 -C "your_email@example.com"
```

Следуйте инструкциям и сохраните ключи в файлах по умолчанию (`~/.ssh/id_ed25519` и `~/.ssh/id_ed25519.pub`).

> В Windows путь будет другой, убедитесь что вы запомнили где будут созданы ключи!!

#### Добавление публичного ключа в аккаунт Git-платформы:

Скопируйте содержимое файла `~/.ssh/id_ed25519.pub` (или ваш путь для Windows) и добавьте его в настройки SSH-ключей на
платформе (например, GitHub, GitLab, Bitbucket).

#### Клонирование репозитория через SSH:

```shell
git clone git@github.com:username/repository.git
```

### Про git clone

Команда `git clone` создаёт локальную копию удалённого репозитория. `Fork` — это операция на платформе (GitHub/GitLab/и т.д.), при которой создаётся ваш собственный удалённый репозиторий, связанный с исходным.

Если вы работаете по схеме форка, добавьте исходный репозиторий как `upstream` и периодически подтягивайте обновления:

```sh
git remote add upstream https://github.com/ORIGINAL/REPO.git
git fetch upstream
git checkout main
git merge upstream/main   # или: git rebase upstream/main
```

### Выводы

Выбор между HTTPS и SSH для доступа к Git-репозиториям зависит от ваших требований и предпочтений. HTTPS проще в
настройке и подходит для быстрого начала работы, особенно в ограниченных сетях. SSH обеспечивает более высокий уровень
безопасности и удобства использования после первоначальной настройки.

Понимание различий между этими протоколами и их преимуществ поможет вам выбрать наиболее подходящий способ доступа к
вашим Git-репозиториям и обеспечит надёжное управление проектами.

> В рамках курса мы будем использовать именно SSH ключи!

## Работа с удалёнными репозиториями

Для того что бы несколько разработчиков могли работать над одним удаленным репозиторием, они все должны быть подключены
к одному удаленному репозиторию, гит об этом должен как то узнать.

### Добавление удалённого репозитория

Чтобы добавить удалённый репозиторий, используется команда `git remote add`:

```sh
git remote add origin <URL>
```

Здесь `origin` – это стандартное имя для удалённого репозитория. Вы можете использовать любое другое имя, если хотите.
Но обычно если у вас один удаленный репозиторий, то он называется именно так.

### Просмотр удалённых репозиториев

Чтобы посмотреть список всех настроенных удалённых репозиториев, используйте команду:

```sh
git remote -v
```

### Удаление удалённого репозитория

Чтобы удалить удалённый репозиторий, используйте команду:

```sh
git remote remove <name>
```

### Изменение URL удалённого репозитория

Чтобы изменить URL удалённого репозитория, используйте команду:

```sh
git remote set-url origin <new-url>
```

## Команды `push` и `pull`

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRa4YtyxtmRuCushR9ethewfblfvOobpHa5yw&s)

### Команда `git push`

**`git push`** – это команда для отправки ваших локальных изменений в удалённый репозиторий. Она передаёт коммиты из
локальной ветки в соответствующую ветку удалённого репозитория.

```sh
git push origin main
```

Эта команда отправляет изменения из локальной ветки `main` в ветку `main` на удалённом репозитории `origin`.
Также удобно единожды задать отслеживаемую ветку (upstream):
```sh
git push -u origin feature-branch
```
После этого достаточно просто `git push`.


Если ветка существует только локально, но не существует на удаленном репозитории, гит покажет ошибку, и подскажет
команду которую надо выполнить, что бы успешно пушнуть код, и создать ветку на удаленном репозитории.

### Force push: когда и как (и почему лучше `--force-with-lease`)

Иногда после переписывания истории (например, `git rebase -i`, `git commit --amend`, `git reset`) ваш локальный граф расходится с удалённым. Обычный `git push` откажется, потому что это не fast‑forward. В таких случаях возникает желание «форс‑пушнуть».

- Что делает force push
  - `git push --force` переписывает удалённую ветку под ваш локальный HEAD, потенциально затирая чужие коммиты.
  - Это опасно на общих ветках: можно случайно уничтожить работу коллег.

- Безопасная альтернатива
  - Используйте `--force-with-lease` — он пушит только если на удалённой ветке нет новых коммитов, которых нет у вас локально.
  - Это защищает от перезаписи чужой работы.

```sh
# После rebase в вашей фиче
git push --force-with-lease
# Явно указать удалённый и ветку
git push --force-with-lease origin feature-branch
```

- Когда это уместно
  - Личные/фича-ветки, где вы единственный коммитер, и команда согласна на переписывание истории ради аккуратного PR.
  - Никогда не делайте force push в `main`/`master`/`release` и другие общие или защищённые ветки.

- Этикет и защита
  - Предупреждайте команду в PR, если предстоит force push; не делайте его во время активного ревью без согласования.
  - На платформах (GitHub/GitLab) включайте защиту веток: запрет force push, требование PR, обязательные проверки.

- Что делать, если что-то пошло не так
  - Если ветку перезаписали, можно восстановить коммиты через `git reflog` на машине, где они ещё есть:
```sh
git reflog                 # найти нужный SHA
git branch rescue <SHA>    # создать «спасательную» ветку на тот коммит
```

### Команда `git pull`

**`git pull`** – это команда для получения и объединения изменений из удалённого репозитория в вашу локальную ветку. Эта
команда сочетает в себе команды `git fetch` и `git merge`.

#### git fetch

Эта команда получает из удаленного репозитория всю информацию которая отличается от вашей локальной версии. **Ничего не
меняет!!** Только получает информацию, что, что-то изменилось.

#### git merge

Уже обсуждали, повторю, объединяет две ветки. В данном случае локальную и удаленную, с одинаковыми названиями.

Использование двух команд, вместо команды `pull` не встречается на практике.

```sh
git pull origin main
```

Безопаснее использовать только fast-forward:
```sh
git pull --ff-only
```
или, если политика команды — rebase:
```sh
git pull --rebase
```

Эта команда получает изменения из ветки `main` удалённого репозитория `origin` и объединяет их с локальной
веткой `main`.

## Pull Request

![](https://www.atlassian.com/blog/wp-content/uploads/bitbucket411-blog-1200x-branches2.png)

**Pull Request (PR)** – это механизм для предложения изменений в проекте. Он позволяет другим разработчикам просмотреть
ваш код перед его включением в основную ветку проекта. Pull request включает в себя описание изменений, обсуждения,
ревью кода и возможность автоматического тестирования.

На GitLab это называется Merge Request (MR); смысл тот же.

> Именно так и надо будет сдавать домашние задания и модули, в виде пулл реквестов.

### Процесс создания Pull Request

1. **Клонирование репозитория**:
    - Клонируйте репозиторий на ваш локальный компьютер.
> Если у вас нет прав на запись, сначала сделайте форк на платформе и клонируйте свой форк. Исходный репозиторий можно добавить как `upstream` для синхронизации.

   ```sh
   git clone <URL>
   ```

2. **Создание новой ветки**:
    - Создайте новую ветку для ваших изменений.

   ```sh
   git checkout -b feature-branch
   ```

3. **Внесение изменений и коммит(ы)**:
    - Внесите необходимые изменения и создайте коммит(ы).

   ```sh
   git add .
   git commit -m "Добавлено новое изменение"
   ```

4. **Отправка изменений в удалённый репозиторий**:
    - Отправьте изменения в ваш удаленный репозиторий на GitHub, Bitbucket или GitLab.

   ```sh
   git push origin feature-branch
   ```

5. **Создание Pull Request**:
    - Перейдите на страницу вашего репозитория на платформе и создайте новый pull request, выбрав основную ветку проекта
      и вашу ветку с изменениями.

> Этот процесс выглядит по-разному на каждом сайте, но суть всегда одна и та же. На занятии покажу как это выглядит на GitHub

6. **Ревью и обсуждение**:
    - Ведите обсуждение изменений с другими разработчиками. Возможно, вам потребуется внести дополнительные изменения.

7. **Мерджинг Pull Request**:
    - После завершения ревью и одобрения изменений ваш pull request может быть объединён с основной веткой проекта.

## Про совместную работу

Для того что бы я мог проверять ваши домашки, я должен быть добавлен в ваш репозиторий как колаборатор.

Для этого надо:

1) Открыть свой репозиторий
2) Перейти в настройки (Settings)
3) Найти там collaborators
4) Нажать добавить (add people)
5) Вписать мой ник `PonomaryovVladyslav`
6) Дождаться пока я подтвержу участие в проекте

> Эти действия нужно выполнять для каждого созданного репозитория (Домашки, Модули, Веб, лучше всего для разных проектов и разделов обучения создавать новый репозиторий)

## Git Flow

> Примечание: вместо `master` в большинстве новых репозиториев используется `main`. Ниже под основной веткой понимается `main` (иногда её называют `master`). В примерах будем использовать `main`.


Когда дело доходит до работы, возникает очень важный вопрос. Как будем использовать GIT?

На самом деле, это очень сложный вопрос. И на него нет правильного ответа.

Но если мы живём в идеальном мире, где у нас небольшая команда, есть профильные девопсы, мы используем только один
репозиторий, и релизы у нас выходят только раз в конце спринта, то в 2010 году за нас придумали правильный ответ.

Ответ называется `git flow`. И несмотря на все описанные выше "или" и количество статей с матом на этот подход, я еще
никогда не видел структуры, которая работала бы лучше при нормальных условиях.

![](http://risovach.ru/upload/2015/05/mem/no-ya-zhe_82347844_orig_.png)

Что же это такое?

Если одной страшной картинкой, то вот:

![](https://habrastorage.org/r/w1560/webt/oj/ir/hp/ojirhpa9ozvcpsejgei2azb0vo0.png)

Давайте разбираться.

При таком подходе нам необходимо две long-term ветки. То есть те, которые будут жить долго.

Это будут ветки `main` (иногда её называют `master`) и `develop`.

Если на пальцах, то `main` — это ветка с последней продакшен‑версией (иногда она называется `master`).

А `develop` - это то, что сейчас находится в разработке всей командой.

Обычно проект инициализируют в основной ветке и делают первый коммит, затем от неё создают `develop` (либо создают её позже при необходимости).

### Соглашения по именованию веток

- feature/<ticket-id>-<slug>
- release/<major>.<minor> (или <major>.<minor>.<patch>)
- hotfix/<major>.<minor>.<patch>

### Политика слияний (внутри Git Flow)

- Feature → develop: договоритесь, как мержить — squash merge (чистая история) или `--no-ff` (сохранять ветку).
- Release → main и Release → develop: мержим релизную ветку в обе; на main ставим тег версии.
- Hotfix → main и → develop: хотфикс идёт в прод, а также обратно в develop (и в открытую release‑ветку, если она есть), чтобы правка не потерялась.

### Правила защиты веток

Protected: `main`, `develop`, `release/*`

- Требуются PR и ревью
- Запрет на прямой push и force push

### Синхронизация feature‑веток

- Регулярно подтягивайте изменения из `develop` в свою feature (например, `git pull --rebase origin develop`), чтобы уменьшать конфликты при слиянии.


### Фича

**Фича** (`feature`) - это реализация одной задачи из беклога. Например, добавить на сайт логин, логин и будет
фичей.

При таком подходе к гиту для каждой фичи создаётся отдельная ветка, создаётся из ветки `develop`.

После завершения разработки создаётся pull request в ветку `develop`, чтобы обновить на ней текущий код.

По сути `develop` - это местная свалка всего нового кода, который только есть.

### Релизная ветка

Когда команда считает, что пора отдавать фичи на тестирование, из ветки `develop` создаётся ветка `release-x.x`,
где `x.x` - это условный номер релиза.

При редких релизах и выделенных тестовых окнах Git Flow удобен и прозрачен. Если релизы частые и практикуется CD, проще подходят GitHub Flow (main + короткие feature‑ветки) или Trunk‑Based Development (малые инкременты, фичефлаги). Выбирайте стратегию под процессы команды и требования к выпуску.

Из неё происходит деплоймент на тестовый сервер, где тестировщики ищут баги. Если баги незначительные, то прям в релиз
ветке фиксятся баги. Если значительные, то возвращаем релиз разработчикам, они всё переделывают и создают новую ветку
релиза.

После того как релизная ветка прошла все тесты и готова к тому, чтобы обновлять продакшен, из неё создаются два pull
PR: в `develop` и в `main`.

В `develop` — чтобы добавить багофиксы (если были). В `main` — чтобы выполнить деплоймент на продакшен.

В `main` после слияния обычно создаётся тег, чтобы была возможность откатить до прошлого тега без особой сложности.

### Hot fix

Но что делать, если задеплоили продакшен и тут же обнаружили небольшой и легко исправляемый баг? Не проходить же всю
процедуру с начала, пока у клиентов явно есть баг?

Для этого придумали хотфикс‑ветки, их создают прямо из `main`, и вливают обратно в `main` и в `develop` (и при необходимости — в открытую `release/*`). Итого
в `main`, чтобы задеплоить исправление бага, и в `develop`, чтобы этот баг не попадал в новые фичи.

### Выводы и реальность

Если для проекта нормально применение такого подхода, то я бы очень рекомендовал его применять. Но в реальности
практически всегда находятся проблемы, которые не совпадают с таким подходом, поэтому очень часто я видел вариации на
тему `git flow`, чем его сам.

Но идея очень крутая, всё структурировано понятно и возможно найти кто, что и когда.

## Как сдавать домашки

Для этого есть вот [эта](https://github.com/PonomaryovVladyslav/PythonCources/blob/master/pr_explanation.md) инструкция!

Жду код первого модуля в виде пулл реквеста! Всем удачи!!!