# Лекция 8. Git. Удалённый репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.

### Оглавление курса

<details>
  <summary>Блок 1 — Python Basic (1–6)</summary>

  - [Лекция 1. Введение. Типизации. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.](lesson02.md)
  - [Лекция 3: None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter.](lesson05.md)
  - [Лекция 6. Алгоритмы и структуры данных](lesson06.md)
</details>

<details open>
  <summary>Блок 2 — Git (7–8)</summary>

  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md)
  - ▶ **Лекция 8. Git. Удалённый репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.**
</details>

<details>
  <summary>Блок 3 — Python Advanced (9–14)</summary>

  - [Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты. Множественное наследование.](lesson09.md)
  - [Лекция 10. Magic methods. Итераторы и генераторы.](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - [Лекция 14. Проектирование. Паттерны. SOLID.](lesson14.md)
</details>

<details>
  <summary>Блок 4 — SQL (15–17)</summary>

  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи.](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. Group by. Joins.](lesson16.md)
  - [Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup](lesson17.md)
</details>

- [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv.](lesson18.md)

<details>
  <summary>Блок 5 — Django (19–26)</summary>

  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy.](lesson21.md)
  - [Лекция 22. Django ORM.](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication.](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
</details>

<details>
  <summary>Блок 6 — Django Rest Framework (27–30)</summary>

  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework.](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST аутентификация. Авторизация. Permissions. Фильтрация.](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API.](lesson30.md)
</details>

<details>
  <summary>Блок 7 — Python async (31–33)</summary>

  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Asyncio. Aiohttp. Асинхронное программирование на практике.](lesson32.md)
  - [Лекция 33. Сокеты. Django channels.](lesson33.md)
</details>

<details>
  <summary>Блок 8 — Deployment (34–35)</summary>

  - [Лекция 34. Linux. Все что нужно знать для деплоймента.](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
</details>

- [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


## Удалённый репозиторий

**Удалённый репозиторий** — это версия вашего проекта, которая хранится в интернете или другой сети. Он позволяет вам и
другим разработчикам совместно работать над проектом. В Git удалённые репозитории обозначаются как «remotes».

## Зачем нужны удалённые репозитории?

Удалённые репозитории в Git играют ключевую роль в командной разработке и управлении проектами. Вот основные причины, по
которым они необходимы:

- Совместная работа:

> Пример: Представьте, что команда из пяти разработчиков работает над одним проектом. Без удалённого репозитория каждый
> разработчик будет вынужден обмениваться изменениями вручную, что сложно и чревато ошибками.


<img src="pictures/lesson08/git_remote_team.png" alt="drawing" width="500"/>

- Резервное копирование:

> Пример: Если локальный репозиторий на компьютере разработчика будет повреждён или утерян, все данные проекта будут
> утеряны. Удалённый репозиторий обеспечивает надёжное резервное копирование.

- Доступ из любой точки:

> Пример: Разработчик может работать над проектом из дома, офиса или в пути, имея доступ к последней версии проекта
> через
> удалённый репозиторий.

- Интеграция с CI/CD и другими сервисами:

> Пример: Удалённые репозитории могут интегрироваться с системами непрерывной интеграции и доставки (CI/CD), что
> позволяет автоматизировать тестирование и развёртывание приложений.

- Контроль версий и история изменений:

> Пример: Удалённые репозитории сохраняют всю историю изменений, позволяя просматривать и восстанавливать предыдущие
> версии проекта.

- Управление разрешениями и безопасность:

> Пример: Удалённые репозитории позволяют управлять доступом и разрешениями для различных пользователей и команд,
> обеспечивая безопасность проекта.

## А какие бывают платформы для хранения репозиториев?

Существует довольно много различных платформ для хранения репозиториев,
например `GitHub`, `GitLab`, `Bitbucket`, `Azure Repos`, `AWS CodeCommit` и другие.

Но годами самые популярные платформы — `GitHub`, `GitLab`, `Bitbucket`. Большинство известных мне проектов используют
именно их.

> Проектов, которые не используют Git, я не знаю, и в ближайшем будущем сомневаюсь, что такие появятся!

### GitHub

<img src="https://miro.medium.com/v2/resize:fit:1125/0*N1fmHtI8gmkH_2Vu.png" alt="drawing" width="300"/>

**GitHub** — это одна из самых популярных платформ для хостинга Git-репозиториев. Она предоставляет мощные инструменты
для совместной работы, такие как pull requests, issues и GitHub Actions.

### Bitbucket

<img src="https://www.kaashivinfotech.com/blog/wp-content/uploads/2023/09/bitbucket9553.jpg" alt="drawing" width="300"/>

**Bitbucket** — это платформа для хостинга Git-репозиториев, которая также поддерживает Mercurial. Bitbucket предлагает
интеграцию с Jira и другие инструменты Atlassian для управления проектами.

### GitLab

<img src="https://media.zenfs.com/en/globenewswire.com/443dc008fa79aaaac01e22267ab1ec43" alt="drawing" width="300"/>

**GitLab** — это платформа для хостинга Git-репозиториев, которая также предоставляет CI/CD, issue tracking и множество
других функций для DevOps.

### И что с этим делать?

Любая из этих платформ предполагает, что вы должны на ней зарегистрироваться и войти в аккаунт.

После этого появится возможность создать свой собственный новый репозиторий

> Ну, или если мы говорим о коммерческой
> разработке, то, скорее всего, репозиторий уже создан и ваш аккаунт просто добавят к существующему репозиторию.

## Публичные и приватные репозитории

<img src="https://cdn.corporatefinanceinstitute.com/assets/private-vs-public.jpeg" alt="drawing" width="300"/>

### Публичные репозитории

`Публичный репозиторий` — это репозиторий, доступ к которому может получить любой пользователь. Публичные репозитории
обычно используются для открытых проектов и open-source разработки.

#### Преимущества публичных репозиториев

- Открытый доступ:

    - Любой пользователь может клонировать, просматривать и использовать код вашего проекта.
      Подходит для проектов с открытым исходным кодом, где важно участие сообщества.
      Вклад сообщества:

    - Позволяет другим разработчикам вносить свой вклад в проект через pull requests.
      Облегчает привлечение новых участников и сторонних разработчиков.
      Популяризация проекта:

    - Проект становится видимым и доступным для широкой аудитории.
      Упрощает демонстрацию вашего кода потенциальным работодателям или партнёрам.

#### Недостатки публичных репозиториев

- Ограниченная приватность:

    - Весь код и история коммитов видны всем пользователям.
      Могут возникнуть проблемы с защитой интеллектуальной собственности.

- Открытость уязвимостей:

    - Все уязвимости и ошибки в коде также видны всем пользователям.
    - Может потребоваться более тщательный контроль качества и безопасности кода.

### Приватные репозитории

`Приватный репозиторий` — это репозиторий, доступ к которому ограничен только определённым пользователям или командам.
Приватные репозитории обычно используются для закрытых проектов и коммерческой разработки.

#### Преимущества приватных репозиториев

- Контроль доступа:

    - Доступ к коду имеют только авторизованные пользователи.
    - Упрощает управление доступом и ролями в команде.

- Защита интеллектуальной собственности:

    - Код и информация о проекте остаются конфиденциальными.
    - Подходит для коммерческих проектов и внутренних разработок.

- Безопасность:

    - Уязвимости и ошибки в коде видны только определённым пользователям.
    - Облегчает внедрение мер по защите кода и данных.

#### Недостатки приватных репозиториев

- Ограниченное участие сообщества:

    - Вклад сообщества ограничен или невозможен.
    - Сложнее привлечь сторонних разработчиков и участников.

- Стоимость:

    - Многие платформы требуют плату за использование приватных репозиториев (например, GitHub).
    - В некоторых случаях требуется покупка лицензий или подписок.

### Примеры платформ и их подходов к приватности

#### GitHub:

- Поддерживает как публичные, так и приватные репозитории.
- Публичные репозитории бесплатны, за приватные может взиматься плата в зависимости от тарифного плана.

#### GitLab:

- Поддерживает публичные и приватные репозитории.
- Предлагает бесплатные приватные репозитории с базовым функционалом, а также платные планы с расширенными
  возможностями.

#### Bitbucket:

- Поддерживает публичные и приватные репозитории.
- Обычно приватные репозитории доступны бесплатно для небольших команд, а для больших команд и организаций могут
  потребоваться платные планы.

> Выбор между публичными и приватными репозиториями зависит от специфики вашего проекта и ваших требований. Публичные
> репозитории подходят для open-source проектов и привлечения сообщества, тогда как приватные репозитории обеспечивают
> защиту интеллектуальной собственности и конфиденциальность.
>
> Понимание различий между этими типами репозиториев поможет вам сделать правильный выбор для вашего проекта и
> эффективно
> управлять доступом к коду.

Для обучения мы будем использовать публичные репозитории, на работе скорее всего будут приватные репозитории.

## Варианты доступа к Git-репозиториям. HTTPS vs SSH

![](https://learn.microsoft.com/ru-ru/devops/_img/git_repositories.png)

Git-репозитории могут быть доступны через два основных протокола: `SSH` и `HTTPS`. Мы пока что не будем разбирать их
особенности, сделаем это намного дальше по курсу. Каждый из этих способов имеет свои особенности, и выбор между ними
зависит от ваших требований и предпочтений.

### Доступ через HTTPS

<img src="https://timeweb.com/ru/community/article/3c/3c7872a45aa48d237485875cbc7c604a.png" alt="drawing" width="300"/>

`HTTPS` (*HyperText Transfer Protocol Secure*) — это протокол, который использует шифрование SSL/TLS для защиты
передаваемых данных. Доступ к Git-репозиториям через HTTPS требует аутентификации (логин+пароль или токен, в зависимости от платформы).

Пример URL для доступа через HTTPS:

```shell
https://github.com/username/repository.git
```

- Преимущества HTTPS:

    - Простота настройки: Для доступа через HTTPS достаточно иметь логин и пароль. Это удобно для новичков и быстрого
      начала
      работы.
    - Работа в ограниченных сетях: HTTPS легко проходит через брандмауэры и прокси-серверы, что делает его хорошим
      выбором для
      работы в корпоративных сетях.
    - Универсальность: HTTPS доступен на любом устройстве и операционной системе без дополнительной настройки.

- Недостатки HTTPS:

    - Неудобство частого ввода пароля: При каждом взаимодействии с удалённым репозиторием требуется вводить логин и
      пароль,
      что может быть неудобно.
    - Ограниченная безопасность: Хотя HTTPS обеспечивает шифрование данных, использование логина и пароля может быть
      менее
      безопасным по сравнению с SSH-ключами.

### Доступ через SSH

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSWiur6gBG_EmmM5xTGMxqrR8IkWkuKJRdlBw&s)

`SSH` (*Secure Shell*) — это протокол, который предоставляет защищённый способ доступа к удалённым системам. Доступ к
Git-репозиториям через SSH осуществляется с использованием пары SSH-ключей (открытого и закрытого ключа).

Пример URL для доступа через SSH:

```shell
git@github.com:username/repository.git
```

- Преимущества SSH:

    - Безопасность: SSH использует криптографическую пару ключей, что обеспечивает высокий уровень безопасности. Пароль
      не
      передаётся по сети, что уменьшает риск его перехвата.
    - Удобство использования: После первоначальной настройки SSH-ключей нет необходимости вводить пароль при каждом
      взаимодействии с репозиторием.
    - Гибкость: SSH позволяет настраивать доступ для разных пользователей и ключей, что удобно для управления командой
      разработчиков.

- Недостатки SSH:

    - Сложность настройки: Настройка SSH-ключей требует некоторых технических знаний и больше времени по сравнению с
      HTTPS.
    - Ограничения на уровне сети: В некоторых корпоративных сетях доступ через SSH может быть ограничен или
      заблокирован.

## Примеры использования и настройки

### Настройка доступа через HTTPS

Клонирование репозитория через HTTPS:

```shell
git clone https://github.com/username/repository.git
```

> На GitHub вместо пароля используется токен (Personal Access Token, PAT).
> Чтобы не вводить его каждый раз, можно настроить менеджер учётных данных (credential manager).

### Настройка доступа через SSH

#### Создание SSH-ключей:

Самый простой способ создания пары ключей для `SSH` — использовать консоль Linux. Если вы используете Windows,
то можете использовать консоль, которая была установлена вместе с Git. Там эти команды тоже будут работать.

```shell
ssh-keygen -t ed25519 -C "your_email@example.com"
```

Следуйте инструкциям и сохраните ключи в файлах по умолчанию (`~/.ssh/id_ed25519` и `~/.ssh/id_ed25519.pub`).

> В Windows путь будет другой, убедитесь, что вы запомнили, где будут созданы ключи!

#### Добавление публичного ключа в аккаунт Git-платформы:

Скопируйте содержимое файла `~/.ssh/id_ed25519.pub` (или ваш путь для Windows) и добавьте его в настройки SSH-ключей на
платформе (например, GitHub, GitLab, Bitbucket).

#### Клонирование репозитория через SSH:

```shell
git clone git@github.com:username/repository.git
```

### Про git clone

Команда `git clone` создаёт локальную копию удалённого репозитория. `Fork` — это операция на платформе (GitHub/GitLab/и т.д.), при которой создаётся ваш собственный удалённый репозиторий, связанный с исходным.

Если вы работаете по схеме форка, добавьте исходный репозиторий как `upstream` и периодически подтягивайте обновления:

```sh
git remote add upstream https://github.com/ORIGINAL/REPO.git
git fetch upstream
git checkout main
git merge upstream/main   # или: git rebase upstream/main
```

### Выводы

Выбор между HTTPS и SSH для доступа к Git-репозиториям зависит от ваших требований и предпочтений. HTTPS проще в
настройке и подходит для быстрого начала работы, особенно в ограниченных сетях. SSH обеспечивает более высокий уровень
безопасности и удобства использования после первоначальной настройки.

Понимание различий между этими протоколами и их преимуществ поможет вам выбрать наиболее подходящий способ доступа к
вашим Git-репозиториям и обеспечит надёжное управление проектами.

> В рамках курса мы будем использовать именно SSH-ключи!

## Работа с удалёнными репозиториями

Для того чтобы несколько разработчиков могли работать над одним удалённым репозиторием, они все должны быть подключены
к одному удалённому репозиторию — Git об этом должен как-то узнать.

### Добавление удалённого репозитория

Чтобы добавить удалённый репозиторий, используется команда `git remote add`:

```sh
git remote add origin <URL>
```

Здесь `origin` — это стандартное имя для удалённого репозитория. Вы можете использовать любое другое имя, если хотите.
Но обычно, если у вас один удалённый репозиторий, то он называется именно так.

### Просмотр удалённых репозиториев

Чтобы посмотреть список всех настроенных удалённых репозиториев, используйте команду:

```sh
git remote -v
```

### Удаление удалённого репозитория

Чтобы удалить удалённый репозиторий, используйте команду:

```sh
git remote remove <name>
```

### Изменение URL удалённого репозитория

Чтобы изменить URL удалённого репозитория, используйте команду:

```sh
git remote set-url origin <new-url>
```

## Команды `push` и `pull`

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRa4YtyxtmRuCushR9ethewfblfvOobpHa5yw&s)

### Команда `git push`

`git push` — это команда для отправки ваших локальных изменений в удалённый репозиторий. Она передаёт коммиты из
локальной ветки в соответствующую ветку удалённого репозитория.

```sh
git push origin main
```

Эта команда отправляет изменения из локальной ветки `main` в ветку `main` на удалённом репозитории `origin`.
Также удобно единожды задать отслеживаемую ветку (upstream):
```sh
git push -u origin feature-branch
```
После этого достаточно просто `git push`.


Если ветка существует только локально, но не существует на удалённом репозитории, Git покажет ошибку и подскажет
команду, которую надо выполнить, чтобы успешно запушить код и создать ветку на удалённом репозитории.

### Force push: когда и как (и почему лучше `--force-with-lease`)

Иногда после переписывания истории (например, `git rebase -i`, `git commit --amend`, `git reset`) ваш локальный граф расходится с удалённым. Обычный `git push` откажется, потому что это не fast-forward. В таких случаях возникает желание «форс-пушнуть».

- Что делает force push
  - `git push --force` переписывает удалённую ветку под ваш локальный HEAD, потенциально затирая чужие коммиты.
  - Это опасно на общих ветках: можно случайно уничтожить работу коллег.

- Безопасная альтернатива
  - Используйте `--force-with-lease` — он пушит только если на удалённой ветке нет новых коммитов, которых нет у вас локально.
  - Это защищает от перезаписи чужой работы.

```sh
# После rebase в вашей фиче
git push --force-with-lease
# Явно указать удалённый и ветку
git push --force-with-lease origin feature-branch
```

- Когда это уместно
  - Личные/фича-ветки, где вы единственный коммитер и команда согласна на переписывание истории ради аккуратного PR.
  - Никогда не делайте force push в `main`/`master`/`release` и другие общие или защищённые ветки.

- Этикет и защита
  - Предупреждайте команду в PR, если предстоит force push; не делайте его во время активного ревью без согласования.
  - На платформах (GitHub/GitLab) включайте защиту веток: запрет force push, требование PR, обязательные проверки.

- Что делать, если что-то пошло не так
  - Если ветку перезаписали, можно восстановить коммиты через `git reflog` на машине, где они ещё есть:
```sh
git reflog                 # найти нужный SHA
git branch rescue <SHA>    # создать «спасательную» ветку на тот коммит
```

### Команда `git pull`

`git pull` — это команда для получения и объединения изменений из удалённого репозитория в вашу локальную ветку. Эта
команда сочетает в себе команды `git fetch` и `git merge`.

#### git fetch

Эта команда получает из удалённого репозитория всю информацию, которая отличается от вашей локальной версии. **Ничего не
меняет!** Только получает информацию, что что-то изменилось.

#### git merge

Уже обсуждали, повторю: объединяет две ветки. В данном случае локальную и удалённую с одинаковыми названиями.

Использование двух команд вместо команды `pull` не встречается на практике.

```sh
git pull origin main
```

Безопаснее использовать только fast-forward-слияние:
```sh
git pull --ff-only
```
Или, если политика команды — rebase:
```sh
git pull --rebase
```

Эта команда получает изменения из ветки `main` удалённого репозитория `origin` и объединяет их с локальной
веткой `main`.

## Pull Request

<img src="https://www.atlassian.com/blog/wp-content/uploads/bitbucket411-blog-1200x-branches2.png" alt="drawing" width="500"/>

**Pull Request (PR)** — это механизм для предложения изменений в проекте. Он позволяет другим разработчикам просмотреть
ваш код перед его включением в основную ветку проекта. Pull request включает в себя описание изменений, обсуждение,
ревью кода и возможность автоматического тестирования.

На GitLab это называется Merge Request (MR); смысл тот же.

> Именно так и надо будет сдавать домашние задания и модули — в виде pull request'ов.

### Процесс создания Pull Request

1. **Клонирование репозитория**:
    - Клонируйте репозиторий на ваш локальный компьютер.
> Если у вас нет прав на запись, сначала сделайте форк на платформе и клонируйте свой форк. Исходный репозиторий можно добавить как `upstream` для синхронизации.

   ```sh
   git clone <URL>
   ```

2. **Создание новой ветки**:
    - Создайте новую ветку для ваших изменений.

   ```sh
   git checkout -b feature-branch
   ```

3. **Внесение изменений и коммит(ы)**:
    - Внесите необходимые изменения и создайте коммит(ы).

   ```sh
   git add .
   git commit -m "Добавлено новое изменение"
   ```

4. **Отправка изменений в удалённый репозиторий**:
    - Отправьте изменения в ваш удалённый репозиторий на GitHub, Bitbucket или GitLab.

   ```sh
   git push origin feature-branch
   ```

5. **Создание Pull Request**:
    - Перейдите на страницу вашего репозитория на платформе и создайте новый pull request, выбрав основную ветку проекта
      и вашу ветку с изменениями.

> Этот процесс выглядит по-разному на каждом сайте, но суть всегда одна и та же. На занятии покажу, как это выглядит на GitHub.

6. **Ревью и обсуждение**:
    - Ведите обсуждение изменений с другими разработчиками. Возможно, вам потребуется внести дополнительные изменения.

7. **Мерджинг Pull Request**:
    - После завершения ревью и одобрения изменений ваш pull request может быть объединён с основной веткой проекта.

## Про совместную работу

Для того чтобы я мог проверять ваши домашки, я должен быть добавлен в ваш репозиторий как коллаборатор.

Для этого надо:

1) Открыть свой репозиторий
2) Перейти в настройки (Settings)
3) Найти там Collaborators
4) Нажать добавить (Add people)
5) Вписать мой ник `PonomaryovVladyslav`
6) Дождаться, пока я подтвержу участие в проекте

> Эти действия нужно выполнять для каждого созданного репозитория (Домашки, Модули, Веб — лучше всего для разных проектов и разделов обучения создавать новый репозиторий).

## Git Flow

> Примечание: вместо `master` в большинстве новых репозиториев используется `main`. Ниже под основной веткой понимается `main` (иногда её называют `master`). В примерах будем использовать `main`.


Когда дело доходит до работы, возникает очень важный вопрос — как будем использовать Git?

На самом деле это очень сложный вопрос, и на него нет правильного ответа.

Но если мы живём в идеальном мире, где у нас небольшая команда, есть профильные девопсы, мы используем только один
репозиторий и релизы у нас выходят только раз в конце спринта, то в 2010 году за нас придумали правильный ответ.

Ответ называется Git Flow. И несмотря на все описанные выше «или» и количество статей с матом на этот подход, я ещё
никогда не видел структуры, которая работала бы лучше при нормальных условиях.

### Что же это такое?

Если одной страшной картинкой — то вот:

![](https://habrastorage.org/r/w1560/webt/oj/ir/hp/ojirhpa9ozvcpsejgei2azb0vo0.png)

Давайте разбираться.

При таком подходе нам необходимы две long-term ветки — то есть те, которые будут жить долго.

Это будут ветки `main` (иногда её называют `master`) и `develop`.

Если на пальцах, то `main` — это ветка с последней продакшен-версией (иногда она называется `master`).

А `develop` — это то, что сейчас находится в разработке всей командой.

Обычно проект инициализируют в основной ветке и делают первый коммит, затем от неё создают `develop` (либо создают её позже при необходимости).

### Соглашения по именованию веток

- feature/<ticket-id>-<slug>
- release/<major>.<minor> (или <major>.<minor>.<patch>)
- hotfix/<major>.<minor>.<patch>

### Политика слияний (внутри Git Flow)

- Feature → develop: договоритесь, как мержить — squash merge (чистая история) или `--no-ff` (сохранять ветку).
- Release → main и Release → develop: мержим релизную ветку в обе; на `main` ставим тег версии.
- Hotfix → main и → develop: хотфикс идёт в прод, а также обратно в `develop` (и в открытую release-ветку, если она есть), чтобы правка не потерялась.

### Правила защиты веток

Protected: `main`, `develop`, `release/*`

- Требуются PR и ревью
- Запрет на прямой push и force push

### Синхронизация feature‑веток

- Регулярно подтягивайте изменения из `develop` в свою feature-ветку (например, `git pull --rebase origin develop`), чтобы уменьшить конфликты при слиянии.

### Фича

**Фича** (`feature`) — это реализация одной задачи из бэклога. Например, добавить на сайт логин — логин и будет
фичей.

При таком подходе к Git для каждой фичи создаётся отдельная ветка из ветки `develop`.

После завершения разработки создаётся pull request в ветку `develop`, чтобы обновить на ней текущий код.

По сути `develop` — это местная свалка всего нового кода, который только есть.

### Релизная ветка

Когда команда считает, что пора отдавать фичи на тестирование, из ветки `develop` создаётся ветка `release-x.x`,
где `x.x` — это условный номер релиза.

При редких релизах и выделенных тестовых окнах Git Flow удобен и прозрачен. Если релизы частые и практикуется CD, проще подходят GitHub Flow (`main` + короткие feature-ветки) или Trunk-Based Development (малые инкременты, фичефлаги). Выбирайте стратегию под процессы команды и требования к выпуску.

Из неё происходит деплоймент на тестовый сервер, где тестировщики ищут баги. Если баги незначительные, то прямо в релизной
ветке они фиксятся. Если значительные — возвращаем релиз разработчикам, они всё переделывают и создают новую ветку
релиза.

После того как релизная ветка прошла все тесты и готова к тому, чтобы обновлять продакшен, из неё создаются два pull
PR: в `develop` и в `main`.

В `develop` — чтобы добавить багофиксы (если были). В `main` — чтобы выполнить деплоймент на продакшен.

В `main` после слияния обычно создаётся тег, чтобы была возможность откатить до прошлого тега без особой сложности.

### Hot fix

Но что делать, если задеплоили продакшен и тут же обнаружили небольшой и легко исправляемый баг? Не проходить же всю
процедуру с начала, пока у клиентов явно есть баг?

Для этого придумали хотфикс-ветки: их создают прямо из `main` и вливают обратно в `main` и в `develop` (и при необходимости — в открытую `release/*`). Итого:
в `main`, чтобы задеплоить исправление бага, и в `develop`, чтобы этот баг не попадал в новые фичи.

### Выводы и реальность

Если для проекта нормально применение такого подхода, то я бы очень рекомендовал его применять. Но в реальности
практически всегда находятся проблемы, которые не совпадают с таким подходом, поэтому очень часто я видел вариации на
тему Git Flow, а не его самого.

Но идея очень крутая, всё структурировано понятно, и можно найти — кто, что и когда.

## Как сдавать домашки

Для этого есть вот [эта](pr_explanation.md) инструкция!

Жду код первого модуля в виде pull request'а! Всем удачи!

---

[← Лекция 7: Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md) | [Лекция 9: Введение в ООП. Основные парадигмы ООП. Классы и объекты. Множественное наследование. →](lesson09.md)