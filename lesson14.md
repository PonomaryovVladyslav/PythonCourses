# Лекция 14. Проектирование. Паттерны. SOLID.

### Оглавление курса

- Блок 1 — Python Basic (1–6):
  - [Лекция 1. Введение. Типизации. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.](lesson02.md)
  - [Лекция 3: None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter.](lesson05.md)
  - [Лекция 6. Рекурсия. Алгоритмы. Бинарный поиск, сортировки](lesson06.md)
- Блок 2 — Git (7–8):
  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md)
  - [Лекция 8. Git. Удаленный репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.](lesson08.md)
- Блок 3 — Python Advanced (9–14):
  - [Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты.](lesson09.md)
  - [Лекция 10. Множественное наследование. MRO. Magic methods.](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - ▶ **Лекция 14. Проектирование. Паттерны. SOLID.**
- Блок 4 — SQL (15–17):
  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи.](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. Group by. Joins.](lesson16.md)
  - [Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup](lesson17.md)
- Вне блоков:
  - [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv.](lesson18.md)
- Блок 5 — Django (19–26):
  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy.](lesson21.md)
  - [Лекция 22. Django ORM.](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication.](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
- Блок 6 — Django Rest Framework (27–30):
  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework.](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST аутентификация. Авторизация. Permissions. Фильтрация.](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API.](lesson30.md)
- Блок 7 — Python async (31–33):
  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Асинхронное программирование в Python. Корутины. Asyncio.](lesson32.md)
  - [Лекция 33. Сокеты. Django channels.](lesson33.md)
- Блок 8 — Deployment (34–35):
  - [Лекция 34. Linux. Все что нужно знать для деплоймента.](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
- Вне блоков:
  - [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


![](https://habrastorage.org/r/w780/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg)

## Что такое проектирование?

Проектирование в программной инженерии — это процесс создания архитектуры системы. Оно включает в себя выбор структур
данных, алгоритмов, интерфейсов и других элементов, которые обеспечивают функциональность и производительность
программного продукта.

### Виды проектирования

1. Архитектурное проектирование: Определение общей структуры системы, ее компонентов и их взаимодействий.
2. Проектирование компонентов: Разработка отдельных модулей или компонентов системы.
3. Проектирование интерфейсов: Определение способов взаимодействия между компонентами системы.

### Принципы хорошего проектирования

1. Простота: Проект должен быть максимально простым и понятным.
2. Модульность: Система должна состоять из отдельных, легко заменяемых модулей.
3. Расширяемость: Легкость добавления нового функционала.
4. Повторное использование: Возможность использования компонентов в других проектах.

## OOA --> OOD --> OOP

OOA - объектно-ориентированный анализ. Если страшной терминологией, то это методология, при которой требования к системе
воспринимаются с точки зрения классов и объектов, выявленных в предметной области.

> Если человеческими словами, то это о том, чтобы понять, какие у нас вообще будут объекты, будут ли они между собой
> взаимодействовать, и если будут, то какие и как

OOD - объектно-ориентированный дизайн. Опять же, если страшными терминами, то это методология проектирования,
соединяющая в себе процесс объектной декомпозиции и приёмы представления логической и физической, а также статической
и динамической моделей проектируемой системы.

> Если человеческими словами, то это о том, чтобы продумать, какие паттерны проектирования мы можем применить, чтобы
> наши объекты взаимодействовали понятно, сопровождаемо и расширяемо. Как добиться того, чтобы у нас появились те
> самые `простота`, `модульность`, `расширяемость` и `повторное использование`.


![](https://intellect.icu/th/25/blogs/id7888/2351a98acf1a7d963aed72c6a6b8c0a2.jpg)

### Как это работает?

OOA - это оценка того, какие проблемы должна решать система и какие сущности у нас вообще существуют (допустим, при
проектировании интернет-магазина нужно понимать, что у нас будут сущности пользователя, товара, заказа и т. д.)

OOD - это проектирование необходимых классов и того, как они будут взаимодействовать. (Понимание, что заказ будет
совершать пользователь, при этом заказ может быть розничным и оптовым, и для того, чтобы их просчитать, необходима
различная логика, какие паттерны мы можем применить (об этом немного ниже))

OOP в этой схеме — это конкретная реализация того, что было продумано на этапе OOD, основываясь на принципах OOP
(садимся и пишем код и тесты).

## Подход к проектированию

Вне зависимости от того, что вы разрабатываете, всегда можно применять два принципа:

> **KISS** = Keep it simple, stupid (Чем проще, тем лучше! Если всё можно описать двумя классами, в которых 3 метода, то
> не надо описывать 10 классов с 30-ю методами.)

> **DRY** = Don't repeat yourself (Не повторяйся! Если ты используешь один и тот же код в разных местах, сделай из него
> функцию или метод)


- YAGNI (You Aren’t Gonna Need It): не добавляйте абстракции и опции «на будущее». Упростить позже сложно; добавить по мере необходимости проще.
- EAFP vs LBYL: в Python предпочитают EAFP (Easier to Ask for Forgiveness than Permission) — пробовать и обрабатывать исключения, вместо многослойных проверок условий.

Существует очень много различных подходов к разработке. Разбирать их детально, мы не будем.

Но посмотрим на два распространенных подхода `Data-driven development` и `Test-driven development`.

## Data-driven development

![](https://hackernoon.com/hn-images/1*qizSjIsG8p2LouZkBeCuTA.jpeg)

> Не путайте Data‑driven development с Domain‑Driven Design (DDD). Здесь речь о подходе, где решения опираются на данные/метрики, а не о моделировании домена (DDD).

Это классический подход к разработке приложений, где во главе угла стоят данные.

Все действия описаны на схеме

1. Планируем что-то сделать
2. Анализируем полученный на этапе планирования запрос
3. Проектируем проект
4. Имплементируем (пишем код)
5. Пишем тесты
6. Поддерживаем приложение

## Test-driven development

![](https://images.spiceworks.com/wp-content/uploads/2022/09/29095630/How-TDD-Works.png)

Test-driven development - это подход к разработке, когда тесты пишутся до кода. Смысл в том, что если проектирование
было проведено правильно, то ты заранее знаешь, какие в твоей системе будут действия, и как система должна реагировать
на разные действия. Тогда можно написать тесты, которые будут отвечать требованиям проектирования, и только после этого
писать код, который будет соответствовать уже написанным тестам.

В этом случае шаги 4 и 5 меняются местами. Такой подход встречается реже, но так тоже делают, поэтому не удивляемся

TDD цикл: Red → Green → Refactor — сначала пишем падающий тест (Red), затем минимальную реализацию для прохождения (Green), потом наводим порядок в коде (Refactor).

когда видим такие термины.

## SOLID

![](https://miro.medium.com/v2/resize:fit:751/1*GoLwqfeB624NB5g7JPVyBA.png)

SOLID - это свод пяти основных принципов ООП, введенный Майклом Фэзерсом в начале нулевых. Эти принципы — часть общей
стратегии гибкой и адаптивной разработки, их соблюдение облегчает расширение и поддержку проекта.

### Принципы

SOLID принципы советуют, как проектировать модули.

> Цель принципов — проектировать модули, которые:
> - способствуют изменениям
> - легко понимаемы
> - повторно используемы

#### SRP: The Single Responsibility Principle (S)

![](https://miro.medium.com/v2/resize:fit:811/1*KUlMnDJYwy3FmID5HFgtJg.png)

> A module should be responsible to one, and only one, actor.


Примечание: под «одним актором» (actor) понимают заинтересованную сторону, для которой модуль несёт ответственность. Класс, который и валидирует данные, и сохраняет их в БД, и логирует — имеет несколько причин для изменения и нарушает SRP.

Старая формулировка: `A module should have one, and only one, reason to change`.

`Принцип единой ответственности`

Часто ее трактовали следующим образом: Модуль должен иметь только одну обязанность.

> Каждый класс должен решать одну конкретную задачу. Программист не должен одновременно быть уборщицей и поваром.

Один класс одна ответственность!


Python‑подход: вместо жёсткого наследования чаще используйте композицию, стратегии (передача функции/объекта), регистрацию обработчиков и расширение через плагины; это позволяет добавлять поведение без правки существующего кода.

#### OCP: The Open Closed Principle (O)

![](https://media.licdn.com/dms/image/D5612AQE_CW8knS38zw/article-cover_image-shrink_720_1280/0/1679406399966?e=2147483647&v=beta&t=3AUCuCP7qgVz0nBGSsvbDNVdl_JMmXP_E5_VI3-gc-8)

> A software artifact should be open for extension but closed for modification.

Корректная подстановка означает, что замена пред- и постусловий не ломает ожидания клиента. Классический антипример: «Квадрат наследуется от Прямоугольника» — изменение одной стороны меняет вторую и нарушает контракт прямоугольника.


`Принцип открытости/закрытости` гласит, что программные сущности должны быть открыты для расширения, но закрыты для
модификации. Это означает, что мы можем добавлять новый функционал, не изменяя существующий код.

#### LSP: The Liskov Substitution Principle (L)

![](https://media.licdn.com/dms/image/D4E12AQHkeXa87_C0LQ/article-cover_image-shrink_720_1280/0/1671577706434?e=2147483647&v=beta&t=AsUbafBvcH731OIN5Q7EQf3nGRukb28rCHrmnUIT_Yk)

`Принцип подстановки Барбары Лисков` - класс потомок должен иметь возможность заменить родителя.

Если мы из отвертки, сделали класс мультитул, значит что мультитул тоже должен уметь закручивать шурупы.

Если класс родитель делал кофе, а класс потомок начал продавать наркотики, то что-то у нас пошло не так.

#### ISP: The Interface Segregation Principle (I)

![](https://miro.medium.com/v2/resize:fit:811/0*PidC9ftwMaxgB-km.png)

> Make fine grained interfaces that are client specific.

В Python удобно дробить интерфейсы через абстракции и typing.Protocol (структурные интерфейсы) — клиентам передаём лишь то, что им действительно нужно.


`Принцип разделения интерфейсов` — Представьте себе кофемашину, у которой всего одна кнопка (интерфейс), и чтобы сделать
капучино, нужно нажать на неё 4 раза. А чтобы латте — зажать кнопку два раза по 5 секунд. Удобно таким пользоваться?
Я думаю, что катастрофически нет.

Если есть метод(функция), который при разных входных данных ведёт себя по-разному, то лучше написать несколько методов(
функций).

Чем меньше нагружены функции/методы, тем проще их поддерживать и тестировать.

#### DIP: The Dependency Inversion Principle (D)

![](https://toidicodedao.com/wp-content/uploads/2016/05/oop-principles-15-638.jpg)

> Depend on abstractions, not on concretions.

`Принцип инверсии зависимостей`. Если страшными словами, то модули верхних уровней не должны зависеть от модулей нижних
уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны
зависеть от абстракций.


Пример внедрения зависимостей (DIP):

````python
class Storage: ...

class Service:
    def __init__(self, store: Storage):
        self.store = store
````

Если нормальным языком. В вашей реализации должно быть как можно меньше деталей до момента когда эти детали необходимы.

Возьмем пример с бургером. Если ваш базовый класс бургера содержит сразу все возможные начинки, соусы и все виды мяса,
причём по 5 штук, а чтобы сделать конкретный бургер, нужно убрать всё лишнее. Будет ли удобно пользоваться таким
классом?

Я думаю, что нет. В этом и суть: детали появляются только в тот момент, когда они нужны. Но на более верхнем уровне вполне
может быть описана абстракция. В бургере могут быть соус, мясо, овощи, сыр и т. д. Но это не значит, что они сразу там
должны быть.

### Еще раз на всякий случай

> Принципы SOLID стремятся свести изменение модулей к их добавлению и удалению.

> Принципы SOLID способствуют откладыванию принятия технических решений и разделению труда программистов.

Таким образом:

- Принцип единственной ответственности (Single responsibility)

> На каждый объект должна быть возложена одна единственная обязанность

Для этого проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный
класс.

- Принцип открытости/закрытости (Open-closed)

> Программные сущности должны быть открыты для расширения, но закрыты для модификации

Для этого представляем наш класс как «черный ящик» и смотрим, можем ли в таком случае изменить его поведение.

- Принцип подстановки Барбары Лисков (Liskov substitution)

> Объекты в программе могут быть заменены их наследниками без изменения свойств программы

Для этого проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло — то принцип не
соблюдается.

- Принцип разделения интерфейса (Interface segregation)

> Много специализированных интерфейсов лучше, чем один универсальный

Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если
необходимо — разбиваем интерфейсы.

- Принцип инверсии зависимостей (Dependency Inversion)

> Зависимости должны строиться относительно абстракций, а не деталей

Проверяем, зависят ли классы от каких-то других классов (непосредственно инстанцируют объекты других классов и т. д.) и
если эта зависимость имеет место, заменяем на зависимость от абстракции.

## Паттерны проектирования

![](https://kloud-blogwpsite-ause-prd-web.azurewebsites.net/wp-content/uploads/2017/02/60288347.jpg)

На самом деле, паттерн - это просто любая шаблонная конструкция, которую можно использовать несколько раз. И вы даже
знаете несколько паттернов, только не знаете, что это паттерны.

Например, декоратор, итератор, генератор (нет, не все паттерны заканчиваются на -ратор). Но это те вещи которые вы уже
видели. Декоратор, это реализация паттерна. Если вы запускали цикл фор, то вы запускали паттерн итератор. А если у вас
там был написан `range` то вы использовали паттерн генератор.

Паттернов существует просто огромное количество, настолько огромное, что существуют сотни книг по паттернам
проектирования. [Тут](https://refactoring.guru/ru/design-patterns/catalog) можно посмотреть на многие из них, но далеко
не на все.

## Что такое паттерн?

Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

> В отличие от готовых функций или библиотек паттерн нельзя просто взять и скопировать в программу. Паттерн представляет
> собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить
> под нужды вашей программы.

Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если
алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может
отличаться в двух разных программах.

> Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на
> котором
> нарисовано решение, но не конкретные шаги его реализации.

### Из чего состоит паттерн?

Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:

- проблема, которую решает паттерн;
- мотивация к решению проблемы способом, который предлагает паттерн;
- структура классов, составляющих решение;
- пример на одном из языков программирования;
- особенности реализации в различных контекстах;
- связи с другими паттернами.

Такой формализм в описании позволил создать обширный каталог паттернов, проверив каждый из них на состоятельность.

### Зачем знать паттерны?

> Вы можете вполне успешно работать, не зная ни одного паттерна. Более того, вы могли уже не раз реализовать какой-то из
> паттернов, даже не подозревая об этом.

Но осознанное владение инструментом как раз и отличает профессионала от любителя. Вы можете забить гвоздь молотком, а
можете и дрелью, если сильно постараетесь. Но профессионал знает, что главная фишка дрели совсем не в этом. Итак, зачем
же знать паттерны?

- `Проверенные решения`. Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда.
  До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.

- `Стандартизация кода`. Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так
  как все скрытые проблемы в них уже давно найдены.

- `Общий программистский словарь`. Вы произносите название паттерна, вместо того, чтобы час объяснять другим
  программистам, какой крутой дизайн вы придумали и какие классы для этого нужны.

## Классификация паттернов

Паттерны отличаются по уровню сложности, детализации и охвату проектируемой системы. Проводя аналогию со строительством,
вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной
развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — идиомы. Они не универсальны, поскольку применимы только в рамках одного языка
программирования.

Самые универсальные — архитектурные паттерны, которые можно реализовать практически на любом языке. Они нужны для
проектирования всей программы, а не отдельных её элементов.

- `Порождающие` паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

- `Структурные` паттерны показывают различные способы построения связей между объектами.

- `Поведенческие` паттерны заботятся об эффективной коммуникации между объектами

[Тут](https://refactoring.guru/) шикарный сайт с описанием некоторых паттернов и их реализации на разных языках
программирования.

## Рассмотрим некоторые паттерны

На сайте указанном выше, вы можете найти примеры, описания, варианты реализации на различных языках программирования. И
лучше и детальнее я не напишу, так что рекомендую детально ознакомится с сайтом. Но давайте все таки обсудим некоторые
паттерны на уровне идеи, зачем нужны и где вообще применимы.

### Одиночка (Singleton)

#### Описание:

Паттерн Одиночка гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому
экземпляру.

#### Применение:

- Управление подключением к базе данных, чтобы избежать множества подключений и, как следствие, экономить ресурсы.
- Логирование, чтобы обеспечить централизованное управление логами.
- Настройки приложения, чтобы убедиться, что все части программы используют одни и те же параметры конфигурации.

> Замечание: в Python роль «одиночки» часто играет сам модуль (его импортируется один раз и кешируется). По возможности предпочитайте внедрение зависимостей (DI) вместо глобального состояния.

### Фабричный метод (Factory Method)

#### Описание:

Паттерн Фабричный метод предоставляет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять
тип создаваемых объектов.

#### Применение:

- В приложениях, где точные классы объектов могут меняться в зависимости от контекста или конфигурации.
- При необходимости создания множества различных объектов, которые имеют общий интерфейс.

Пример мини‑фабрики:

````python
class Parser: ...
class JsonParser(Parser): ...
class XmlParser(Parser): ...

def make_parser(fmt: str) -> Parser:
    return JsonParser() if fmt == "json" else XmlParser()
````

### Абстрактная фабрика (Abstract Factory)

#### Описание:

Абстрактная фабрика предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без
указания их конкретных классов.

#### Применение:

- В системах, где необходимо создавать группы связанных объектов (например, наборы GUI-элементов для различных
  платформ).
- В кроссплатформенных приложениях для создания объектов, зависящих от операционной системы.

### Строитель (Builder)

#### Описание:

Паттерн Строитель позволяет создавать сложные объекты поэтапно. Он отделяет конструирование объекта от его
представления.

#### Применение:

- В приложениях, где необходима пошаговая конфигурация сложных объектов (например, составление документов, создание
  отчетов).
- Для создания объектов с большим числом опциональных параметров.

### Прототип (Prototype)

#### Описание:

Паттерн Прототип позволяет копировать объекты, не прибегая к их непосредственному созданию через конструктор.

#### Применение:

- В системах, где создание объектов требует значительных затрат ресурсов (например, клонирование объектов в графических
  редакторах).
- В играх для клонирования игровых объектов с определенными характеристиками.

### Адаптер (Adapter)

#### Описание:

Паттерн Адаптер позволяет объектам с несовместимыми интерфейсами работать вместе. Он преобразует интерфейс одного класса
в интерфейс, который ожидает клиент.

#### Применение:

- Для интеграции старого кода в новые системы без изменения самого старого кода.
- Для работы с классами, интерфейсы которых отличаются от необходимых.

Примечание: из‑за «утинотипизации» (duck typing) в Python адаптер часто не нужен — достаточно предоставить ожидаемые методы. Но при интеграции чужого API адаптер помогает согласовать интерфейсы.

### Мост (Bridge)

#### Описание:

Паттерн Мост разделяет абстракцию и реализацию, позволяя им изменяться независимо друг от друга.

#### Применение:

- В приложениях, где необходимо изменить реализацию абстракции во время выполнения.
- Для разработки кроссплатформенных GUI-приложений.

### Компоновщик (Composite)

#### Описание:

Паттерн Компоновщик позволяет объединять объекты в древовидные структуры для представления иерархий часть-целое. Клиенты
могут одинаково работать как с отдельными объектами, так и с их комбинациями.

#### Применение:

- В графических приложениях для построения сложных сцен из простых объектов.
- В системах управления файлами для работы с файловыми системами (директории и файлы).

### Декоратор (Decorator)

#### Описание:

Паттерн Декоратор позволяет динамически добавлять новые функциональности к объектам, не изменяя их классов.

#### Применение:

- В текстовых редакторах для добавления форматирования к тексту.
- В веб-приложениях для добавления новых возможностей к существующим объектам запроса и ответа.

### Стратегия (Strategy)

#### Описание:

Паттерн Стратегия определяет семейство алгоритмов, инкапсулирует их и делает их взаимозаменяемыми. Паттерн позволяет
изменять алгоритмы независимо от клиентов, которые их используют.

#### Применение:

- В системах, где необходимо изменять алгоритмы сортировки или поиска.
- В играх для реализации различных стратегий поведения персонажей.

Pythonic‑вариант стратегии — передать функцию/ключ сортировки:

````python
def by_len(x): return len(x)
def by_neg(x): return -x

sorted(data, key=by_len)  # замена стратегии выбором функции
````


## Практика

Спроектируйте мини‑сервис уведомлений, соблюдая принципы SOLID.

Требования:
- Определите интерфейс Notifier (через ABC или typing.Protocol)
- Реализуйте EmailNotifier и SMSNotifier (позже легко добавить PushNotifier)
- Используйте Strategy для форматирования сообщения (разные шаблоны)
- Внедрите зависимость Notifier в сервис (DIP) через конструктор
- Покройте ключевую логику простыми тестами (unittest/pytest — на выбор)

Подсказки:
- Предпочитайте композицию и DI, избегайте singletons
- Держите форматирование изолированным (стратегии как функции/объекты)

Мини‑скелет:

````python
from typing import Protocol

class Notifier(Protocol):
    def send(self, to: str, message: str) -> None: ...

class Service:
    def __init__(self, notifier: Notifier):
        self.notifier = notifier
    def notify_user(self, user_email: str, text: str) -> None:
        self.notifier.send(user_email, text)
````

Дополнительно:
- Перейдите ко [второму модулю](module2.md)
- Перед следующим занятием выполните всё по [этой ссылке](before_postgres.md)