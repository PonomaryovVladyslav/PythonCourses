# Лекция 14. Проектирование. Паттерны. SOLID.

### Оглавление курса

<details>
  <summary>Блок 1 — Python Basic (1–6)</summary>

  - [Лекция 1. Введение. Типизация. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы](lesson02.md)
  - [Лекция 3. None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш-таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter](lesson05.md)
  - [Лекция 6. Алгоритмы и структуры данных](lesson06.md)
</details>

<details>
  <summary>Блок 2 — Git (7–8)</summary>

  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием](lesson07.md)
  - [Лекция 8. Git. Удалённый репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request](lesson08.md)
</details>

<details open>
  <summary>Блок 3 — Python Advanced (9–14)</summary>

  - [Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты. Множественное наследование](lesson09.md)
  - [Лекция 10. Magic methods. Итераторы и генераторы](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP 8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - ▶ **Лекция 14. Проектирование. Паттерны. SOLID.**
</details>

<details>
  <summary>Блок 4 — SQL (15–17)</summary>

  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. GROUP BY. Joins](lesson16.md)
  - [Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup](lesson17.md)
</details>

- [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv](lesson18.md)

<details>
  <summary>Блок 5 — Django (19–26)</summary>

  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy](lesson21.md)
  - [Лекция 22. Django ORM](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
</details>

<details>
  <summary>Блок 6 — Django Rest Framework (27–30)</summary>

  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST-аутентификация. Авторизация. Permissions. Фильтрация](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API](lesson30.md)
</details>

<details>
  <summary>Блок 7 — Python async (31–33)</summary>

  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Asyncio. Aiohttp. Асинхронное программирование на практике.](lesson32.md)
  - [Лекция 33. Сокеты. Django Channels](lesson33.md)
</details>

<details>
  <summary>Блок 8 — Deployment (34–35)</summary>

  - [Лекция 34. Linux. Всё, что нужно знать для деплоймента](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
</details>

- [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


![](https://habrastorage.org/r/w780/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg)

## Что такое проектирование?

Проектирование в программной инженерии — это процесс создания архитектуры системы. Оно включает в себя выбор структур
данных, алгоритмов, интерфейсов и других элементов, которые обеспечивают функциональность и производительность
программного продукта.

### Виды проектирования

1. Архитектурное проектирование: определение общей структуры системы, её компонентов и их взаимодействий.
2. Проектирование компонентов: разработка отдельных модулей или компонентов системы.
3. Проектирование интерфейсов: определение способов взаимодействия между компонентами системы.

### Принципы хорошего проектирования

1. Простота: проект должен быть максимально простым и понятным.
2. Модульность: система должна состоять из отдельных, легко заменяемых модулей.
3. Расширяемость: лёгкость добавления нового функционала.
4. Повторное использование: возможность использования компонентов в других проектах.

## OOA --> OOD --> OOP

OOA — объектно-ориентированный анализ. Если страшной терминологией, то это методология, при которой требования к системе
воспринимаются с точки зрения классов и объектов, выявленных в предметной области.

> Если человеческими словами, то это о том, чтобы понять, какие у нас вообще будут объекты, будут ли они между собой
> взаимодействовать, и если будут, то какие и как.

OOD — объектно-ориентированный дизайн. Опять же, если страшными терминами, то это методология проектирования,
соединяющая в себе процесс объектной декомпозиции и приёмы представления логической и физической, а также статической
и динамической моделей проектируемой системы.

> Если человеческими словами, то это о том, чтобы продумать, какие паттерны проектирования мы можем применить, чтобы
> наши объекты взаимодействовали понятно, сопровождаемо и расширяемо. Как добиться того, чтобы у нас появились те
> самые `простота`, `модульность`, `расширяемость` и `повторное использование`.


![](https://intellect.icu/th/25/blogs/id7888/2351a98acf1a7d963aed72c6a6b8c0a2.jpg)

### Как это работает?

OOA — это оценка того, какие проблемы должна решать система и какие сущности у нас вообще существуют (допустим, при
проектировании интернет-магазина нужно понимать, что у нас будут сущности пользователя, товара, заказа и т. д.).

OOD — это проектирование необходимых классов и того, как они будут взаимодействовать (понимание, что заказ будет
совершать пользователь, при этом заказ может быть розничным и оптовым, и для того, чтобы их просчитать, необходима
различная логика; какие паттерны мы можем применить — об этом немного ниже).

OOP в этой схеме — это конкретная реализация того, что было продумано на этапе OOD, основываясь на принципах OOP
(садимся и пишем код и тесты).

## Подход к проектированию

Вне зависимости от того, что вы разрабатываете, всегда можно применять два принципа:

> **KISS** = Keep it simple, stupid (Чем проще, тем лучше! Если всё можно описать двумя классами, в которых 3 метода, то
> не надо описывать 10 классов с 30-ю методами.)

> **DRY** = Don't repeat yourself (Не повторяйся! Если ты используешь один и тот же код в разных местах, сделай из него
> функцию или метод.)


- YAGNI (You Aren’t Gonna Need It): не добавляйте абстракции и опции «на будущее». Упростить позже сложно; добавить по мере необходимости проще.
- EAFP vs LBYL: в Python предпочитают EAFP (Easier to Ask for Forgiveness than Permission) — пробовать и обрабатывать исключения, вместо многослойных проверок условий.

Существует очень много различных подходов к разработке. Разбирать их детально мы не будем.

Но посмотрим на два распространённых подхода: `Data-driven development` и `Test-driven development`.

## Data-driven development

![](https://hackernoon.com/hn-images/1*qizSjIsG8p2LouZkBeCuTA.jpeg)

> Не путайте Data‑driven development с Domain‑Driven Design (DDD). Здесь речь о подходе, где решения опираются на данные/метрики, а не о моделировании домена (DDD).

Это классический подход к разработке приложений, где во главе угла стоят данные.

Все действия описаны на схеме:

1. Планируем что-то сделать.
2. Анализируем полученный на этапе планирования запрос.
3. Проектируем проект.
4. Имплементируем (пишем код).
5. Пишем тесты.
6. Поддерживаем приложение.

## Test-driven development

![](https://images.spiceworks.com/wp-content/uploads/2022/09/29095630/How-TDD-Works.png)

Test-driven development — это подход к разработке, когда тесты пишутся до кода. Смысл в том, что если проектирование
было проведено правильно, то ты заранее знаешь, какие в твоей системе будут действия, и как система должна реагировать
на разные действия. Тогда можно написать тесты, которые будут отвечать требованиям проектирования, и только после этого
писать код, который будет соответствовать уже написанным тестам.

В этом случае шаги 4 и 5 меняются местами. Такой подход встречается реже, но так тоже делают, поэтому не удивляемся,
когда видим такие термины.

TDD-цикл: Red → Green → Refactor — сначала пишем падающий тест (Red), затем минимальную реализацию для прохождения (Green), потом наводим порядок в коде (Refactor).

## SOLID

![](https://miro.medium.com/v2/resize:fit:751/1*GoLwqfeB624NB5g7JPVyBA.png)

SOLID — это свод пяти основных принципов ООП, введённый Майклом Фэзерсом в начале нулевых. Эти принципы — часть общей
стратегии гибкой и адаптивной разработки, их соблюдение облегчает расширение и поддержку проекта.

### Принципы

SOLID-принципы советуют, как проектировать модули.

> Цель принципов — проектировать модули, которые:
> - способствуют изменениям
> - легко понимаемы
> - повторно используемы

#### SRP: The Single Responsibility Principle (S)

![](https://miro.medium.com/v2/resize:fit:811/1*KUlMnDJYwy3FmID5HFgtJg.png)

> A module should be responsible to one, and only one, actor.


Примечание: под «одним актором» (actor) понимают заинтересованную сторону, для которой модуль несёт ответственность. Класс, который и валидирует данные, и сохраняет их в БД, и логирует — имеет несколько причин для изменения и нарушает SRP.

Старая формулировка: `A module should have one, and only one, reason to change`.

`Принцип единой ответственности`

Часто её трактовали следующим образом: модуль должен иметь только одну обязанность.

> Каждый класс должен решать одну конкретную задачу. Программист не должен одновременно быть уборщицей и поваром.

Один класс — одна ответственность!

**❌ Плохо — класс делает слишком много:**

```python
class User:
    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email

    def save_to_database(self):
        # Сохранение в БД — это не ответственность User
        db.execute(f"INSERT INTO users ...")

    def send_welcome_email(self):
        # Отправка email — тоже не его дело
        smtp.send(self.email, "Welcome!")

    def generate_report(self):
        # И генерация отчётов тоже
        return f"Report for {self.name}"
```

**✅ Хорошо — разделение ответственностей:**

```python
class User:
    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user: User):
        db.execute(f"INSERT INTO users ...")

class EmailService:
    def send_welcome(self, user: User):
        smtp.send(user.email, "Welcome!")

class UserReportGenerator:
    def generate(self, user: User) -> str:
        return f"Report for {user.name}"
```

Python‑подход: вместо жёсткого наследования чаще используйте композицию, стратегии (передача функции/объекта), регистрацию обработчиков и расширение через плагины; это позволяет добавлять поведение без правки существующего кода.

#### OCP: The Open Closed Principle (O)

![](https://media.licdn.com/dms/image/D5612AQE_CW8knS38zw/article-cover_image-shrink_720_1280/0/1679406399966?e=2147483647&v=beta&t=3AUCuCP7qgVz0nBGSsvbDNVdl_JMmXP_E5_VI3-gc-8)

> A software artifact should be open for extension but closed for modification.

Корректная подстановка означает, что замена пред- и постусловий не ломает ожидания клиента. Классический антипример: «Квадрат наследуется от Прямоугольника» — изменение одной стороны меняет вторую и нарушает контракт прямоугольника.


`Принцип открытости/закрытости` гласит, что программные сущности должны быть открыты для расширения, но закрыты для
модификации. Это означает, что мы можем добавлять новый функционал, не изменяя существующий код.

**❌ Плохо — при добавлении нового типа нужно менять существующий код:**

```python
class DiscountCalculator:
    def calculate(self, customer_type: str, amount: float) -> float:
        if customer_type == "regular":
            return amount * 0.95
        elif customer_type == "vip":
            return amount * 0.85
        elif customer_type == "premium":  # Добавили новый тип — изменили класс!
            return amount * 0.80
        return amount
```

**✅ Хорошо — расширение через новые классы:**

```python
from abc import ABC, abstractmethod

class DiscountStrategy(ABC):
    @abstractmethod
    def calculate(self, amount: float) -> float: ...

class RegularDiscount(DiscountStrategy):
    def calculate(self, amount: float) -> float:
        return amount * 0.95

class VIPDiscount(DiscountStrategy):
    def calculate(self, amount: float) -> float:
        return amount * 0.85

class PremiumDiscount(DiscountStrategy):  # Новый класс — старый код не трогаем!
    def calculate(self, amount: float) -> float:
        return amount * 0.80

# Использование
def apply_discount(strategy: DiscountStrategy, amount: float) -> float:
    return strategy.calculate(amount)
```

#### LSP: The Liskov Substitution Principle (L)

![](https://media.licdn.com/dms/image/D4E12AQHkeXa87_C0LQ/article-cover_image-shrink_720_1280/0/1671577706434?e=2147483647&v=beta&t=AsUbafBvcH731OIN5Q7EQf3nGRukb28rCHrmnUIT_Yk)

`Принцип подстановки Барбары Лисков` — класс-потомок должен иметь возможность заменить родителя.

Если мы из отвёртки сделали класс мультитул, значит, мультитул тоже должен уметь закручивать шурупы.

Если класс-родитель делал кофе, а класс-потомок начал продавать наркотики, то что-то у нас пошло не так.

**❌ Плохо — классический антипример «Квадрат и Прямоугольник»:**

```python
class Rectangle:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height

    def set_width(self, width: int):
        self.width = width

    def set_height(self, height: int):
        self.height = height

    def area(self) -> int:
        return self.width * self.height

class Square(Rectangle):  # Квадрат — это прямоугольник?
    def set_width(self, width: int):
        self.width = width
        self.height = width  # Нарушаем ожидания!

    def set_height(self, height: int):
        self.width = height
        self.height = height

# Проблема:
def resize(rect: Rectangle):
    rect.set_width(5)
    rect.set_height(10)
    assert rect.area() == 50  # Для Square это упадёт!
```

**✅ Хорошо — отдельные классы или общий интерфейс:**

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self) -> int: ...

class Rectangle(Shape):
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height

    def area(self) -> int:
        return self.width * self.height

class Square(Shape):
    def __init__(self, side: int):
        self.side = side

    def area(self) -> int:
        return self.side ** 2
```

#### ISP: The Interface Segregation Principle (I)

![](https://miro.medium.com/v2/resize:fit:811/0*PidC9ftwMaxgB-km.png)

> Make fine grained interfaces that are client specific.

В Python удобно дробить интерфейсы через абстракции и typing.Protocol (структурные интерфейсы) — клиентам передаём лишь то, что им действительно нужно.


`Принцип разделения интерфейсов` — представьте себе кофемашину, у которой всего одна кнопка (интерфейс), и чтобы сделать
капучино, нужно нажать на неё 4 раза. А чтобы латте — зажать кнопку два раза по 5 секунд. Удобно таким пользоваться?
Я думаю, что катастрофически нет.

Если есть метод (функция), который при разных входных данных ведёт себя по-разному, то лучше написать несколько методов
(функций).

Чем меньше нагружены функции/методы, тем проще их поддерживать и тестировать.

**❌ Плохо — «толстый» интерфейс:**

```python
from abc import ABC, abstractmethod

class Worker(ABC):
    @abstractmethod
    def work(self): ...

    @abstractmethod
    def eat(self): ...

    @abstractmethod
    def sleep(self): ...

class Robot(Worker):
    def work(self):
        print("Working...")

    def eat(self):
        pass  # Роботы не едят! Но вынуждены реализовывать

    def sleep(self):
        pass  # И не спят!
```

**✅ Хорошо — мелкие специализированные интерфейсы:**

```python
from abc import ABC, abstractmethod

class Workable(ABC):
    @abstractmethod
    def work(self): ...

class Eatable(ABC):
    @abstractmethod
    def eat(self): ...

class Sleepable(ABC):
    @abstractmethod
    def sleep(self): ...

class Human(Workable, Eatable, Sleepable):
    def work(self): print("Working...")
    def eat(self): print("Eating...")
    def sleep(self): print("Sleeping...")

class Robot(Workable):  # Только то, что нужно
    def work(self): print("Working...")
```

#### DIP: The Dependency Inversion Principle (D)

![](https://toidicodedao.com/wp-content/uploads/2016/05/oop-principles-15-638.jpg)

> Depend on abstractions, not on concretions.

`Принцип инверсии зависимостей`. Если страшными словами, то модули верхних уровней не должны зависеть от модулей нижних
уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны
зависеть от абстракций.

**❌ Плохо — жёсткая зависимость от конкретной реализации:**

```python
class MySQLDatabase:
    def save(self, data: dict):
        print(f"Saving to MySQL: {data}")

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # Жёсткая привязка!

    def create_user(self, name: str):
        self.db.save({"name": name})

# Проблема: как протестировать без реальной БД?
# Как переключиться на PostgreSQL?
```

**✅ Хорошо — зависимость от абстракции:**

```python
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data: dict): ...

class MySQLDatabase(Database):
    def save(self, data: dict):
        print(f"Saving to MySQL: {data}")

class PostgreSQLDatabase(Database):
    def save(self, data: dict):
        print(f"Saving to PostgreSQL: {data}")

class FakeDatabase(Database):  # Для тестов!
    def save(self, data: dict):
        self.last_saved = data

class UserService:
    def __init__(self, db: Database):  # Зависимость внедряется
        self.db = db

    def create_user(self, name: str):
        self.db.save({"name": name})

# Использование
service = UserService(MySQLDatabase())
# Или для тестов:
fake_db = FakeDatabase()
service = UserService(fake_db)
```

Если нормальным языком: в вашей реализации должно быть как можно меньше деталей до момента, когда эти детали необходимы.

Возьмём пример с бургером. Если ваш базовый класс бургера содержит сразу все возможные начинки, соусы и все виды мяса,
причём по 5 штук, а чтобы сделать конкретный бургер, нужно убрать всё лишнее — будет ли удобно пользоваться таким
классом?

Я думаю, что нет. В этом и суть: детали появляются только в тот момент, когда они нужны. Но на более верхнем уровне вполне
может быть описана абстракция. В бургере могут быть соус, мясо, овощи, сыр и т. д. Но это не значит, что они сразу там
должны быть.

### Ещё раз на всякий случай

> Принципы SOLID стремятся свести изменение модулей к их добавлению и удалению.

> Принципы SOLID способствуют откладыванию принятия технических решений и разделению труда программистов.

Таким образом:

- Принцип единственной ответственности (Single responsibility)

> На каждый объект должна быть возложена одна единственная обязанность

Для этого проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный
класс.

- Принцип открытости/закрытости (Open-closed)

> Программные сущности должны быть открыты для расширения, но закрыты для модификации

Для этого представляем наш класс как «чёрный ящик» и смотрим, можем ли в таком случае изменить его поведение.

- Принцип подстановки Барбары Лисков (Liskov substitution)

> Объекты в программе могут быть заменены их наследниками без изменения свойств программы

Для этого проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло, то принцип не
соблюдается.

- Принцип разделения интерфейса (Interface segregation)

> Много специализированных интерфейсов лучше, чем один универсальный

Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если
необходимо — разбиваем интерфейсы.

- Принцип инверсии зависимостей (Dependency Inversion)

> Зависимости должны строиться относительно абстракций, а не деталей

Проверяем, зависят ли классы от каких-то других классов (непосредственно инстанцируют объекты других классов и т. д.), и
если эта зависимость имеет место, заменяем на зависимость от абстракции.

## Паттерны проектирования

![](https://kloud-blogwpsite-ause-prd-web.azurewebsites.net/wp-content/uploads/2017/02/60288347.jpg)

На самом деле паттерн — это просто любая шаблонная конструкция, которую можно использовать несколько раз. И вы даже
знаете несколько паттернов, только не знаете, что это паттерны.

Например, декоратор, итератор, генератор (нет, не все паттерны заканчиваются на «-ратор»). Но это те вещи, которые вы уже
видели. Декоратор — это реализация паттерна. Если вы запускали цикл for, то вы запускали паттерн «итератор». А если у вас
там был написан `range`, то вы использовали паттерн «генератор».

Паттернов существует просто огромное количество, настолько огромное, что существуют сотни книг по паттернам
проектирования. [Тут](https://refactoring.guru/ru/design-patterns/catalog) можно посмотреть на многие из них, но далеко
не на все.

## Что такое паттерн?

Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

> В отличие от готовых функций или библиотек паттерн нельзя просто взять и скопировать в программу. Паттерн представляет
> собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить
> под нужды вашей программы.

Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если
алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может
отличаться в двух разных программах.

> Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на
> котором
> нарисовано решение, но не конкретные шаги его реализации.

### Из чего состоит паттерн?

Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:

- проблема, которую решает паттерн;
- мотивация к решению проблемы способом, который предлагает паттерн;
- структура классов, составляющих решение;
- пример на одном из языков программирования;
- особенности реализации в различных контекстах;
- связи с другими паттернами.

Такой формализм в описании позволил создать обширный каталог паттернов, проверив каждый из них на состоятельность.

### Зачем знать паттерны?

> Вы можете вполне успешно работать, не зная ни одного паттерна. Более того, вы могли уже не раз реализовать какой-то из
> паттернов, даже не подозревая об этом.

Но осознанное владение инструментом как раз и отличает профессионала от любителя. Вы можете забить гвоздь молотком, а
можете и дрелью, если сильно постараетесь. Но профессионал знает, что главная фишка дрели совсем не в этом. Итак, зачем
же знать паттерны?

- `Проверенные решения`. Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда.
  До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.

- `Стандартизация кода`. Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так
  как все скрытые проблемы в них уже давно найдены.

- `Общий программистский словарь`. Вы произносите название паттерна вместо того, чтобы час объяснять другим
  программистам, какой крутой дизайн вы придумали и какие классы для этого нужны.

## Классификация паттернов

Паттерны отличаются по уровню сложности, детализации и охвату проектируемой системы. Проводя аналогию со строительством,
вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной
развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — идиомы. Они не универсальны, поскольку применимы только в рамках одного языка
программирования.

Самые универсальные — архитектурные паттерны, которые можно реализовать практически на любом языке. Они нужны для
проектирования всей программы, а не отдельных её элементов.

- `Порождающие` паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

- `Структурные` паттерны показывают различные способы построения связей между объектами.

- `Поведенческие` паттерны заботятся об эффективной коммуникации между объектами.

[Здесь](https://refactoring.guru/) — шикарный сайт с описанием некоторых паттернов и их реализации на разных языках
программирования.

## Рассмотрим некоторые паттерны

На сайте, указанном выше, вы можете найти примеры, описания, варианты реализации на различных языках программирования.
Лучше и детальнее я не напишу, так что рекомендую детально ознакомиться с сайтом. Но давайте всё-таки обсудим некоторые
паттерны на уровне идеи: зачем нужны и где вообще применимы.

### Одиночка (Singleton)

#### Описание:

Паттерн Одиночка гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому
экземпляру.

#### Применение:

- Управление подключением к базе данных, чтобы избежать множества подключений и, как следствие, экономить ресурсы.
- Логирование, чтобы обеспечить централизованное управление логами.
- Настройки приложения, чтобы убедиться, что все части программы используют одни и те же параметры конфигурации.

#### Пример реализации:

```python
class DatabaseConnection:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.connection = cls._connect()
        return cls._instance

    @staticmethod
    def _connect():
        print("Connecting to database...")
        return "connection_object"

# Использование
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(db1 is db2)  # True — один и тот же объект
```

> Замечание: в Python роль «одиночки» часто играет сам модуль (он импортируется один раз и кешируется). По возможности предпочитайте внедрение зависимостей (DI) вместо глобального состояния.

### Фабричный метод (Factory Method)

#### Описание:

Паттерн Фабричный метод предоставляет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять
тип создаваемых объектов.

#### Применение:

- В приложениях, где точные классы объектов могут меняться в зависимости от контекста или конфигурации.
- При необходимости создания множества различных объектов, которые имеют общий интерфейс.

Пример мини‑фабрики:

````python
class Parser: ...
class JsonParser(Parser): ...
class XmlParser(Parser): ...

def make_parser(fmt: str) -> Parser:
    return JsonParser() if fmt == "json" else XmlParser()
````

### Абстрактная фабрика (Abstract Factory)

#### Описание:

Абстрактная фабрика предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без
указания их конкретных классов.

#### Применение:

- В системах, где необходимо создавать группы связанных объектов (например, наборы GUI-элементов для различных
  платформ).
- В кроссплатформенных приложениях для создания объектов, зависящих от операционной системы.

### Строитель (Builder)

#### Описание:

Паттерн Строитель позволяет создавать сложные объекты поэтапно. Он отделяет конструирование объекта от его
представления.

#### Применение:

- В приложениях, где необходима пошаговая конфигурация сложных объектов (например, составление документов, создание
  отчётов).
- Для создания объектов с большим числом опциональных параметров.

### Прототип (Prototype)

#### Описание:

Паттерн Прототип позволяет копировать объекты, не прибегая к их непосредственному созданию через конструктор.

#### Применение:

- В системах, где создание объектов требует значительных затрат ресурсов (например, клонирование объектов в графических
  редакторах).
- В играх для клонирования игровых объектов с определёнными характеристиками.

### Адаптер (Adapter)

#### Описание:

Паттерн Адаптер позволяет объектам с несовместимыми интерфейсами работать вместе. Он преобразует интерфейс одного класса
в интерфейс, который ожидает клиент.

#### Применение:

- Для интеграции старого кода в новые системы без изменения самого старого кода.
- Для работы с классами, интерфейсы которых отличаются от необходимых.

Примечание: из‑за «утинотипизации» (duck typing) в Python адаптер часто не нужен — достаточно предоставить ожидаемые методы. Но при интеграции чужого API адаптер помогает согласовать интерфейсы.

### Мост (Bridge)

#### Описание:

Паттерн Мост разделяет абстракцию и реализацию, позволяя им изменяться независимо друг от друга.

#### Применение:

- В приложениях, где необходимо изменить реализацию абстракции во время выполнения.
- Для разработки кроссплатформенных GUI-приложений.

### Компоновщик (Composite)

#### Описание:

Паттерн Компоновщик позволяет объединять объекты в древовидные структуры для представления иерархий часть-целое. Клиенты
могут одинаково работать как с отдельными объектами, так и с их комбинациями.

#### Применение:

- В графических приложениях для построения сложных сцен из простых объектов.
- В системах управления файлами для работы с файловыми системами (директории и файлы).

### Декоратор (Decorator)

#### Описание:

Паттерн Декоратор позволяет динамически добавлять новую функциональность к объектам, не изменяя их классов.

#### Применение:

- В текстовых редакторах для добавления форматирования к тексту.
- В веб-приложениях для добавления новых возможностей к существующим объектам запроса и ответа.

### Стратегия (Strategy)

#### Описание:

Паттерн Стратегия определяет семейство алгоритмов, инкапсулирует их и делает их взаимозаменяемыми. Паттерн позволяет
изменять алгоритмы независимо от клиентов, которые их используют.

#### Применение:

- В системах, где необходимо изменять алгоритмы сортировки или поиска.
- В играх для реализации различных стратегий поведения персонажей.

#### Пример реализации:

```python
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: float) -> str: ...

class CreditCardPayment(PaymentStrategy):
    def pay(self, amount: float) -> str:
        return f"Paid {amount} via Credit Card"

class PayPalPayment(PaymentStrategy):
    def pay(self, amount: float) -> str:
        return f"Paid {amount} via PayPal"

class CryptoPayment(PaymentStrategy):
    def pay(self, amount: float) -> str:
        return f"Paid {amount} via Crypto"

class ShoppingCart:
    def __init__(self, payment_strategy: PaymentStrategy):
        self.payment = payment_strategy

    def checkout(self, amount: float) -> str:
        return self.payment.pay(amount)

# Использование — легко менять стратегию
cart = ShoppingCart(CreditCardPayment())
print(cart.checkout(100))  # Paid 100 via Credit Card

cart = ShoppingCart(PayPalPayment())
print(cart.checkout(50))   # Paid 50 via PayPal
```

Pythonic‑вариант стратегии — передать функцию/ключ сортировки:

````python
def by_len(x): return len(x)
def by_neg(x): return -x

sorted(data, key=by_len)  # замена стратегии выбором функции
````

## Антипаттерны

Антипаттерны — это распространённые ошибки проектирования, которых следует избегать.

### God Object (Божественный объект)

Класс, который знает слишком много или делает слишком много. Нарушает SRP.

```python
# ❌ Плохо
class Application:
    def handle_request(self): ...
    def connect_database(self): ...
    def send_email(self): ...
    def generate_report(self): ...
    def validate_user(self): ...
    def calculate_taxes(self): ...
    # ... ещё 50 методов
```

### Spaghetti Code

Код без чёткой структуры, где всё связано со всем. Трудно читать, тестировать и поддерживать.

### Magic Numbers / Strings

Использование «магических» значений без объяснения:

```python
# ❌ Плохо
if user.role == 1:  # Что такое 1?
    discount = price * 0.15  # Откуда 0.15?

# ✅ Хорошо
ADMIN_ROLE = 1
VIP_DISCOUNT = 0.15

if user.role == ADMIN_ROLE:
    discount = price * VIP_DISCOUNT
```

### Copy-Paste Programming

Дублирование кода вместо выделения в функцию. Нарушает DRY.

### Premature Optimization

Оптимизация кода до того, как она реально нужна. Усложняет код без измеримой пользы.

> «Преждевременная оптимизация — корень всех зол» — Дональд Кнут

## Практика

Спроектируйте мини‑сервис уведомлений, соблюдая принципы SOLID.

Требования:
- Определите интерфейс Notifier (через ABC или typing.Protocol).
- Реализуйте EmailNotifier и SMSNotifier (позже легко добавить PushNotifier).
- Используйте Strategy для форматирования сообщения (разные шаблоны).
- Внедрите зависимость Notifier в сервис (DIP) через конструктор.
- Покройте ключевую логику простыми тестами (unittest/pytest — на выбор).

Подсказки:
- Предпочитайте композицию и DI, избегайте singletons.
- Держите форматирование изолированным (стратегии как функции/объекты).

Мини‑скелет:

````python
from typing import Protocol

class Notifier(Protocol):
    def send(self, to: str, message: str) -> None: ...

class Service:
    def __init__(self, notifier: Notifier):
        self.notifier = notifier
    def notify_user(self, user_email: str, text: str) -> None:
        self.notifier.send(user_email, text)
````

Дополнительно:
- Практические задачки по блоку — [тут](tasks_block2.md).
- Перед следующим занятием выполните всё по [этой ссылке](before_postgres.md).

## Задание на второй модуль
[Ссылка](module2.md)

---

[← Лекция 13: Тестирование](lesson13.md) | [Лекция 15: СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи. →](lesson15.md)
