# Copyright (C) 2023, Python training course authors and contributors
# This file is distributed under the same license as the Python Training
# Course package.
# SERHII HORODILOV <sgorodil@gmail.com>
msgid ""
msgstr ""
"Project-Id-Version: Python Training Course 2022.11.dev\n"
"Report-Msgid-Bugs-To: https://github.com/edu-python-course/edu-python-course."
"github.io/issues\n"
"POT-Creation-Date: 2023-12-16 13:55+0000\n"
"PO-Revision-Date: 2023-12-21 04:00+0200\n"
"Last-Translator: Serhii Horodilov <sgorodil@gmail.com>\n"
"Language-Team: ua <LL@li.org>\n"
"Language: ua\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Generator: Poedit 3.4.1\n"

#: ../../src/rdbms/relations.txt:-1
msgid "This document describes the database relationships"
msgstr "Цей документ описує відносини в базах даних"

#: ../../src/rdbms/relations.txt:-1
msgid "Serhii Horodilov"
msgstr "Serhii Horodilov"

#: ../../src/rdbms/relations.txt:-1
msgid ""
"sql, db, database, relationship, primary key, foreign key, pk, fk, one-to-"
"one, one-to-many, many-to-many, 1-1, 1-n, n-m"
msgstr ""

#: ../../src/rdbms/relations.txt:9
msgid "Data Relationships"
msgstr "Зв'язки даних"

#: ../../src/rdbms/relations.txt:11
msgid ""
"Before dive into relationships, there is a need explain core concepts on how "
"data are referenced between different tables."
msgstr ""

#: ../../src/rdbms/relations.txt:15
msgid "Primary key"
msgstr ""

#: ../../src/rdbms/relations.txt:17
msgid ""
"A primary key constraint indicates that a column, or group of columns, can "
"be used as a unique identifier for rows in the table. This requires that "
"values be both unique and not null. So, the following two table definitions "
"accept the same data:"
msgstr ""

#: ../../src/rdbms/relations.txt:36
msgid ""
"Primary keys can span more than one column; the syntax is similar to unique "
"constraint:"
msgstr ""

#: ../../src/rdbms/relations.txt:49
msgid ""
"Adding a primary key will automatically create a unique B-tree index on the "
"column or group of columns listed in the primary key, and will force the "
"column(s) to be marked ``NOT NULL``."
msgstr ""

#: ../../src/rdbms/relations.txt:53
msgid "A table can have at most one primary key."
msgstr ""

#: ../../src/rdbms/relations.txt:57
msgid ""
"There can be any number of unique and not-null constraints, which are "
"functionally almost the same thing, but only one can be identified as the "
"primary key."
msgstr ""

#: ../../src/rdbms/relations.txt:62
msgid "Foreign key (FK)"
msgstr "Зовнішній ключ (FK)"

#: ../../src/rdbms/relations.txt:64
msgid ""
"A foreign key constraint specifies that the value in a column (or a group of "
"columns) must match the values appearing in some row of another table. We "
"say this maintains the *referential integrity* between two tables."
msgstr ""

#: ../../src/rdbms/relations.txt:68
msgid ""
"A table can have more than one foreign key constraint. Foreign key can also "
"overlaps with the primary key."
msgstr ""

#: ../../src/rdbms/relations.txt:71
msgid "To define a FK constraint:"
msgstr ""

#: ../../src/rdbms/relations.txt:94
msgid ""
"In this situation the ``book`` table is the *referencing* table, and the "
"``publisher`` table is the *referenced* table. Similarly there are "
"referencing and referenced columns."
msgstr ""

#: ../../src/rdbms/relations.txt:98
msgid ""
"In case the referenced column is not explicitly defined, the primary key of "
"the referenced table will be used as the referenced column."
msgstr ""

#: ../../src/rdbms/relations.txt:101
msgid ""
"It is not possible to create a row with non-null foreign key, that does not "
"appear in the referenced table."
msgstr ""

#: ../../src/rdbms/relations.txt:105
msgid "Self-referential foreign key"
msgstr ""

#: ../../src/rdbms/relations.txt:107
msgid ""
"Sometimes it is useful to the referenced table to be the same table as "
"referencing. This makes possible to create a tree-structures with nodes, "
"there a top-level node would have ``NULL`` ``parent_id``."
msgstr ""

#: ../../src/rdbms/relations.txt:120
msgid "Deleting referenced rows"
msgstr ""

#: ../../src/rdbms/relations.txt:122
msgid ""
"So far we know that the foreign keys disallows creation of rows that do not "
"relate to any row inside the referenced table. But what if a referenced row "
"needs to be removed? Intuitively, there are few options:"
msgstr ""

#: ../../src/rdbms/relations.txt:126
msgid "disallow deletion"
msgstr ""

#: ../../src/rdbms/relations.txt:127
msgid "delete referencing rows as well"
msgstr ""

#: ../../src/rdbms/relations.txt:128
msgid "something else..."
msgstr ""

#: ../../src/rdbms/relations.txt:130
msgid ""
"Restricting and cascading deletes are the two most common options. "
"``RESTRICT`` prevents deletion of a referenced row. ``CASCADE`` will also "
"delete all referencing rows as well as the referenced one."
msgstr ""

#: ../../src/rdbms/relations.txt:148
msgid "There are others options."
msgstr ""

#: ../../src/rdbms/relations.txt:150
msgid ""
"``NO ACTION`` means that if any referencing rows still exist when the "
"constraint is checked, an error is raised; this is the default behavior."
msgstr ""

#: ../../src/rdbms/relations.txt:153
msgid ""
"``SET NULL`` will replace all referencing rows foreign key values with "
"``NULL`` values."
msgstr ""

#: ../../src/rdbms/relations.txt:156
msgid ""
"``SET DEFAULT`` will replace all referencing rows foreign key values with "
"default values."
msgstr ""

#: ../../src/rdbms/relations.txt:160
msgid "Relationships"
msgstr ""

#: ../../src/rdbms/relations.txt:162
msgid ""
"From the point of view of the RDBMS there are no other relationships between "
"two tables except the **foreign key**. But the way the foreign keys are "
"designed brings us three concepts of the data relations."
msgstr ""

#: ../../src/rdbms/relations.txt:168
msgid "One-to-many"
msgstr ""

#: ../../src/rdbms/relations.txt:169
msgid ""
"In a relational database, two tables have a one-to-many relationship if each "
"row in one table references multiple rows of the other table. For example "
"``publisher`` can publish many books, but a single ``book`` is published by "
"some specific publisher."
msgstr ""

#: ../../src/rdbms/relations.txt:180
msgid "One-to-one"
msgstr ""

#: ../../src/rdbms/relations.txt:183
msgid ""
"You can think of one-to-one relationship as a limited version of *one-to-"
"many*."
msgstr ""

#: ../../src/rdbms/relations.txt:186
msgid ""
"In a relational database, two tables have a one-to-one relationship if each "
"row in one table links to exactly one row in the other table, and vice "
"versa. For example a table of ``members`` and a table of ``contacts`` might "
"have a one-to-one relationship."
msgstr ""

#: ../../src/rdbms/relations.txt:197
msgid "Many-to-many"
msgstr ""

#: ../../src/rdbms/relations.txt:198
msgid ""
"In relational database, two table have many-to-many relationship if each row "
"in one table can reference multiple rows in another table, and vice versa. "
"For example table ``book`` may contain records for books authored by many "
"``authors``. On the other hand author can write multiple books. Implementing "
"a many-to-many relationship requires creation of an intermediate table, that "
"applies one-to-many relationship with both original tables."
msgstr ""

#~ msgid "sql, db, database, relationship"
#~ msgstr "sql, db, database, relationship"

#~ msgid "It's time to talk about **data relations**."
#~ msgstr "Настав час поговорити про **відносини даних**."

#~ msgid ""
#~ "For example your database contains two tables: ``weather`` and ``city``. "
#~ "The diagram below demonstrates the overall data structure:"
#~ msgstr ""
#~ "Наприклад, ваша база даних містить дві таблиці: ``weather`` і ``city``. "
#~ "Діаграма нижче демонструє загальну структуру даних:"

#~ msgid ""
#~ "Consider the following problem: you want to make sure no one can insert a "
#~ "record into ``weather`` without a matching entry in ``city`` table. This "
#~ "is called maintaining the *referential integrity* of your data. In "
#~ "simplistic database systems this would be implemented (if at all) by "
#~ "first looking at the cities table to check if a matching record exists, "
#~ "and then inserting or rejecting the new weather records. This approach "
#~ "has a number of problems and is very inconvenient."
#~ msgstr ""
#~ "Розглянемо таку проблему: ви хочете переконатися, що ніхто не може "
#~ "вставити запис до ``weather`` без відповідного запису в ``city`` таблиці. "
#~ "Ценазивається підтримкою посилальної цілісності ваші дані. У спрощених "
#~ "системах баз даних це було б реалізовано (якщо взагалі) спочатку "
#~ "переглядаючи таблицю міст, щоб перевірити, чи існує відповідний запис, а "
#~ "потім вставляв або відхиляв нові записи погоди. Цей підхід має низку "
#~ "проблем і дуже незручно."

#~ msgid ""
#~ "This declaration creates a relationship between two (or even more) tables."
#~ msgstr ""
#~ "Це оголошення створює зв'язок між двома (або навіть більше) таблицями."

#~ msgid ""
#~ "So far, you have knowledge about **primary** keys. The **foreign** key is "
#~ "a column, that *references* some another table. In common, it's a "
#~ "reference to another table's PK; but there is no limitation of this kind, "
#~ "any column can be referenced by another one. FKs handle data integrity "
#~ "only, it's not required for FK to be non-NULL value."
#~ msgstr ""
#~ "Поки що ви знаєте про первинні ключі. Зовнішній ключ - це стовпець, який "
#~ "посилається на іншу таблицю. Загалом, це посилання на PK іншої таблиці; "
#~ "але такого роду обмежень немає , на будь-який стовпець може посилатися "
#~ "інший. FK обробляє лише цілісність даних, не обов'язково, щоб значення FK "
#~ "було відмінним від NULL."

#~ msgid ""
#~ "The relation's properties are described by CONSTRAINTS and the database's "
#~ "structure."
#~ msgstr ""
#~ "Властивості відношення описуються ОБМЕЖЕННЯМИ та структурою бази даних."

#~ msgid ""
#~ "For example, modifying declaration with ``NOT NULL`` constraint grants "
#~ "that each record within a table has a matching one entity in another "
#~ "table."
#~ msgstr ""
#~ "Наприклад, зміна декларації з обмеженням ``NOT NULL`` гарантує, що кожний "
#~ "запис у таблиці має відповідну сутність в іншій таблиці."

#~ msgid "This brings us to various relationship models."
#~ msgstr "Це підводить нас до різних моделей відносин."

#~ msgid "One-to-many relationship (1-to-N)"
#~ msgstr "Зв'язок один-до-багатьох (1-до-N)"

#~ msgid "This is the most common relationship."
#~ msgstr "Це найпоширеніший зв'язок."

#~ msgid ""
#~ "For the example above there are no limitations on temperature "
#~ "measurements in a specified city. So, a single city may has 0 or N "
#~ "related records in ``weather`` table. But each weather record is related "
#~ "to the only one city."
#~ msgstr ""
#~ "Для наведеного вище прикладу немає обмежень на вимірювання температури у "
#~ "визначеному місті. Отже, окреме місто може мати 0 або N пов'язаних "
#~ "записів у таблиці ``погода``. Але кожен запис погоди пов'язаний до "
#~ "єдиного міста."

#~ msgid ""
#~ "Another example is employees and office buildings they work in. Some big "
#~ "company may have multiple offices and employee across the globe. Multiple "
#~ "employees can be present in a single office building at a time. But each "
#~ "employee can be physically located only in a single office at a time."
#~ msgstr ""
#~ "Іншим прикладом є співробітники та офісні будівлі, в яких вони працюють. "
#~ "Деякі великі компанії можуть мати кілька офісів і співробітників по "
#~ "всьому світу. Декілька працівників можуть бути присутні в одній офісній "
#~ "будівлі одночасно. Але кожен працівник може фізично перебувати лише в "
#~ "одному офісі одночасно."

#~ msgid "One-to-one relationship (1-to-1)"
#~ msgstr "One-to-one relationship (1-to-1)"

#~ msgid ""
#~ "``UNIQUE`` and ``NOT NULL`` constraints are used together to ensure there "
#~ "is and only one matching record. Back to the example with employees. "
#~ "Multiple workstations (personal computers) are located in each office "
#~ "building. The only one person can occupy the only one work station at a "
#~ "time."
#~ msgstr ""
#~ "Обмеження ``UNIQUE`` і ``NOT NULL`` використовуються разом, щоб "
#~ "забезпечити наявність лише одного відповідного запису. Повернемося до "
#~ "прикладу зі співробітниками. Кілька робочих станцій (персональних "
#~ "комп'ютерів) розташовані в у кожній офісній будівлі. Лише одна особа може "
#~ "займати лише одну робочу станцію одночасно."

#~ msgid "Many-to-many relationship (N-to-N)"
#~ msgstr "Зв'язок багато-до-багатьох (N-до-N)"

#~ msgid ""
#~ "These relationships require additional table. A good example may be a "
#~ "*project role*. There are many of them in a production team. And some "
#~ "employees may be assigned to the same role (e.g. developers, testers "
#~ "etc.). But also a single person can be a developer and tester at a time."
#~ msgstr ""
#~ "Ці зв'язки потребують додаткової таблиці. Хорошим прикладом може бути "
#~ "роль у проекті. Їх багато у виробничій команді. І деяким працівникам може "
#~ "бути призначено ту саму роль (наприклад, розробники, тестувальники і т. "
#~ "д.). Але також одна людина може бути розробником і тестувальником "
#~ "одночасно."

#~ msgid "Joining data"
#~ msgstr "Об'єднання даних"

#~ msgid ""
#~ "``JOIN`` is used to *join* data fetched from multiple related tables. To "
#~ "build a valid query you are to set the tables to join and parameter to "
#~ "use for this operation."
#~ msgstr ""
#~ "``JOIN`` використовується для об'єднання даних, отриманих з кількох "
#~ "пов'язаних таблиць. Щоб побудувати дійсний запит, вам потрібно встановити "
#~ "таблиці для об'єднання та параметр, який використовується для цієї "
#~ "операції."

#~ msgid "Common syntax is:"
#~ msgstr "Загальний синтаксис:"

#~ msgid ""
#~ "There are various join types available. Here are is some dummy data to "
#~ "demonstrate their purpose."
#~ msgstr ""
#~ "Існують різні типи об'єднань. Ось деякі фіктивні дані, щоб "
#~ "продемонструвати їх призначення."

#~ msgid "poem"
#~ msgstr "poem"

#~ msgid "id"
#~ msgstr "id"

#~ msgid "title"
#~ msgstr "title"

#~ msgid "author_id"
#~ msgstr "author_id"

#~ msgid "1"
#~ msgstr "1"

#~ msgid "On the Field of Battle"
#~ msgstr "On the Field of Battle"

#~ msgid "2"
#~ msgstr "2"

#~ msgid "Moses"
#~ msgstr "Moses"

#~ msgid "3"
#~ msgstr "3"

#~ msgid "The Forest Song"
#~ msgstr "The Forest Song"

#~ msgid "4"
#~ msgstr "4"

#~ msgid "In the Catacombs"
#~ msgstr "In the Catacombs"

#~ msgid "null"
#~ msgstr "null"

#~ msgid "5"
#~ msgstr "5"

#~ msgid "The Singing Stones"
#~ msgstr "The Singing Stones"

#~ msgid "6"
#~ msgstr "6"

#~ msgid "Ancient Fairy Tales"
#~ msgstr "Ancient Fairy Tales"

#~ msgid "7"
#~ msgstr "7"

#~ msgid "My Thoughts"
#~ msgstr "My Thoughts"

#~ msgid "8"
#~ msgstr "8"

#~ msgid "To Shevchenko"
#~ msgstr "To Shevchenko"

#~ msgid "author"
#~ msgstr "author"

#~ msgid "name"
#~ msgstr "name"

#~ msgid "Larysa Kosach"
#~ msgstr "Larysa Kosach"

#~ msgid "Ivan Franko"
#~ msgstr "Ivan Franko"

#~ msgid "John Doe"
#~ msgstr "John Doe"

#~ msgid "Join types"
#~ msgstr "Join types"

#~ msgid "Cross join"
#~ msgstr "Cross join"

#~ msgid ""
#~ "For every possible combination of rows from T1 and T2 (i.e., a Cartesian "
#~ "product), the joined table will contain a row consisting of all columns "
#~ "in T1 followed by all columns in T2. If the tables have N and M rows "
#~ "respectively, the joined table will have N * M rows."
#~ msgstr ""
#~ "Для будь-якої можливої комбінації рядків з T1 і T2 (тобто декартового "
#~ "добутку) об’єднана таблиця міститиме рядок, що складається з усіх "
#~ "стовпців у T1, за якими йдуть усі стовпці в T2. Якщо таблиці мають N і M "
#~ "рядків відповідно, об’єднана таблиця матиме N * M рядків."

#~ msgid "Qualified joins"
#~ msgstr "Qualified joins"

#~ msgid ""
#~ "The words ``INNER`` and ``OUTER`` are optional for all forms. ``INNER`` "
#~ "is the default; ``LEFT``, ``RIGHT`` and ``FULL`` imply ``OUTER`` join."
#~ msgstr ""
#~ "Слова ``INNER`` і ``OUTER`` є необов'язковими для всіх форм. ``INNER`` є "
#~ "типовим; ``LEFT``, ``RIGHT`` і ``FULL` ` означає ``OUTER`` приєднання."

#~ msgid "INNER JOIN"
#~ msgstr "INNER JOIN"

#~ msgid ""
#~ "For each row R1 of T1, the joined table has a row for each row in T2 that "
#~ "satisfies the join condition with R1."
#~ msgstr ""
#~ "Для кожного рядка R1 T1 об'єднана таблиця має рядок для кожного рядка T2, "
#~ "який задовольняє умову об'єднання з R1."

#~ msgid "Inner join"
#~ msgstr "Inner join"

#~ msgid "LEFT OUTER JOIN"
#~ msgstr "LEFT OUTER JOIN"

#~ msgid ""
#~ "First, an inner join is performed. Then, for each row in T1 that does not "
#~ "satisfy the join condition with any row in T2, a joined row is added with "
#~ "null values in columns of T2. Thus, the joined table always has at least "
#~ "one row for each row in T1."
#~ msgstr ""
#~ "Спочатку виконується внутрішнє об'єднання. Потім для кожного рядка в T1, "
#~ "який не задовольняє умови з'єднання з будь-яким рядком у T2, додається "
#~ "об'єднаний рядок із нульовими значеннями в стовпцях T2. Таким чином, "
#~ "об'єднана таблиця завжди має щонайменше один рядок для кожного рядка в T1."

#~ msgid "Left join"
#~ msgstr "Left join"

#~ msgid "RIGHT OUTER JOIN"
#~ msgstr "RIGHT OUTER JOIN"

#~ msgid ""
#~ "First, an inner join is performed. Then, for each row in T2 that does not "
#~ "satisfy the join condition with any row in T1, a joined row is added with "
#~ "null values in columns of T1. This is the converse of a left join: the "
#~ "result table will always have a row for each row in T2."
#~ msgstr ""
#~ "Спочатку виконується внутрішнє об'єднання. Потім для кожного рядка в T2, "
#~ "який не задовольняє умови об'єднання з будь-яким рядком у T1, об'єднаний "
#~ "рядок додається з нульовими значеннями в стовпцях T1. Це є протилежністю "
#~ "лівого об'єднання: таблиця результатів завжди матиме рядок для кожного "
#~ "рядка в T2."

#~ msgid "Right join"
#~ msgstr "Right join"

#~ msgid "FULL OUTER JOIN"
#~ msgstr "FULL OUTER JOIN"

#~ msgid ""
#~ "First, an inner join is performed. Then, for each row in T1 that does not "
#~ "satisfy the join condition with any row in T2, a joined row is added with "
#~ "null values in columns of T2. Also, for each row of T2 that does not "
#~ "satisfy the join condition with any row in T1, a joined row with null "
#~ "values in the columns of T1 is added."
#~ msgstr ""
#~ "Спочатку виконується внутрішнє об'єднання. Потім для кожного рядка в T1, "
#~ "який не задовольняє умови об'єднання з будь-яким рядком у T2, додається "
#~ "об'єднаний рядок із нульовими значеннями в стовпцях T2. Також , для "
#~ "кожного рядка T2, який не задовольняє умову з'єднання з будь-яким рядком "
#~ "T1, додається об'єднаний рядок із нульовими значеннями в стовпцях T1."

#~ msgid "Full join"
#~ msgstr "Full join"
