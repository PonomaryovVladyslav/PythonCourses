# Урок 28. Знакомство с Django

![](https://the-flow.ru/uploads/images/resize/830x0/adaptiveResize/06/04/56/59/17/253344b40cd7.jpg)

## Как работает интернет и что именно мы будем изучать?

Мы, в рамках этого курса изучим то как можно создавать сайты и приложения. Я надеюсь ни для кого не окажется секретом,
что любой сайт или приложение работают в сети интернет. Но как именно?

На самом деле, большая часть работы это результат выполнения различных запросов, и в первую очередь запросов по
протоколу `http` (Ну скорее `https`, о чём поговорим сильно позже).

Когда вы набираете в браузере url, или просто переходите по закладкам или ссылкам, на самом деле вы заставляете браузер
создавать и отправлять `GET http` запрос. А когда вводите юзернейм и пароль, чаще всего после кнопки, например "Войти",
вы формируете и отправляете `POST http` запрос

## Request-response, Он же клиент-сервер

При работе с веб-ресурсами, в самом распространённом случае мы будем иметь дело с так называемым
взаимодействием `запрос-ответ`, что на английском `request-response`.

А это значит, что у нас есть кто-то кто "спрашивает", и тот кто "отвечает".

### Кто может спрашивать?

На самом деле спрашивать может любое устройство или приложение которое способно
сформировать `http` запрос, а в современном мире это уже почти любое устройство включая, чайники, часы и стиральные
машины.

Но в самом распространённом варианте, это всё-таки будут:

- Веб-браузеры (Chrome, mozilla, opera, их же мобильные аналоги, итд.)
- Приложения (Instagram, telegram итд. приложения бывают не только мобильные, но и для компьютера или планшета, и мы
  даже будем таким в рамках курса пользоваться)

![](https://www.iguides.ru/upload/medialibrary/a60/a60857ccc094b4bfd975d0fa842bcb1c.png)

### Кто может отвечать?

Отвечать может только сервер. В отличие от задающего вопрос, отвечать может только специально подготовленный. Сервером
может являться по сути любое электронное устройство, на котором возможно запустить необходимый набор программ или
команд. В рамках обучения, вы будете запускать сервер, прямо на ваших компьютерах, при разработке так обычно и делается,
но реальные сайты и приложения обычно располагаются на специально подготовленных, изолированных, или облачных
компьютерах, и в случае в веб-приложения на python, это практически всегда будет компьютер с операционной системой
Linux, зачем и как это настроить мы поговорим ближе к концу нашего курса.

#### А бывает ли не клиент-сервер?

Бывает, но используется крайне редко, и для очень специфических случаев. Так что для нас не несёт полезной информации.

### Краткое описание http запросов

Из чего состоит http запрос можно почитать [тут](https://developer.mozilla.org/ru/docs/Web/HTTP/Messages), но если
вкратце, то из тела, где хранятся данные, и хедеров, где хранится служебная информация.

#### Метод GET

Используется для запроса содержимого указанного ресурса. Например, получить данные, файл или любую другую информацию,
браузер (Chrome, Mozzila, etc.) при наборе url (https://ru.wikipedia.org/,
https://www.youtube.com/watch?v=WdZJ-QUItHw&t=7974s) использует именно GET запрос, может передавать переменные в query
параметре (в примере с ютубом ?v=WdZJ-QUItHw&t=7974s это query параметры, начинается с символа ?, следующий параметр
добавляется при помощи символа & в данном примере, параметр {'v': 'WdZJ-QUItHw', 't': '7974s'})

Обычно не используется для отправки данных (query параметры чаще используются для уточнения того, что вы хотите
получить, например значение фильтров, или каких-то системных параметров)

Например, получение комментариев к посту в блоге, или списка рекомендаций на ютубе, открытие любого сайта это уже `GET`
запрос.

#### Метод POST

Применяется для передачи пользовательских данных заданному ресурсу. Если мы хотим, ввести юзернейм и пароль, обычно мы
используем `POST`, потому что это передача пользовательских данных. Хотим оставить комментарий, `POST`, заказать товар
из интернет-магазина, `POST`, итд. Практически всегда когда мы отправляем пользовательские данные, это будет `POST`.

#### Методы PUT и PATCH

Применяется для обновления данных. Например, изменить текст сообщения, или пароль пользователя. Подробно будем
разбираться как и с методом `DELETE` в следующем блоке этого курса.

#### Метод DELETE

Используется для удаления объектов. Подробно рассмотрим в следующем блоке.

#### Методы TRACE, HEAD, OPTIONS итд.

Существуют и другие запросы, которые используют реже и с другими назначениями, подробно изучать не будем, хотя наверняка
расскажу несколько практических примеров использования в дальнейшем

## Шаблон проектирования MVC

Для разработки любых сложных решений используются шаблоны проектирования (`patterns`).

Если вы собираетесь строить дом, я сомневаюсь, что нужно придумывать собственный способ его постройки. Залить
фундамент, на него поставить каркас и в каркасе провести коммуникации и сделать отделку. Придумывание своих путей
постройки дома, скорее всего приведёт к плохому результату, либо не возможности достичь результата вообще.

Так вот, в программировании тоже все стандартные решения придумали за нас. Называются они паттерны, и вы уже слышали
этот
термин, когда обсуждали такие вещи как ООА\ООД\ООП.

Для нас, в данный момент, с точки зрения создания веб ресурсов самым важных из них является `MVC` **(Model - View -
Controller) (Модель - Отображение - Контроллер)**

### Что же это такое?

Это разделение обязанностей между тремя зависимыми блоками.

Давайте посмотрим на работу обычного ресторана.

Клиент приходит, садится за столик и видит только меню и официанта. Выбрав, что-то из меню, через официанта он
отправляет запрос на кухню, на приготовление его блюда. Официант в свою очередь идёт к поварам, что бы сообщить о
заказе, а повар получив заказ, должен сначала понять есть ли у него необходимые продукты, и работает ли плита или
духовка. В случае если всё хорошо, то готовит блюдо, и после отдаёт его официанту, который и выносит блюдо.

Получается, что клиент, видел только меню и конечное блюдо, но не видел повара, или тем более склад с продуктами, но
ожидаемые результат всё-таки получил.

Большая часть сайтов или приложений так же делится на три компонента, `Model` - `View` - `Controller`

Если рассматривать пример с рестораном, то зал в котором находится клиент, его столик и его тарелка будут
являться `Отображением`, оно же `View`, В случае с сайтом или приложением, этим элементом является всё что может увидеть
пользователь.

Официант, который принимает заказ и выносит блюдо, является в этой аналогии, `http` запросами и ответами. И общается
только с `Контроллером`, он же `Controller`

Кухня и повара на ней, будут являться `Контролером`, так как они могут принимать запросы от официантов, но при этом
могут сходить и на склад, посмотреть, например, на наличие продуктов, а склад в нашем случае будет являться
моделью, `Model`. При написании веб-приложения, контролером будет являться та часть кода, которая отвечает за обработку
запросов. И так же выполнять действия и с отображением, и с моделью.

Склад в этой конструкции, будет являться моделью, `Model`, официант или клиент, не могут пойти на склад и взять себе
продуктов, это может сделать только повар, так же только повар может принять продукты у поставщика и добавить их на
склад. В случае с веб-приложениями, моделью является `база данных`, и код который отвечает за взаимодействия с ней.

При этом клиент не может заказать, всё что ему захочется, ему нужно будет выбрать из `меню`

Сегодня мы изучим как именно формируется "меню" для django, и что это вообще.

![](https://miro.medium.com/max/1304/1*la8KCs0AKSzVGShoLQo2oQ.png)

По этому же принципу работает и Django, но с немного другими названиями, паттерн называется `MVT` (`Model` - `View`

- `Template`),
  где `View` играет роль `Controller`, а `Template` роль `View`, но это точно такая-же идея, изменились только названия
  блоков.

## Что же такое все таки Django?

**Django** - веб-фреймворк, а фреймворк это по своей сути конструктор, который помогает нам собирать блоки, часто даже
не задумываясь как именно это работает под капотом.

![](https://www.meme-arsenal.com/memes/07d78e429e60f57b09f8afb5e4446bd1.jpg)

Основной информационный ресурс [Django](https://www.djangoproject.com/)

## Наконец-то практика

### Виртуальное окружение

Когда мы разрабатываем какой-либо проект, обычно мы не хотим, что-бы пакеты которые были установлены для него, как
либо пересекались с теми, которые установлены, для другого проекта. А у разработчика вполне может быть большое
количество проектов на рабочем компьютере.

Для того, что бы разные проекты не пересекались, можно использовать разные компьютеры, для разных проектов, но не надо
так делать :)

Существует возможность создать `виртуальное окружение` для каждого отдельного проекта. По сути, создаётся папка, в
которую копируется сам интерпретатор питона, вспомогательные системные файлы, и создаётся папка, куда будут
устанавливаться все необходимые для конкретного проекта пакеты.

#### Консоль

Когда мы занимаемся программированием, нам очень часто необходимо использовать консоль, будь то Windows или Linux

В Windows, что бы открыть терминал, необходимо нажать Win+R, и во всплывшем окне набрать `cmd`

В Linux/Mac многое зависит от дистрибутива, но часто можно найти по поиску, по слову Terminal, или по клавишам Alt+T (
Далеко не везде будет работать)

#### cd

Команда `cd` (Change Directory) позволяет изменить текущую папку. Мы можем указать ей как абсолютный `cd /home/my_user`,
так и относительный `cd my_images`(находясь, допустим, в папке `/home/my_user`) пути.

Перейти на директорию уровнем выше `cd ..` (были в `/home/my_user/my_images/` попали в `/home/my_user/`)

Перейти на директорию двумя уровнями выше `cd ../..` (были в `/home/my_user/my_images/` попали в `/home`)

#### Создание виртуального окружения

Для, того, что бы создать виртуальное окружение, вам необходим компьютер с установленным python и открытая консоль

В консоли необходимо указать

```python -m venv /path/to/new/virtual/environment```

где `/path/to/new/virtual/environment` путь к вашему виртуальному окружению (Я лично создал себе папку которую назвал
enviroments, и внутри неё уже создаю новые виртуальные окружения)

#### Активация и деактивация виртуального окружения

После создания, что бы использовать виртуальное окружение его необходимо активировать, так же через консоль.

Для активации, необходимо запустить активационный скрипт.

Windows

Для windows внутри папки с виртуальным окружением нам необходим файл `activate` в папке `Scripts`

Допустим вы находились в папке `C:\Users\black>`, и прописали команду `python -m venv test_env`, это создаст
папку `C:\Users\black\test_env`, значит что бы запустить виртуальное окружение, нужно выполнить
команду `test_env\Scripts\activate`

Linux/Mac

В этих операционных системах необходимо использовать команду `source` применяя её к файлу `activate` в папке `bin`.

Допустим вы находились в папке `/home/black/`, и прописали команду `python -m venv test_env`, это создаст
папку `/home/black/test_env`, значит что бы запустить виртуальное окружение, нужно выполнить
команду `source test_env/bin/activate`

После чего в консоли перед курсором появится указание виртуального окружения `(test_env)`, в наших примерах.

Что бы деактивировать, для любых систем необходимо использовать команду `deactivate`

### Создадим новый проект

Для создания проекта, создаём виртуальное окружение, и активируем его (описание выше).

После чего необходимо выполнить два действия:

- Установить джанго
- Перейти в папку где мы собираемся создать проект, в котором будем писать код.

~Порядок этих двух действий не имеет значения, ведь установка пакета через `pip` установит пакет в папку виртуального
окружения, где находитесь вы, совершенно не имеет значения.

Что бы установить последнюю версию django необходимо выполнить команду:

```pip install django```

Если необходимо установить конкретную версию, нужно добавить `==x.y`, например

```pip install django==2.2```

После установки django и перехода в папку, в которой вы собираетесь работать, необходимо создать проект, сделать это
можно через такую команду:

```django-admin startproject mysite```

`mysite` - это название вашего проекта, может быть таким, как вам необходимо.

Эта команда создаёт новый проект, и заполняет его базово нужными файлами, давайте рассмотрим их.

Структура файлов:

```
mysite /
    manage.py
    mysite /
        __init__.py
        settings.py
        urls.py
        wsgi.py
        asgi.py
```

**manage.py** - файл точка входа, при помощи которого мы будем взаимодействовать со многими частями Django из консоли

Внутри папки `mysite`:

**\_\_init__.py** - Пустой файл, который говорит Python-у, что этот каталог должен рассматриваться как пакет Python-а

**settings.py** - Настройки и конфигурации проекта.

**urls.py** - URL-ы для этого проекта; «меню» вашего сайта на платформе Django.

**wsgi.py** - Файл отвечающий за входную точку сервера (Позволяет запускать код как сайт), разберём почти в самом конце
курса

**asgi.py** - Файл отвечающий за входную точку сервера асинхронно (Позволяет запускать код как сайт), разберём почти в
самом конце курса

Проверим работоспособность.

В консоли запустим локальный "сервер" из папки с нашим "сайтом" (в моём примере `mysite`)

**Необходимо находится в консоли в той же папке где находится `manage.py` с включённым виртуальным окружением.

```python manage.py runserver```

В консоли должна появиться примерно такая надпись.

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/runserver.png)

Не закрывая консоль (сервер должен работать), открываем в браузере http://127.0.0.1:8000/

В этом случае скрипт запускает сервер, он должен работать, что бы запросы вообще могли выполняться.

А браузер будет клиентом (Помним о взаимодействии `клиент-сервер`? )

При таком подходе наш компьютер сразу является и клиентом (браузер) и сервером (скрипт запущенный в консоли)

`127.0.0.1` это локальный хост (обращаться к вашему же собственному компьютеру) а `:8000` это номер порта на котором
запущен процесс (Если не указывать порт, то по умолчанию будет использоваться 80 порт, для `http` и 443 для `https`,
когда вы открываете любой сайт, на самом деле вы скрытым образом указываете порт. Для разработки, часто используют те
порты, на которых точно не будет ничего полезного (других программ работающих на вашем компьютере), для django по
умолчанию используется 8000, если нужно его можно изменить, но обычно в этом нет необходимости. `127.0.0.1` можно
заменить на `0.0.0.0` или слово `localhost`, все три варианта практически взаимозаменяемы.

Если вы всё сделали правильно, то в браузере должны увидеть, что-то такое:

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/worked.png)

## Создаём приложение

Настройки и конфигурации это замечательно, но разработка подразумевает использование отдельных
модулей как части сайта (бывает один на весь сайт, а бывают и тысячи), такие модули называются приложениями, и именно в
них пишется "суть" сайта.

Через консоль, и уже известную нам `manage.py` создадим приложение

```python manage.py startapp myapp```

Команда создаст вам папку с вашим приложением, давайте разберем её подробнее

```
myapp/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

**\_\_init__.py** - Пустой файл, который говорит Python-у, что этот каталог должен рассматриваться как пакет Python-а

**admin.py** - заготовка под страницу для администратора, удобный встроенные инструмент, разберём на следующих занятиях

**apps.py** - информация о приложении, просто смиритесь, что этот файл есть.

**папка migrations** - Тут будут миграции базы данных.

**models.py** - Модели.

**tests.py** - Тесты.

**views.py** - Контроллер приложения.

## Наш первый URL

Теперь у нас всё готово для того, что бы начать создавать наш сайт. Сегодня мы будем разбираться, как работают urls.

При любом запросе к запущенному Django приложению запущенный сервер при обработке в первую очередь заходит в
файл `settings.py` и ищет там переменную `URL_CONF`, по умолчанию там будет указан файл `urls.py` который находится в
той же папке где и `settings.py`.

Внутри этого файла Django ожидает наличие переменной `urlpatterns`, которая содержит коллекцию (например список)
состоящую из специальных объектов `path` или `re_path`.

На самом деле эти объекты появились в Django только после версии, 2.0, сейчас актуальная версия это 4.0, но потенциально
вы можете встретить и версии ниже, например 1.11, поэтому ниже разберем и более старые варианты урлов. До 2.0 там были
коллекции из объектов `url`, и все они работали на регулярных выражениях, о них позже.

Всё основная логика обработки запросов пишется в приложениях, в файлах `views.py`, у нас всего одно приложение поэтому
всю логику (сегодня она будет простейшая) мы будем писать в файл `myapp/views.py`.

Для начала изменим файл `views.py`

```python
# mysite/myapp/views.py
from django.http import HttpResponse


# Поздравляю, это ваш первый контроллер, который может, принять запрос, и отдать ответ с текстом, больше ничего
def main(request):
    return HttpResponse("Hey! It's your main view!!")
```

Мы создали функцию, которая принимает один параметр `request` и возвращает объект `HttpResponse`.

Это нужно потому что вся веб-инфраструктура работает на `request-response` системе, мы тоже не будем её нарушать, и
будем принимать запросы, и возвращать ответы.

Объект `HttpResponse` мы импортировали из Django, и на данном этапе нас совершенно не интересует как он работает, как и
то что именно находится в переменной `request`.

По сути эта функция является контролером, но не спешите, контролеры мы будем изучать детально далее.

Для использования этого контролера в качестве логики, он должен быть описан в файле `urls.py`:

```python
# mysite/mysite/urls.py
from django.urls import path
from myapp.views import main

urlpatterns = [
    path('', main)
]
```

Мы импортировали `path` из django и метод `main` из нашего `views.py`

Объект `path`, принимает два обязательных параметра:

- Строка, которая содержит `путь`
- Обработчик, что именно должно происходить при запросе по такому пути.

### Строка пути

Строка, которая указывает как именно можно выполнить запрос к данному `url`.

Например, если указать там пустую строку, и запустим сервер на локалхосте на 8000 порту, то запросы нужно выполнять по
адресу `127.0.0.1:8000/`

Если указать там, например `super_cool_path`, то обращаться нужно было бы к `127.0.0.1:8000/super_cool_path/`

Не может содержать пробелов, может содержать `/`

### Обработчик

Что угодно что можно вызвать `()`, на данном этапе это функции, дальше мы будем использовать классы. При вызове,
добавляет в качестве аргумента переменную `request`.

Объект `path` так же может принимать атрибут `name=`, который нужен дня автоматической генерации адресов, будем изучать на следующем
занятии, и некоторые другие не обязательные атрибуты.

Если мы перезапустим (ну или запустим) сервер и откроем страницу, то мы увидим, что-то такое:

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/main_home.png)

Список урлов проекта называется роутинг. Роутинг можно строить так как вам удобно, или как того требует задание.

Напишем еще один контролер, для "другой" страницы. В файле `myapp/views.py`

```python
from django.http import HttpResponse


def main(request):
    return HttpResponse("Hey! It's your main view!!")


def another(request):
    return HttpResponse("It's another page!!")

```

А в файле `mysite/urls.py` импортируем эту функции и добавим маршрут в список, что бы получилось так:

```python
from django.urls import path
from myapp.views import main, another

urlpatterns = [
    path('', main),
    path('some_url/', another)
]
```

То что написано в строке до контролера это путь к урлу, а значит, что бы увидеть обработку этого контролера нужно
открыть страницу http:/127.0.0.1:8000/some_url/

Открываем [эту](http:/127.0.0.1:8000/some_url/) страницу и видим результат:

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/another_page.png)

## Урлы с параметрами

Урл может заведомо принимать параметры, самый простой способ, это описание параметра через синтаксис `<type:variable>`

Обновим наш `urls.py`:

```python
from django.urls import path
from myapp.views import main, another, main_article, uniq_article, article

urlpatterns = [
    path('', main),
    path('some_url/', another),
    path('article/', main_article, name='mail_article'),
    path('article/33/', uniq_article, name='uniq_article'),
    path('article/<int:article_id>/', article, name='article'),
]
```

Обратите внимание, часть урлов теперь имеет параметр `name`, он понадобится на следующем занятии

А в последнем url мы указали параметр <int:article_id>, значение до двоеточия, это тип данных который принимает
параметр, а после это имя параметра который можно будет использовать в контролере, что бы получить значение этого
параметра.

Всего существует 5 таких типов:

- str - Ищет не пустую строку, без символа `/`

- int - Ноль или любое положительное число.

- slug - по сути это тоже строка, которая состоит из букв, цифр, нижних подчеркиваний, дефисов, символов плюс,
  например `building-your-1st-django-site` отличается от обычной строки тем, что обычно этот урл берет данные из уже
  существующих данных, название статьи, уникальный номер товара итд.

- uuid - Ищет соответствие UUID, это специальный формат состоящий из шестнадцатиричных цифр и букв и дефисов, дефисы
  должны быть обязательно, буквы маленькие. Например, 075194d3-6885-417e-a8a8-6c931e272f00.

- path - Строка с символом/лами `/`

```Обратите внимание что url `article/33/` попадает так же и под `article/<int:article_id>/` потому что 33 это тоже цифра, в этом случае будет использован тот который находится в списке первым. Урлы считываются сверху вниз ```

Изменим `myapp/views.py`:

```python
from django.http import HttpResponse


def main(request):
    return HttpResponse("Hey! It's your main view!!")


def another(request):
    return HttpResponse("It's another page!!")


def main_article(request):
    return HttpResponse('There will be a list with articles')


def uniq_article(request):
    return HttpResponse('This is uniq answer for uniq value')


def article(request, article_id):
    return HttpResponse(f"This is an article #{article_id}.")
```

Обратите внимание в функцию `article` я добавил параметр `article_id` для получения значения в контролере.

Давайте посмотрим на результат при заходе на разные страницы.

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/static_url.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson33/static_const_url.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/page_article_with_num.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/page_article_with_str.png)

Последнее это пример работы если урл не был описан (Всем известная страница 404, в дебаг режиме, она может рассказать
много подробностей об ошибке) В данном примере, ошибка говорит, о том, что контролера для указанного запроса не
существует.

Так как параметры в функции могут быть не обязательными, мы можем воспользоваться и этим свойством тоже.

`views.py`

```python
from django.http import HttpResponse


def main(request):
    return HttpResponse("Hey! It's your main view!!")


def another(request):
    return HttpResponse("It's another page!!")


def main_article(request):
    return HttpResponse('There will be a list with articles')


def uniq_article(request):
    return HttpResponse('This is uniq answer for uniq value')


def article(request, article_id, name=''):
    return HttpResponse(
        "This is an article #{}. {}".format(article_id, "Name of this article is {}".format(
            name) if name else "This is unnamed article"))
```

`urls.py`

```python
from django.urls import path
from myapp.views import main, another, main_article, uniq_article, article

urlpatterns = [
    path('', main),
    path('some_url/', another),
    path('article/', main_article, name='mail_article'),
    path('article/33/', uniq_article, name='uniq_article'),
    path('article/<int:article_id>/', article, name='article'),
    path('article/<int:article_id>/<slug:name>', article, name='article_name'),
]
```

Результаты некоторых запросов:

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/unnamed_article.png)

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/named_article.png)

### include

На самом деле path, может принимать не только обработчик, но и специальный параметр `include`, который позволяет
добавить урлы из другого файла к основному.

Например, вы видите, что у нас есть 4 урла которые начинаются на `article/`, а значит что удобным вариантом было бы
вынести урлы в отдельный файл, обычно такие файлы создаются на уровне приложений, а основной файл с урлами содержит
только инклюды

Для того, что бы перенести часть урлов, нам необходимо создать файл `urls.py` в приложении `myapp` (на самом деле мы
могли и назвать его как угодно, и сложить его куда угодно, но так просто удобнее и читаемее), и обязательно в этом файле
создать переменную `urlpatterns` содержащую коллекцию урлов.

Посмотрим на измененные\добавленные файлы:

`myapp/urls.py`

```python
from django.urls import path
from .views import main_article, uniq_article, article

urlpatterns = [
    path('', main_article, name='mail_article'),
    path('33/', uniq_article, name='uniq_article'),
    path('<int:article_id>/', article, name='article'),
    path('<int:article_id>/<slug:name>', article, name='article_name'),
]
```

`mysite/urls.py`

```python
from django.urls import path, include
from myapp.views import main, another

urlpatterns = [
    path('', main),
    path('some_url/', another),
    path('article/', include('myapp.urls'))
]
```

**После этого изменения ни один урл не изменился** - они просто стали по другому располагаться, в случае с 4 урлами не
до конца понятно зачем это может быть нужно, но когда у нас существует 20 приложений и в них 5000+ урлов, структура
становится очень важна, что бы ничего не потерять, поэтому правилом хорошего тона для django кода считается создание
файла с урлами в каждом приложении, а в основном хранить только инклюды на них (Если сделать `url` path('', include('
app.urls')), то можно перенести и те 2 урла которые мы сейчас оставили в основных урлах.)

## re_path

### Регулярные выражения

![](https://www.meme-arsenal.com/memes/d92b55ae26fca33c655197ce4c6a79b9.jpg)

Как говорит нам
википедия [Регуля́рные выраже́ния](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F) (
англ. regular expressions) — используемый в компьютерных программах, работающих с текстом, формальный язык поиска и
осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (символов-джокеров, англ.
wildcard characters). Для поиска используется строка-образец (англ. pattern, по-русски её часто называют «шаблоном»,
«маской»), состоящая из символов и метасимволов и задающая правило поиска. Для манипуляций с текстом дополнительно
задаётся строка замены, которая также может содержать в себе специальные символы.

По факту это механизм который позволяет понять, соответствует ли наша строка заданному шаблону.

![](https://python-school.ru/wp-content/uploads/2020/12/2.jpg)

Например. Бывают случаи когда нам не подходит просто строка или просто число, а нужно указывать более сложные параметры.

Предположим, что нам нужно указать в качестве части урла три цифры и хотя бы 2 буквы (`123blabla`, `432fo`,`111aaaaa`
итд. но `12asd` не подходило)

![](https://miro.medium.com/max/660/0*NfcqRr1hjlXdl2lZ.jpg)

Для того, что бы собрать такую конструкцию нужно воспользоваться синтаксисом регулярных выражений, мне лично нравится
вот этот [сайт](https://regex101.com/), на неё можно изучить базовые принципы использования регулярных выражений.

Получаем необходимое регулярное выражение:

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/regex.png)

Теперь давайте попробуем использовать его в url

`mysite/urls.py`:

```python
from django.urls import path, include, re_path
from myapp.views import main, another, regex

urlpatterns = [
    path('', main),
    path('some_url/', another),
    path('article/', include('myapp.urls')),
    re_path('\d{3}[a-zA-Z]{2,}', regex),
]
```

`views.py`

```python
from django.http import HttpResponse


def main(request):
    return HttpResponse("Hey! It's your main view!!")


def another(request):
    return HttpResponse("It's another page!!")


def main_article(request):
    return HttpResponse('There will be a list with articles')


def uniq_article(request):
    return HttpResponse('This is uniq answer for uniq value')


def article(request, article_id, name=''):
    return HttpResponse(
        "This is an article #{}. {}".format(article_id, "Name of this article is {}".format(
            name) if name else "This is unnamed article"))


def regex(request):
    return HttpResponse("it's regexp")

```

Обратите внимание мы используем не `path`, a `re_path`.

Такой url уже будет работать.

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/regex_url.png)

Но как нам получить значение именно этого регулярного выражения? Как бы не было ужасно, но завернуть его в другое
регулярное выражение.

И после этого не забыть получать его в контролере

`mysite/urls.py`

```python
from django.urls import path, include, re_path
from myapp.views import main, another, regex

urlpatterns = [
    path('', main),
    path('some_url/', another),
    path('article/', include('myapp.urls')),
    re_path(r'^(?P<text>\d{3}[a-zA-Z]{2,}$)', regex),
]

```

`views.py`

```python
from django.http import HttpResponse


def main(request):
    return HttpResponse("Hey! It's your main view!!")


def another(request):
    return HttpResponse("It's another page!!")


def main_article(request):
    return HttpResponse('There will be a list with articles')


def uniq_article(request):
    return HttpResponse('This is uniq answer for uniq value')


def article(request, article_id, name=''):
    return HttpResponse(
        "This is an article #{}. {}".format(article_id, "Name of this article is {}".format(
            name) if name else "This is unnamed article"))


def regex(request, text):
    return HttpResponse(f"it's regexp with text: {text}")

```

![](https://djangoalevel.s3.eu-central-1.amazonaws.com/lesson28/regex_text.png)

Мы получили данные из урла.

Бывают и более сложные конструкции, рассмотрите их
по [вот этой ссылке](https://docs.djangoproject.com/en/3.1/topics/http/urls/)

На практике редко встречаются более сложные конструкции, но джанго представляет нам такую возможность.

# Практика / Домашнее задание:

Вся домашка на ближайшие много занятий описана вот 
[тут](https://edu-python-course.github.io/_build/html/uk/appx/blog/spec.html).

Там прописаны все задачи разбитые на подзадачи, что бы собрать их в один цельный проект

[Задание](https://edu-python-course.github.io/_build/html/uk/appx/blog/spec.html#challenge-functional-views) на это занятие:



- `/about/`: надає звичайний текст для користувача, що описує функції сайту django.
- `/`: Головна сторінка сайту. Тут буде перелік блогів, опублікованих через сайт Django.
- `/<article>/`: Представлення деталей однієї статті. URL містить динамічну частину. Вона буде використовуватися для отримання однієї статті з бази даних.
- `/<article>/comment/`: Це представлення буде використовуватися для додавання коментарів до статті.
- `/create/`: Форма створення статті.
- `/<article>/update/`: Представлення для оновлення існуючих даних статті.
- `/<article>/delete/`: Представлення для підтвердження видалення статті.
- `/topics/`: Перелік доступних тем на сайті.
- `/topics/<topic>/subscribe/`: Представлення для підписки на тему.
- `/topics/<topic>/unsubscribe/`: Представлення для відписки від теми.
- `/profile/<str:username>/`: Особиста сторінка користувача сайту.
- `/set-password/`: Цей маршрут буде використовуватися для зміни облікових даних користувачів.
- `/set-userdata/`: Цей маршрут буде використовуватися для зміни даних користувачів.
- `/deactivate/`: Представлення для деактивації облікового запису (видалення).
- `/register/`: Сторінка з формою для реєстрації нового користувача.
- `/login/`: Сторінка з формою для логіна.
- `/logout/`: Логаут. Має перенаправляти користувача назад на домашню сторінку..
