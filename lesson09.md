# Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты.

### Оглавление курса

<details>
  <summary>Блок 1 — Python Basic (1–6)</summary>

  - [Лекция 1. Введение. Типизации. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.](lesson02.md)
  - [Лекция 3: None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter.](lesson05.md)
  - [Лекция 6. Алгоритмы и структуры данных](lesson06.md)
</details>

<details>
  <summary>Блок 2 — Git (7–8)</summary>

  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md)
  - [Лекция 8. Git. Удалённый репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.](lesson08.md)
</details>

<details open>
  <summary>Блок 3 — Python Advanced (9–14)</summary>

  - ▶ **Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты.**
  - [Лекция 10. Magic methods.](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - [Лекция 14. Проектирование. Паттерны. SOLID.](lesson14.md)
</details>

<details>
  <summary>Блок 4 — SQL (15–17)</summary>

  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи.](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. Group by. Joins.](lesson16.md)
  - [Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup](lesson17.md)
</details>

- [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv.](lesson18.md)

<details>
  <summary>Блок 5 — Django (19–26)</summary>

  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy.](lesson21.md)
  - [Лекция 22. Django ORM.](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication.](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
</details>

<details>
  <summary>Блок 6 — Django Rest Framework (27–30)</summary>

  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework.](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST аутентификация. Авторизация. Permissions. Фильтрация.](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API.](lesson30.md)
</details>

<details>
  <summary>Блок 7 — Python async (31–33)</summary>

  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Асинхронное программирование в Python. Корутины. Asyncio.](lesson32.md)
  - [Лекция 33. Сокеты. Django channels.](lesson33.md)
</details>

<details>
  <summary>Блок 8 — Deployment (34–35)</summary>

  - [Лекция 34. Linux. Всё, что нужно знать для деплоймента.](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
</details>

- [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


![](https://i.pinimg.com/originals/81/a4/77/81a477d2cb7daf3443c8438ec897db1f.png)

## Что такое ООП, и что же такое класс и объект.

Объектно-ориентированное программирование (в дальнейшем — ООП) — парадигма программирования, в которой основными
концепциями являются понятия объектов и классов. Взаимодействие между операциями при помощи объектов.

Если говорить человеческим языком, то в обычной жизни мы не оперируем понятиями строка или кортеж, мы оперируем
объектами.

Мы говорим: «Подай чашку», «Пришли фотку», «Прикольный стол» и т. д. Так вот чашка, фотка и стол в этих примерах будут
являться объектами. Объекты могут обладать некоторыми атрибутами (цвет, название, размер и т. д.) и методами (они же
действия, например, на кнопку можно нажать, автомобиль может ехать, карандаш может писать и т. д.)

![](https://static.tildacdn.com/tild6133-3934-4363-a236-636439333831/Smartiqa_Python_Obje.png)

В центре ООП находится понятие `объекта`.

Объекты создаются на основе `классов`.

Класс — это шаблон для создания объекта. Допустим, у нас есть класс автомобиль, автомобиль — это класс, а конкретный
Lexus синего цвета и 2015 года выпуска — это уже объект класса автомобиль.

Объект — это сущность, экземпляр класса, содержащий свои атрибуты и свои методы, созданный при помощи шаблона (т. е.
класса).

> **Важно:** В Python вообще всё является объектом — и строка, и число, и список, и функция, и метод, и None, и сами
> типы данных. Эта информация понадобится нам в дальнейшем.

Атрибут класса — это данные, принадлежащие самому классу (общие для всех экземпляров, пока не переопределены в экземпляре).
Атрибут экземпляра хранится в самом объекте и может отличаться от значения в классе.

Метод — это функция, определённая внутри класса. Обычно её вызывают у экземпляра (объекта), чтобы выполнить действие.
Например: кофемашина делает кофе.

![](https://skillbox.ru/upload/setka_images/10060020022023_ee673444daa2c4c150863fb4fe2e59385df85324.png)

### Ключевое слово `self`

Что такое `self`? `self` — это специальный аргумент в методах класса, который является ссылкой на экземпляр.

В большинстве случаев (когда нет, обсудим отдельно на следующих занятиях), первым аргументом любого метода будет `self`.
Он обязательный. Чисто технически можно написать любое слово первым аргументом, и это тоже будет работать. Но не надо
так делать. Не сбивайте ни себя, ни других разработчиков. Первый аргумент большинства методов это `self`.

`self` — это конкретный объект внутри метода класса.

Если у нас есть класс студент, то через `self` мы можем получить доступ ко всем атрибутам и методам конкретного
студента, например, списку оценок или методу «прогулять занятие».

Доступ к атрибутам и методам предоставляется через точку.

Ещё про `self`:

- Метод определяется в классе, а вызывается, как правило, у экземпляра: cat.murchalo().
- Внутри метода первый параметр — это `self`: ссылка на тот экземпляр, для которого вызван метод.
- Технически тот же код можно вызвать через класс, но тогда экземпляр нужно передать явно: Cat.murchalo(cat).
- Важно: вызов метода у конкретного объекта не «запускает» его для всех — работает только с тем экземпляром, который передан как `self`.

Вот [тут](https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-the-self-parameter-why-is-it-needed) хорошо
на английском написано.

Наконец, к коду:

```python
# Используем ключевое слово `class`
class Car:
   # Опишем класс Машина, у которого будет два атрибута: цвет и максимальная скорость.
   # Я указал для них типы данных, но для Python это не обязательно, скорее, удобный инструмент.
   # И я указал значения по умолчанию при помощи =. Но это тоже не обязательно, можно было не указывать
   # Обратите внимание: названия классов пишутся с большой буквы и без дополнительных символов вроде _
   color: str = 'red'
   top_speed: int = 250

   # И несколько методов.

   # Вернуть строку с максимальной скоростью и цветом
   def find_color_and_top_speed(self) -> str:
      return f"This car's top speed is {self.top_speed} and color is {self.color}"

   # Вернуть булево значение, которое отвечает на вопрос, может ли машина ехать с указанной скоростью
   def is_car_can_go_with_needed_speed(self, speed: int) -> bool:
      return speed < self.top_speed

   # Назначить максимальную скорость
   def set_top_speed(self, speed: int) -> None:
      self.top_speed = speed

   # Назначить количество колёс. Обратите внимание,
   # такого атрибута изначально вообще не было
   # (лучше так не делать, но технически нет никаких ограничений)
   def set_count_of_wheels(self, wheels: int) -> None:
      self.wheels = wheels


# Как создать объект? Для этого нужно просто «вызвать» класс

lamborghini = Car()
print(lamborghini.find_color_and_top_speed())  # This car's top speed is 250 and color is red
# Когда мы вызываем метод у объекта lamborghini, сам объект lamborghini передается в качестве аргумента self!!
print(lamborghini.is_car_can_go_with_needed_speed(200))  # True
# Доступ к атрибутам можно получить напрямую
print(lamborghini.top_speed)  # 250
lamborghini.set_top_speed(150)  # Назначаем новую максимальную скорость для этого объекта
print(lamborghini.is_car_can_go_with_needed_speed(200))  # False
cherry = Car()
print(cherry.find_color_and_top_speed())  # This car's top speed is 250 and color is red
# Когда мы вызываем метод у объекта cherry, сам объект cherry передается в качестве аргумента self!!
cherry.top_speed = 140
cherry.color = 'yellow'
print(cherry.wheels)  # ВЫЗОВЕТ ОШИБКУ, у нас нет такого атрибута
cherry.set_count_of_wheels(4)
print(cherry.wheels)  # Всё ок, напечатает 4
cherry.size = 'small'  # Можно добавлять атрибуты к любому объекту если это необходимо, у ламборгини такого атрибута не будет, но делать так тоже обычно не стоит
```

## Парадигмы ООП

![](https://img1.joyreactor.cc/pics/post/%D0%BA%D0%BE%D0%BB%D0%B0-%D0%9E%D0%9E%D0%9F-geek-2269253.jpeg)

ООП держится на трёх основных и одной второстепенной парадигме.

### Наследование

![](https://studfile.net/html/71636/410/html_jr0To65ZHB.44IR/htmlconvd-QCA4hj_html_fadf8074562f39b7.png)

`Наследование` — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или
полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или
родительским. Новый класс — потомком, наследником или производным классом.

Например, у нас есть базовый класс автомобиль и три наследника, легковой, самосвал и фура. Все три класса могут иметь
общие атрибуты, например, двигатель или материал лобового стекла, или методы, например, газ и тормоз, но при этом иметь
свои особенные атрибуты или методы, например, только у фуры будет больше 4 колёс, у самосвала будет метод
поднять кузов, или у фуры — отцепить груз.

При описании ООП мне очень нравятся бытовые примеры на автомобилях. Представьте, что при разработке новой модели BMW,
конструкторы решили бы начисто забыть о том, что у них уже были предыдущие модели. Тогда им пришлось бы абсолютно
каждую новую модель разрабатывать с нуля. Возможно ли это? Конечно. Есть ли в этом необходимость? Очень сомнительно.
Если можно взять прошлую модель, немного изменить дизайн, поменять систему тормозов и вставить новые фары, и вуаля,
новая модель готова при минимальных затратах и максимальном результате. С наследованием точно также, можно описывать все
классы с нуля, но часто это очень неудобно и затратно.

#### Пример кода

```python
class Car:
    wheels = 4
    doors = 4
    current_speed = 0
    max_speed = 200

    def go(self):
        self.current_speed = self.max_speed / 2

    def stop(self):
        self.current_speed = 0


# тут класс унаследовал атрибуты wheels и current_speed, а также все методы
class Truck(Car):
    doors = 2
    max_speed = 120


# а тут класс унаследовал все атрибуты кроме max_speed, а также все методы
class SportCar(Car):
    max_speed = 350


truck = Truck()
sport = SportCar()

truck.go()
sport.go()
print(truck.current_speed)  # 60
print(sport.current_speed)  # 175
```

### Метод `super()`

Практически всегда, когда нам нужно в дочернем классе выполнить такое же действие, как и в родительском, нам необходимо
основываться на данных из родительского (в конце блока вы узнаете, что это даже целое правило).

Но как вызвать код из другого класса? Нам поможет метод `super()`.

Допустим, у нас есть класс, который занимается тем, что просто возвращает нам цену продукта.
И ещё два класса, которые вычисляют скидку 10%. И второй класс отнимает ещё 20% уже от уменьшенной цены.

```python
class PriceCounter:
    price = 100

    def calculate_price(self):
        print('In PriceCounter calculate price:')
        return self.price


class DiscountCounter(PriceCounter):

    def calculate_price(self):
        print('In DiscountCounter calculate price: ')
        return super().calculate_price() * 0.9


class SuperDiscountCounter(DiscountCounter):

    def calculate_price(self):
        print('In SuperDiscountCounter calculate price: ')
        return super().calculate_price() * 0.8


price_counter = PriceCounter()
discount_counter = DiscountCounter()
super_discount_counter = SuperDiscountCounter()

print(price_counter.calculate_price())
"""
In PriceCounter calculate price:
100
"""
print(discount_counter.calculate_price())
"""
In DiscountCounter calculate price:
In PriceCounter calculate price:
90.0
"""
print(super_discount_counter.calculate_price())
"""
In SuperDiscountCounter calculate price:
In DiscountCounter calculate price:
In PriceCounter calculate price:
72.0
"""
```

#### Устаревшие синтаксисы

Для Python существуют несколько различных версий, включая 2.х и 3.х.

Версии 2.х считаются устаревшими, но всё-таки иногда можно встретить код на Python 2.x или «отнаследовавшийся от
него».
В Python 3 все классы — «new‑style», поэтому явно наследоваться от `object` не требуется; оба варианта ниже корректны.


```python
class A():  # Лишние скобки — не ошибка, но стиль спорный; в Python 3 это обычный класс
    pass


class B(object):
    """
    Вариант, который тоже будет работать
    и на самом деле показывает нам суть любого класса и объекта в Python,
    вообще всё унаследовано от объекта.
    """


class C:  # Традиционный способ для объявления класса в python3
    pass
```

Заодно познакомились с ключевым словом `pass`, которое нужно в качестве «заглушки», так как класс или функция не могут
быть пустыми, но могут быть с такой заглушкой. Вместо заглушки лучше всё-таки ставить комментарий, если есть
необходимость создать пустой класс (а она вполне бывает).


### Множественное наследование

Множественное наследование — это возможность у класса-потомка наследовать функционал не от одного, а от нескольких
родителей. Благодаря этому мы можем создавать сложные структуры, сохраняя простой и легко поддерживаемый код.

Во многих языках программирования нет множественного наследования, так что давайте разбираться, как это вообще работает.

Например, у нас есть класс автомобиля:

```python
class Auto:
    def ride(self):
        print("Riding on ground")

```

Также у нас есть класс для лодки:

```python
class Boat:
    def swim(self):
        print("Sailing in the ocean")

```

Теперь, если нам нужно запрограммировать автомобиль-амфибию, который будет плавать в воде и ездить по земле, мы вместо
написания нового класса можем просто унаследовать от уже существующих, просто написав их через запятую:

```python
class Auto:
    def ride(self):
        print("Riding on ground")


class Boat:
    def swim(self):
        print("Sailing in the ocean")


class Amphibian(Auto, Boat):
    pass


a = Amphibian()
a.ride()
a.swim()
```

![](https://python-course.eu/images/oop/clock_calendar_500w.webp)

Теперь наш класс имеет атрибуты и методы обоих родителей (их может быть сколько угодно).

Обратите внимание, что объект класса Amphibian будет одновременно объектом класса Auto и Boat, то есть:

```python
a = Amphibian()
isinstance(a, Auto)
# True
isinstance(a, Boat)
# True
isinstance(a, Amphibian)
# True
```

#### Миксины (Mixins)

Миксин, он же примесь, — это тип классов, которые нужны, чтобы добавлять к обычным классам какие-то методы или атрибуты,
но эти классы не используются для создания объектов, только как примесь. (Нас ничего не останавливает создать объект
этого класса, но задача в другом)

Представим, что мы программируем класс для автомобиля.
Мы хотим, чтобы у нас была возможность слушать музыку в машине.
Конечно, можно просто добавить метод `play_music()` в класс `Car`:

```python
class Car:
    def ride(self):
        print("Riding a car")

    def play_music(self, song):
        print(f"Now playing: {song}.")


c = Car()
c.ride()
# Riding a car
c.play_music("Queen - Bohemian Rhapsody")
# Now playing: Queen - Bohemian Rhapsody
```

Но что, если у нас есть ещё и телефон, радио или любой другой девайс, с которого мы будем слушать музыку?
В таком случае лучше вынести функционал проигрывания музыки в отдельный класс-миксин:

```python
class MusicPlayerMixin:
    def play_music(self, song):
        print(f"Now playing: {song}.")
```

Мы можем «домешивать» этот класс в любой, где нужна функция проигрывания музыки:

```python
class Smartphone(MusicPlayerMixin):
    pass


class Radio(MusicPlayerMixin):
    pass


class Amphibian(Auto, Boat, MusicPlayerMixin):
    pass
```

В рамках изучения Django мы будем довольно много использовать такие классы, рекомендую детально ознакомиться.
Небольшие рекомендации по миксинам:
- давайте им суффикс Mixin (например, MusicPlayerMixin);
- избегайте состояния и лишних __init__ в миксинах; держите их маленькими и специализированными;
- если миксин должен переопределять методы баз, ставьте его левее в списке базовых классов.


#### Diamond problem. MRO

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190612120714/diamond-problem-solution.png)

Итак, классы-наследники могут использовать родительские атрибуты и методы.
Но что, если у нескольких родителей будут одинаковые атрибуты или методы?
Какой метод в таком случае будет использовать наследник?

Рассмотрим классический пример:

```python
class A:
    def hi(self):
        print("A")


class B(A):
    def hi(self):
        print("B")


class C(A):
    def hi(self):
        print("C")


class D(B, C):
    pass


d = D()
d.hi()
```

Эта ситуация, так называемое ромбовидное наследование (diamond problem), решается в Python путем установления порядка
разрешения методов.

В современном Python используется C3-линеаризация (MRO, Method Resolution Order). Порядок поиска атрибутов/методов формируется линейно на основе иерархии и указанного порядка базовых классов. Важно, в каком порядке написаны базовые в объявлении класса.

В Python 2 «old‑style» классы имели другой порядок, но «new‑style» (наследующиеся от object) также использовали C3. Сейчас Python 2 устарел.

В Python 3 можно посмотреть, в каком порядке будут проинспектированы родительские классы, при помощи метода класса `mro()`:

#### MRO - Method resolution order

Чтобы посмотреть, в каком порядке Python будет искать атрибуты или методы у родителей, у любого класса можно вызывать
метод `mro()`:

```python
>>> D.mro()
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

Обратите внимание, в конце всегда будет `object`, если вы используете любой Python.
Потому что вообще всё отнаследовано от него, как я и говорил ранее. (Всё это объект!)

Если по какой-то причине вас не устраивает существующий порядок, есть возможность вызвать метод ровно из того класса,
откуда вам надо, но это считается плохой практикой и лучше так не делать, а полностью поменять структуру.

Если вам необходимо использовать метод конкретного родителя, например, `hi()` класса С, нужно напрямую вызвать его по
имени класса, передав `self` в качестве аргумента:

```python
# НЕ НАДО ТАК ДЕЛАТЬ!!!
class D(B, C):
    def call_hi(self):
        C.hi(self)


d = D()
d.call_hi()
```

[Большая статья про МРО и вообще множественное наследование тут](https://habr.com/ru/post/62203/?_ga=2.205768979.1207595081.1598867257-330984554.1578271027)

### Методы `type()`, `isinstance()` и `issubclass()`

У любого объекта всегда есть тип данных. И по факту этим типом данных всегда является класс (да, `str`, `int`, `list`
и т. д., и даже функции — это тоже классы)

Чтобы узнать тип данных любого объекта, необходимо вызвать метод `type()`.

```python
class A:
    pass


a = A()
num = 10
text = 'test_str'
collection = [1, 2, 3]


def some_func():
    pass


print(type(a))  # <class '__main__.A'>
print(type(num))  # <class 'int'>
print(type(text))  # <class 'str'>
print(type(collection))  # <class 'list'>
print(type(some_func))  # <class 'function'>
```

Для того чтобы сравнить и узнать, является ли объект подклассом, существует специальная функция `isinstance()`. Она
принимает на вход объект и класс, либо кортеж из классов, а возвращает булево значение.

И есть такая же функция, которая принимает не объект, а сам класс: `issubclass()`.

```python
class A:
    pass


class B(A):
    pass


class C(B):
    pass


a = A()
b = B()
c = C()

print(isinstance(a, A))  # True
print(isinstance(a, B))  # False
print(isinstance(b, A))  # True
print(isinstance(c, (A, C)))  # True
print(issubclass(type(a), A))  # True
print(issubclass(B, A))  # True
print(issubclass(A, C))  # False
print(issubclass(type(a), (B, C)))  # False
```

### Абстракция

![](https://static.tildacdn.com/tild3939-6466-4061-a132-656632333864/Smartiqa_OOP_Abstrac.png)

Абстракция в объектно-ориентированном программировании — это использование только тех характеристик объекта, которые с
достаточной точностью представляют его в данной системе.

Часто говорят, что абстракция — это не обязательная парадигма ООП.

Вернёмся к примерам с автомобилями. Когда мы управляем автомобилем, мы часто используем руль и поворотники, но часто ли
мы меняем настройку зеркал или подогрева сидений? Не особо. Так вот абстракция о том, чтобы выделять главное и не
тратить лишние ресурсы на второстепенное.

Если говорить простыми словами, то это возможность описать реализацию метода только в том классе, где это необходимо. А
в родительском только описать название и, возможно, какие-то комментарии к будущей реализации.

```python
class Animal:

    def sound(self):
        raise NotImplementedError  # Вызвать ошибку — подробнее об исключениях в конце лекции


class Mouse(Animal):

    def sound(self):
        return 'pee pee'


class Lion(Animal):

    def sound(self):
        return 'roar'

```

Если в этом примере не описать метод `sound()`, то технически всё будет работать, но любая IDE будет подсвечивать, что
вы не описали абстрактный метод.

### Полиморфизм

![](https://cdn.javarush.com/images/article/5d67355f-5702-4ba8-b1c2-5eb3f27fa5b5/800.jpeg)

Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
структуре объекта, т. е. способность одной функции (метода), действовать по-разному в зависимости от обстоятельств
(которые мы сами указываем).

По сути, это возможность использовать одни и те же методы или интерфейсы к различным структурам, например, обычный
знак `+`, ведь мы можем сложить числа, а можем и строки, и получим разный результат, но применим один и тот же метод.

```python
"1" + "1" # "11"
1 + 1 #2
# А ведь это один и тот же плюс
```

В примере с автомобилем, если мы умеем водить Mercedes, то, скорее всего, у нас не вызовет проблем управлять Toyota или
Ford. Ведь для управления мы будем использовать точно те же самые интерфейсы (руль, педали, поворотники и т. д.)

```python
class English:

    def greeting(self):
        print("Hello")


class French:

    def greeting(self):
        print("Bonjour")


def intro(language):
    language.greeting()


flora = English()
michelle = French()

intro(flora)
intro(michelle)
```

Прошлый пример из абстракции тоже подходит, ведь разные звери издают разные звуки. А для нас это не имеет значения, мы
всего лишь вызовем метод `sound()`.

### Инкапсуляция

![](https://cdn.javarush.com/images/article/a3a32228-a349-4de8-b402-16c19fc4db88/1024.jpeg)

`Инкапсуляция` — принцип «убирания с глаз» функционала или данных с предоставлением только входных и выходных
параметров. Например, если в автомобиле повернуть руль налево, то колёса тоже повернутся налево, но как именно это
происходит, от нас скрыто — мы не знаем, какие именно рычаги и шестерёнки в этот момент двигаются внутри автомобиля.
Можем ли мы разобрать и посмотреть? Можем, а надо ли оно нам?

Так же, например, с кофемашиной, мы знаем, что если нажать кнопку с капучино, то мы получим чашку кофе. Какие в этот
момент процессы происходят внутри, нас практически не интересует. Что-то нагревается, где-то по трубкам бежит жидкость.
Но нас интересует только результат. Могу ли я разобрать кофемашину и посмотреть, из чего она состоит? Могу, но у меня
нет в этом необходимости.

Так же и в программировании мы можем «скрыть» внутренние процессы.

![](https://senior.ua/storage/article/651ea79a-83e1-4f4a-9ca4-8968b7ae86f9.jpeg)

В Python инкапсуляция очень условная (всегда можно получить доступ куда угодно, было бы желание). Как сказал создатель
языка, Гвидо Ван Россум: «Мы всё же взрослые люди, зачем мы будем кого-то ограничивать?»

В первую очередь код пишется для людей, поэтому и разделение существует на уровне понимания людей.

Существует три вида состояния атрибутов и свойств, и для их разделения используется специальный синтаксис.

1. Без начального подчёркивания (`name`) — условно `public`. Доступны везде (в объекте, классе, наследниках).

2. С одним подчёркиванием (`_name`) — условно `protected`: по соглашению используем внутри класса и его наследников, а не снаружи.

3. С двумя подчёркиваниями (`__name`) — условно `private`: по соглашению используем внутри самого класса;
   снаружи к ним обращаются через переименование имени (name mangling) — `_ИмяКласса__attr`.

#### Пример кода

```python
class Car:
    color = 'red'
    _top_speed = 250
    __max_carrying = 1000

    def find_color_and_top_speed(self):
        return f"This car's top speed is {self._top_speed} and color is {self.color}."

    def can_go_with_needed_speed(self, speed):
        return speed < self._top_speed

    def can_get_weight(self, weight):
        return self.__max_carrying > weight

    def change_max_carrying(self, new_carrying):
        self.__max_carrying = new_carrying

    def __private_method(self):
        print('This is private method')

    def _this_is_protected_method(self):
        print('This is protected method')

    def run_hidden_and_protected_methods(self):
        self.__private_method()
        self._this_is_protected_method()


class Truck(Car):
    def _this_is_protected_method(self):
       super()._this_is_protected_method()  # всё хорошо

    def __private_method(self):
       super().__private_method() # не заработает

car = Car()
car.color  # всё нормально
car._top_speed  # сработает, но мы же сами описали это свойство так, чтобы сообщить, что не надо так его использовать
car.__max_carrying  # не сработает (будет ошибка, что этот атрибут не найден)
car._Car__max_carrying  # Сработает, и это как раз описание того, что добраться можно куда угодно. Но сам синтаксис нам говорит, что мы что-то не то делаем
car.__max_carrying = 800  # создаст НОВЫЙ атрибут у экземпляра; реальный «приватный» не изменится
car.change_max_carrying(800)  # сработает
car.__private_method()  # не сработает (AttributeError из‑за name mangling)
car._this_is_protected_method()  # сработает, но опять же не надо этого делать
car.run_hidden_and_protected_methods()  # сработает и вызовет защищённый и приватный методы
```

![](https://miro.medium.com/v2/resize:fit:1400/1*4TQU8gAHJAJasc-Lwx2APw.png)

## Создание собственных исключений

Ранее в разделе про абстракцию мы видели `raise NotImplementedError`. Теперь разберёмся, как создавать собственные
исключения — это важный навык для написания понятного и поддерживаемого кода.

### Зачем нужны собственные исключения?

Собственные исключения позволяют:

1. **Улучшить читабельность кода**: описательные имена исключений сразу показывают, какая ошибка произошла
2. **Обеспечить точность обработки ошибок**: можно точно указать, какие ошибки перехватывать
3. **Создавать иерархию ошибок**: базовые и специализированные исключения для гибкой обработки

### Как создать собственное исключение?

Для создания исключения нужно создать класс, который наследует от `Exception`:

```python
class MyCustomError(Exception):
    """Класс для пользовательского исключения."""
    pass
```

#### Исключение с дополнительной информацией

```python
class InvalidInputError(Exception):
    """Исключение вызывается, когда ввод недействителен."""

    def __init__(self, message, value):
        self.message = message
        self.value = value
        super().__init__(self.message)

    def __str__(self):
        return f'{self.message}: {self.value}'
```

### Использование собственных исключений

```python
def divide(a, b):
    if b == 0:
        raise InvalidInputError("Деление на ноль", b)
    return a / b

try:
    result = divide(10, 0)
except InvalidInputError as e:
    print(e)  # Деление на ноль: 0
```

### Иерархия пользовательских исключений

Создание иерархии полезно, когда код может генерировать разные виды связанных ошибок:

```python
class ApplicationError(Exception):
    """Базовый класс для всех исключений приложения."""
    pass


class DatabaseError(ApplicationError):
    """Исключения, связанные с базой данных."""
    pass


class ValidationError(ApplicationError):
    """Исключения, связанные с валидацией данных."""
    pass


# Использование
def connect_to_database():
    raise DatabaseError("Не удалось подключиться к базе данных")

try:
    connect_to_database()
except ApplicationError as e:
    # Поймает и DatabaseError, и ValidationError
    print(f"Произошла ошибка приложения: {e}")
```

> Создавайте собственные исключения, когда встроенных недостаточно для описания специфики вашей бизнес-логики.

Все тонкости и детали можно познать только на практике. Так что задачи на практику/домашние:

1. Описываем телефон:

   Класс телефон. У него должны быть:
    - Поле для описания номера.
    - Метод, чтобы задать номер телефона.
    - Защищённое поле для счётчика входящих звонков.
    - Метод, который вернёт нам количество принятых звонков.
    - Метод принять звонок, который добавляет к счётчику единицу.

   Создайте три разных объекта телефона.

   Поменяйте всем изначальный номер.

   Примите по несколько звонков на каждом (разное количество)

   Напишите функцию, которая принимает список из объектов телефонов, а возвращает общее количество принятых звонков
   со всех телефонов.

2. Опишите класс для шахматной фигуры.

   Фигура должна содержать такие атрибуты:
    - Цвет (белый или чёрный).
    - Место на доске (тут есть варианты, или два отдельных поля, для описания координат или одно, но, например, кортеж
      из двух чисел).
      И такие методы как:
    - Изменить цвет (ничего не принимает, только меняет цвет на противоположный).
    - Изменить место на доске (принимает или две переменные, или один кортеж из двух элементов), не забудьте проверить,
      что мы не пытаемся поставить фигуру за пределы доски (оба значения от 0 до 7).
    - Абстрактный метод проверки потенциального хода (детали ниже).
      На данном этапе фигуры могут стоять на одной и той же клетке, пока нам это не важно.

   Опишите классы для пешки, коня, офицера, ладьи, ферзя и короля.
   Всё, что в них нужно добавить, — это один метод для проверки,
   возможно ли за один ход поменять место фигуры на доске (все ходят по-разному, у пешек будет ещё и разница от цвета).
   Метод принимает опять же или две цифры, или один кортеж. И опять же проверяем, не выходит ли значение за пределы
   доски (так как нам необходим этот функционал дважды, я бы делал его как отдельный защищённый метод в родительском
   классе)

   И функцию, которая принимает список фигур и потенциальную новую клетку, а возвращает список из фигур. Но только тех,
   которые могут за один ход добраться до этой клетки.

3. Создайте класс `Student` с такими полями:
   - Имя
   - Возраст
   - Список оценок

   И класс `Group`:
   - список `Student`
   - название

   **Эти два класса нам понадобятся на следующем занятии**