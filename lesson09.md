# Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты. Множественное наследование.

### Оглавление курса

<details>
  <summary>Блок 1 — Python Basic (1–6)</summary>

  - [Лекция 1. Введение. Типизации. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.](lesson02.md)
  - [Лекция 3: None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter.](lesson05.md)
  - [Лекция 6. Алгоритмы и структуры данных](lesson06.md)
</details>

<details>
  <summary>Блок 2 — Git (7–8)</summary>

  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md)
  - [Лекция 8. Git. Удалённый репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.](lesson08.md)
</details>

<details open>
  <summary>Блок 3 — Python Advanced (9–14)</summary>

  - ▶ **Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты. Множественное наследование.**
  - [Лекция 10. Magic methods. Итераторы и генераторы.](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - [Лекция 14. Проектирование. Паттерны. SOLID.](lesson14.md)
</details>

<details>
  <summary>Блок 4 — SQL (15–17)</summary>

  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи.](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. Group by. Joins.](lesson16.md)
  - [Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup](lesson17.md)
</details>

- [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv.](lesson18.md)

<details>
  <summary>Блок 5 — Django (19–26)</summary>

  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy.](lesson21.md)
  - [Лекция 22. Django ORM.](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication.](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
</details>

<details>
  <summary>Блок 6 — Django Rest Framework (27–30)</summary>

  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework.](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST аутентификация. Авторизация. Permissions. Фильтрация.](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API.](lesson30.md)
</details>

<details>
  <summary>Блок 7 — Python async (31–33)</summary>

  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Asyncio. Aiohttp. Асинхронное программирование на практике.](lesson32.md)
  - [Лекция 33. Сокеты. Django channels.](lesson33.md)
</details>

<details>
  <summary>Блок 8 — Deployment (34–35)</summary>

  - [Лекция 34. Linux. Всё, что нужно знать для деплоймента.](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
</details>

- [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


![](https://i.pinimg.com/originals/81/a4/77/81a477d2cb7daf3443c8438ec897db1f.png)

## Что такое ООП, и что же такое класс и объект.

Объектно-ориентированное программирование (в дальнейшем — ООП) — парадигма программирования, в которой основными
концепциями являются понятия объектов и классов. Взаимодействие между операциями при помощи объектов.

Если говорить человеческим языком, то в обычной жизни мы не оперируем понятиями строка или кортеж, мы оперируем
объектами.

Мы говорим: «Подай чашку», «Пришли фотку», «Прикольный стол» и т. д. Так вот чашка, фотка и стол в этих примерах будут
являться объектами. Объекты могут обладать некоторыми атрибутами (цвет, название, размер и т. д.) и методами (они же
действия: например, на кнопку можно нажать, автомобиль может ехать, карандаш может писать и т. д.).

![](https://static.tildacdn.com/tild6133-3934-4363-a236-636439333831/Smartiqa_Python_Obje.png)

В центре ООП находится понятие `объекта`.

Объекты создаются на основе `классов`.

Класс — это шаблон для создания объекта. Допустим, у нас есть класс автомобиль, автомобиль — это класс, а конкретный
Lexus синего цвета и 2015 года выпуска — это уже объект класса автомобиль.

Объект — это сущность, экземпляр класса, содержащий свои атрибуты и методы, созданный при помощи шаблона (т. е.
класса).

> **Важно:** В Python вообще всё является объектом — и строка, и число, и список, и функция, и метод, и None, и сами
> типы данных. Эта информация понадобится нам в дальнейшем.

Атрибут класса — это данные, принадлежащие самому классу (общие для всех экземпляров, пока не переопределены в экземпляре).
Атрибут экземпляра хранится в самом объекте и может отличаться от значения в классе.

Метод — это функция, определённая внутри класса. Обычно её вызывают у экземпляра (объекта), чтобы выполнить действие.
Например: кофемашина делает кофе.

![](https://skillbox.ru/upload/setka_images/10060020022023_ee673444daa2c4c150863fb4fe2e59385df85324.png)

### Ключевое слово `self`

Что такое `self`? `self` — это специальный аргумент в методах класса, который является ссылкой на экземпляр.

В большинстве случаев (когда нет — обсудим отдельно на следующих занятиях) первым аргументом любого метода будет `self`.
Он обязательный. Чисто технически можно написать любое слово первым аргументом, и это тоже будет работать. Но не надо
так делать. Не сбивайте ни себя, ни других разработчиков. Первый аргумент большинства методов — это `self`.

`self` — это конкретный объект внутри метода класса.

Если у нас есть класс студент, то через `self` мы можем получить доступ ко всем атрибутам и методам конкретного
студента, например, списку оценок или методу «прогулять занятие».

Доступ к атрибутам и методам предоставляется через точку.

Ещё про `self`:

- Метод определяется в классе, а вызывается, как правило, у экземпляра: `cat.murchalo()`.
- Внутри метода первый параметр — это `self`: ссылка на тот экземпляр, для которого вызван метод.
- Технически тот же код можно вызвать через класс, но тогда экземпляр нужно передать явно: `Cat.murchalo(cat)`.
- Важно: вызов метода у конкретного объекта не «запускает» его для всех — работает только с тем экземпляром, который передан как `self`.

Вот [тут](https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-the-self-parameter-why-is-it-needed) хорошо
на английском написано.

Наконец, к коду:

```python
# Используем ключевое слово `class`
class Car:
   # Опишем класс Машина, у которого будет два атрибута: цвет и максимальная скорость.
   # Я указал для них типы данных, но для Python это не обязательно, скорее, удобный инструмент.
   # И я указал значения по умолчанию при помощи =. Но это тоже не обязательно, можно было не указывать
   # Обратите внимание: названия классов пишутся с большой буквы и без дополнительных символов вроде _
   color: str = 'red'
   top_speed: int = 250

   # И несколько методов.

   # Вернуть строку с максимальной скоростью и цветом
   def find_color_and_top_speed(self) -> str:
      return f"This car's top speed is {self.top_speed} and color is {self.color}"

   # Вернуть булево значение, которое отвечает на вопрос, может ли машина ехать с указанной скоростью
   def is_car_can_go_with_needed_speed(self, speed: int) -> bool:
      return speed < self.top_speed

   # Назначить максимальную скорость
   def set_top_speed(self, speed: int) -> None:
      self.top_speed = speed

   # Назначить количество колёс. Обратите внимание,
   # такого атрибута изначально вообще не было
   # (лучше так не делать, но технически нет никаких ограничений)
   def set_count_of_wheels(self, wheels: int) -> None:
      self.wheels = wheels


# Как создать объект? Для этого нужно просто «вызвать» класс

lamborghini = Car()
print(lamborghini.find_color_and_top_speed())  # This car's top speed is 250 and color is red
# Когда мы вызываем метод у объекта lamborghini, сам объект lamborghini передается в качестве аргумента self!!
print(lamborghini.is_car_can_go_with_needed_speed(200))  # True
# Доступ к атрибутам можно получить напрямую
print(lamborghini.top_speed)  # 250
lamborghini.set_top_speed(150)  # Назначаем новую максимальную скорость для этого объекта
print(lamborghini.is_car_can_go_with_needed_speed(200))  # False
cherry = Car()
print(cherry.find_color_and_top_speed())  # This car's top speed is 250 and color is red
# Когда мы вызываем метод у объекта cherry, сам объект cherry передается в качестве аргумента self!!
cherry.top_speed = 140
cherry.color = 'yellow'
print(cherry.wheels)  # ВЫЗОВЕТ ОШИБКУ, у нас нет такого атрибута
cherry.set_count_of_wheels(4)
print(cherry.wheels)  # Всё ок, напечатает 4
cherry.size = 'small'  # Можно добавлять атрибуты к любому объекту, если это необходимо; у ламборгини такого атрибута не будет, но делать так тоже обычно не стоит
```

## Парадигмы ООП

![](https://img1.joyreactor.cc/pics/post/%D0%BA%D0%BE%D0%BB%D0%B0-%D0%9E%D0%9E%D0%9F-geek-2269253.jpeg)

ООП держится на трёх основных и одной второстепенной парадигме.

### Наследование

![](https://studfile.net/html/71636/410/html_jr0To65ZHB.44IR/htmlconvd-QCA4hj_html_fadf8074562f39b7.png)

**Наследование** — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или
полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или
родительским. Новый класс — потомком, наследником или производным классом.

Например, у нас есть базовый класс «автомобиль» и три наследника: легковой, самосвал и фура. Все три класса могут иметь
общие атрибуты (например, двигатель или материал лобового стекла) или методы (например, газ и тормоз), но при этом иметь
свои особенные атрибуты или методы: например, только у фуры будет больше 4 колёс, у самосвала будет метод
«поднять кузов», а у фуры — «отцепить груз».

При описании ООП мне очень нравятся бытовые примеры на автомобилях. Представьте, что при разработке новой модели BMW,
конструкторы решили бы начисто забыть о том, что у них уже были предыдущие модели. Тогда им пришлось бы абсолютно
каждую новую модель разрабатывать с нуля. Возможно ли это? Конечно. Есть ли в этом необходимость? Очень сомнительно.
Если можно взять прошлую модель, немного изменить дизайн, поменять систему тормозов и вставить новые фары — и вуаля,
новая модель готова при минимальных затратах и максимальном результате. С наследованием точно так же: можно описывать все
классы с нуля, но часто это очень неудобно и затратно.

#### Пример кода

```python
class Car:
    wheels = 4
    doors = 4
    current_speed = 0
    max_speed = 200

    def go(self):
        self.current_speed = self.max_speed / 2

    def stop(self):
        self.current_speed = 0


# тут класс унаследовал атрибуты wheels и current_speed, а также все методы
class Truck(Car):
    doors = 2
    max_speed = 120


# а тут класс унаследовал все атрибуты кроме max_speed, а также все методы
class SportCar(Car):
    max_speed = 350


truck = Truck()
sport = SportCar()

truck.go()
sport.go()
print(truck.current_speed)  # 60
print(sport.current_speed)  # 175
```

### Метод `super()`

Практически всегда, когда нам нужно в дочернем классе выполнить такое же действие, как и в родительском, необходимо
основываться на данных из родительского (в конце блока вы узнаете, что это даже целое правило).

Но как вызвать код из другого класса? Нам поможет метод `super()`.

Допустим, у нас есть класс, который занимается тем, что просто возвращает нам цену продукта.
И ещё два класса, которые вычисляют скидку 10%. И второй класс отнимает ещё 20% уже от уменьшенной цены.

```python
class PriceCounter:
    price = 100

    def calculate_price(self):
        print('In PriceCounter calculate price:')
        return self.price


class DiscountCounter(PriceCounter):

    def calculate_price(self):
        print('In DiscountCounter calculate price: ')
        return super().calculate_price() * 0.9


class SuperDiscountCounter(DiscountCounter):

    def calculate_price(self):
        print('In SuperDiscountCounter calculate price: ')
        return super().calculate_price() * 0.8


price_counter = PriceCounter()
discount_counter = DiscountCounter()
super_discount_counter = SuperDiscountCounter()

print(price_counter.calculate_price())
"""
In PriceCounter calculate price:
100
"""
print(discount_counter.calculate_price())
"""
In DiscountCounter calculate price:
In PriceCounter calculate price:
90.0
"""
print(super_discount_counter.calculate_price())
"""
In SuperDiscountCounter calculate price:
In DiscountCounter calculate price:
In PriceCounter calculate price:
72.0
"""
```

#### Устаревшие синтаксисы

Для Python существуют несколько различных версий, включая 2.х и 3.х.

Версии 2.х считаются устаревшими, но всё-таки иногда можно встретить код на Python 2.x или «отнаследовавшийся» от
него.
В Python 3 все классы — «new-style», поэтому явно наследоваться от `object` не требуется; оба варианта ниже корректны.


```python
class A():  # Лишние скобки — не ошибка, но стиль спорный; в Python 3 это обычный класс
    pass


class B(object):
    """
    Вариант, который тоже будет работать
    и на самом деле показывает нам суть любого класса и объекта в Python,
    вообще всё унаследовано от объекта.
    """


class C:  # Традиционный способ для объявления класса в python3
    pass
```

Заодно познакомились с ключевым словом `pass`, которое нужно в качестве «заглушки», так как класс или функция не могут
быть пустыми, но могут быть с такой заглушкой. Вместо заглушки лучше всё-таки ставить docstring, если есть
необходимость создать пустой класс (а она вполне бывает).


### Множественное наследование

![](https://i.ytimg.com/vi/ektST9ppziE/maxresdefault.jpg)

Множественное наследование — это возможность у класса-потомка наследовать функционал не от одного, а от нескольких
родителей. Благодаря этому мы можем создавать сложные структуры, сохраняя простой и легко поддерживаемый код.

Во многих языках программирования нет множественного наследования, так что давайте разберёмся, как это вообще работает.

Например, у нас есть класс автомобиля:

```python
class Auto:
    def ride(self):
        print("Riding on ground")

```

Также у нас есть класс для лодки:

```python
class Boat:
    def swim(self):
        print("Sailing in the ocean")

```

Теперь, если нам нужно запрограммировать автомобиль-амфибию, который будет плавать в воде и ездить по земле, мы вместо
написания нового класса можем унаследовать от уже существующих, просто написав их через запятую:

```python
class Auto:
    def ride(self):
        print("Riding on ground")


class Boat:
    def swim(self):
        print("Sailing in the ocean")


class Amphibian(Auto, Boat):
    pass


a = Amphibian()
a.ride()
a.swim()
```

![](https://python-course.eu/images/oop/clock_calendar_500w.webp)

Теперь наш класс имеет атрибуты и методы обоих родителей (их может быть сколько угодно).

Обратите внимание, что объект класса Amphibian будет одновременно объектом класса Auto и Boat, то есть:

```python
a = Amphibian()
isinstance(a, Auto)
# True
isinstance(a, Boat)
# True
isinstance(a, Amphibian)
# True
```

#### Миксины (Mixins)

Миксин, он же примесь, — это тип классов, которые нужны, чтобы добавлять к обычным классам какие-то методы или атрибуты,
но эти классы не используются для создания объектов, только как примесь (нас ничего не останавливает создать объект
этого класса, но задача в другом).

Представим, что мы программируем класс для автомобиля.
Мы хотим, чтобы у нас была возможность слушать музыку в машине.
Конечно, можно просто добавить метод `play_music()` в класс `Car`:

```python
class Car:
    def ride(self):
        print("Riding a car")

    def play_music(self, song):
        print(f"Now playing: {song}.")


c = Car()
c.ride()
# Riding a car
c.play_music("Queen - Bohemian Rhapsody")
# Now playing: Queen - Bohemian Rhapsody
```

Но что, если у нас есть ещё и телефон, радио или любой другой девайс, с которого мы будем слушать музыку?
В таком случае лучше вынести функционал проигрывания музыки в отдельный класс-миксин:

```python
class MusicPlayerMixin:
    def play_music(self, song):
        print(f"Now playing: {song}.")
```

Мы можем «домешивать» этот класс в любой, где нужна функция проигрывания музыки:

```python
class Smartphone(MusicPlayerMixin):
    pass


class Radio(MusicPlayerMixin):
    pass


class Amphibian(Auto, Boat, MusicPlayerMixin):
    pass
```

В рамках изучения Django мы будем довольно много использовать такие классы, рекомендую детально ознакомиться.
Небольшие рекомендации по миксинам:
- давайте им суффикс `Mixin` (например, `MusicPlayerMixin`);
- избегайте состояния и лишних `__init__` в миксинах; держите их маленькими и специализированными;
- если миксин должен переопределять методы базовых классов, ставьте его левее в списке базовых классов.


#### Diamond problem. MRO

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190612120714/diamond-problem-solution.png)

Итак, классы-наследники могут использовать родительские атрибуты и методы.
Но что, если у нескольких родителей будут одинаковые атрибуты или методы?
Какой метод в таком случае будет использовать наследник?

Рассмотрим классический пример:

```python
class A:
    def hi(self):
        print("A")


class B(A):
    def hi(self):
        print("B")


class C(A):
    def hi(self):
        print("C")


class D(B, C):
    pass


d = D()
d.hi()
```

Эта ситуация, так называемое ромбовидное наследование (diamond problem), решается в Python путем установления порядка
разрешения методов.

В современном Python используется C3-линеаризация (MRO — Method Resolution Order). Порядок поиска атрибутов/методов формируется линейно на основе иерархии и указанного порядка базовых классов. Важно, в каком порядке написаны базовые классы в объявлении класса.

В Python 2 «old-style» классы имели другой порядок, но «new-style» (наследующиеся от `object`) также использовали C3. Сейчас Python 2 устарел.

В Python 3 можно посмотреть, в каком порядке будут проинспектированы родительские классы, при помощи метода класса `mro()`:

#### MRO — Method Resolution Order

Чтобы посмотреть, в каком порядке Python будет искать атрибуты или методы у родителей, у любого класса можно вызвать
метод `mro()`:

```python
>>> D.mro()
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

Обратите внимание, в конце всегда будет `object`, если вы используете любой Python.
Потому что вообще всё отнаследовано от него, как я и говорил ранее (всё — это объект!).

Если по какой-то причине вас не устраивает существующий порядок, есть возможность вызвать метод ровно из того класса,
откуда вам надо, но это считается плохой практикой и лучше так не делать, а полностью поменять структуру.

Если вам необходимо использовать метод конкретного родителя, например, `hi()` класса С, нужно напрямую вызвать его по
имени класса, передав `self` в качестве аргумента:

```python
# НЕ НАДО ТАК ДЕЛАТЬ!!!
class D(B, C):
    def call_hi(self):
        C.hi(self)


d = D()
d.call_hi()
```

[Большая статья про МРО и вообще множественное наследование тут](https://habr.com/ru/post/62203/?_ga=2.205768979.1207595081.1598867257-330984554.1578271027)

### Методы `type()`, `isinstance()` и `issubclass()`

У любого объекта всегда есть тип данных. И по факту этим типом данных всегда является класс (да, `str`, `int`, `list`
и т. д., и даже функции — это тоже классы).

Чтобы узнать тип данных любого объекта, необходимо вызвать метод `type()`.

```python
class A:
    pass


a = A()
num = 10
text = 'test_str'
collection = [1, 2, 3]


def some_func():
    pass


print(type(a))  # <class '__main__.A'>
print(type(num))  # <class 'int'>
print(type(text))  # <class 'str'>
print(type(collection))  # <class 'list'>
print(type(some_func))  # <class 'function'>
```

Для того чтобы сравнить и узнать, является ли объект подклассом, существует специальная функция `isinstance()`. Она
принимает на вход объект и класс, либо кортеж из классов, а возвращает булево значение.

И есть такая же функция, которая принимает не объект, а сам класс: `issubclass()`.

```python
class A:
    pass


class B(A):
    pass


class C(B):
    pass


a = A()
b = B()
c = C()

print(isinstance(a, A))  # True
print(isinstance(a, B))  # False
print(isinstance(b, A))  # True
print(isinstance(c, (A, C)))  # True
print(issubclass(type(a), A))  # True
print(issubclass(B, A))  # True
print(issubclass(A, C))  # False
print(issubclass(type(a), (B, C)))  # False
```

### Абстракция

![](https://static.tildacdn.com/tild3939-6466-4061-a132-656632333864/Smartiqa_OOP_Abstrac.png)

Абстракция в объектно-ориентированном программировании — это использование только тех характеристик объекта, которые с
достаточной точностью представляют его в данной системе.

Часто говорят, что абстракция — это не обязательная парадигма ООП.

Вернёмся к примерам с автомобилями. Когда мы управляем автомобилем, мы часто используем руль и поворотники, но часто ли
мы меняем настройку зеркал или подогрева сидений? Не особо. Так вот, абстракция — о том, чтобы выделять главное и не
тратить лишние ресурсы на второстепенное.

Если говорить простыми словами, то это возможность описать реализацию метода только в том классе, где это необходимо. А
в родительском только описать название и, возможно, какие-то комментарии к будущей реализации.

```python
class Animal:

    def sound(self):
        raise NotImplementedError  # Вызвать ошибку — подробнее об исключениях в конце лекции


class Mouse(Animal):

    def sound(self):
        return 'pee pee'


class Lion(Animal):

    def sound(self):
        return 'roar'

```

Если в этом примере не описать метод `sound()`, то технически всё будет работать, но любая IDE будет подсвечивать, что
вы не описали абстрактный метод.

### Полиморфизм

![](https://cdn.javarush.com/images/article/5d67355f-5702-4ba8-b1c2-5eb3f27fa5b5/800.jpeg)

Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
структуре объекта, т. е. способность одной функции (метода) действовать по-разному в зависимости от обстоятельств
(которые мы сами указываем).

По сути, это возможность использовать одни и те же методы или интерфейсы к различным структурам, например, обычный
знак `+`, ведь мы можем сложить числа, а можем и строки, и получим разный результат, но применим один и тот же метод.

```python
"1" + "1"  # "11"
1 + 1  # 2
# А ведь это один и тот же плюс
```

В примере с автомобилем: если мы умеем водить Mercedes, то, скорее всего, у нас не вызовет проблем управлять Toyota или
Ford. Ведь для управления мы будем использовать точно те же самые интерфейсы (руль, педали, поворотники и т. д.).

```python
class English:

    def greeting(self):
        print("Hello")


class French:

    def greeting(self):
        print("Bonjour")


def intro(language):
    language.greeting()


flora = English()
michelle = French()

intro(flora)
intro(michelle)
```

Прошлый пример из абстракции тоже подходит, ведь разные звери издают разные звуки. А для нас это не имеет значения, мы
всего лишь вызовем метод `sound()`.

### Инкапсуляция

![](https://cdn.javarush.com/images/article/a3a32228-a349-4de8-b402-16c19fc4db88/1024.jpeg)

**Инкапсуляция** — принцип «убирания с глаз» функционала или данных с предоставлением только входных и выходных
параметров. Например, если в автомобиле повернуть руль налево, то колёса тоже повернутся налево, но как именно это
происходит — от нас скрыто: мы не знаем, какие именно рычаги и шестерёнки в этот момент двигаются внутри автомобиля.
Можем ли мы разобрать и посмотреть? Можем. А надо ли оно нам?

Так же, например, с кофемашиной: мы знаем, что если нажать кнопку с капучино, то мы получим чашку кофе. Какие в этот
момент процессы происходят внутри — нас практически не интересует. Что-то нагревается, где-то по трубкам бежит жидкость.
Но нас интересует только результат. Могу ли я разобрать кофемашину и посмотреть, из чего она состоит? Могу. Но у меня
нет в этом необходимости.

Так же и в программировании мы можем «скрыть» внутренние процессы.

![](https://senior.ua/storage/article/651ea79a-83e1-4f4a-9ca4-8968b7ae86f9.jpeg)

В Python инкапсуляция очень условная (всегда можно получить доступ куда угодно, было бы желание). Как сказал создатель
языка, Гвидо Ван Россум: «Мы всё же взрослые люди, зачем мы будем кого-то ограничивать?»

В первую очередь код пишется для людей, поэтому и разделение существует на уровне понимания людей.

Существует три вида состояния атрибутов и свойств, и для их разделения используется специальный синтаксис.

1. Без начального подчёркивания (`name`) — условно `public`. Доступны везде (в объекте, классе, наследниках).

2. С одним подчёркиванием (`_name`) — условно `protected`: по соглашению используем внутри класса и его наследников, а не снаружи.

3. С двумя подчёркиваниями (`__name`) — условно `private`: по соглашению используем только внутри самого класса;
   снаружи к ним можно обратиться через переименование имени (name mangling) — `_ИмяКласса__attr`.

#### Пример кода

```python
class Car:
    color = 'red'
    _top_speed = 250
    __max_carrying = 1000

    def find_color_and_top_speed(self):
        return f"This car's top speed is {self._top_speed} and color is {self.color}."

    def can_go_with_needed_speed(self, speed):
        return speed < self._top_speed

    def can_get_weight(self, weight):
        return self.__max_carrying > weight

    def change_max_carrying(self, new_carrying):
        self.__max_carrying = new_carrying

    def __private_method(self):
        print('This is private method')

    def _this_is_protected_method(self):
        print('This is protected method')

    def run_hidden_and_protected_methods(self):
        self.__private_method()
        self._this_is_protected_method()


class Truck(Car):
    def _this_is_protected_method(self):
       super()._this_is_protected_method()  # всё хорошо

    def __private_method(self):
       super().__private_method() # не заработает

car = Car()
car.color  # всё нормально
car._top_speed  # сработает, но мы же сами описали это свойство так, чтобы сообщить, что не надо так его использовать
car.__max_carrying  # не сработает (будет ошибка, что этот атрибут не найден)
car._Car__max_carrying  # Сработает, и это как раз описание того, что добраться можно куда угодно. Но сам синтаксис нам говорит, что мы что-то не то делаем
car.__max_carrying = 800  # создаст НОВЫЙ атрибут у экземпляра; реальный «приватный» не изменится
car.change_max_carrying(800)  # сработает
car.__private_method()  # не сработает (AttributeError из-за name mangling)
car._this_is_protected_method()  # сработает, но опять же не надо этого делать
car.run_hidden_and_protected_methods()  # сработает и вызовет защищённый и приватный методы
```

![](https://miro.medium.com/v2/resize:fit:1400/1*4TQU8gAHJAJasc-Lwx2APw.png)

## Создание собственных исключений

Ранее в разделе про абстракцию мы видели `raise NotImplementedError`. Теперь разберёмся, как создавать собственные
исключения — это важный навык для написания понятного и поддерживаемого кода.

### Зачем нужны собственные исключения?

Собственные исключения позволяют:

1. **Улучшить читабельность кода**: описательные имена исключений сразу показывают, какая ошибка произошла
2. **Обеспечить точность обработки ошибок**: можно точно указать, какие ошибки перехватывать
3. **Создавать иерархию ошибок**: базовые и специализированные исключения для гибкой обработки

### Как создать собственное исключение?

Для создания исключения нужно создать класс, который наследует от `Exception`:

```python
class MyCustomError(Exception):
    """Класс для пользовательского исключения."""
    pass
```

#### Исключение с дополнительной информацией

```python
class InvalidInputError(Exception):
    """Исключение вызывается, когда ввод недействителен."""

    def __init__(self, message, value):
        self.message = message
        self.value = value
        super().__init__(self.message)

    def __str__(self):
        return f'{self.message}: {self.value}'
```

### Использование собственных исключений

```python
def divide(a, b):
    if b == 0:
        raise InvalidInputError("Деление на ноль", b)
    return a / b

try:
    result = divide(10, 0)
except InvalidInputError as e:
    print(e)  # Деление на ноль: 0
```

### Иерархия пользовательских исключений

Создание иерархии полезно, когда код может генерировать разные виды связанных ошибок:

```python
class ApplicationError(Exception):
    """Базовый класс для всех исключений приложения."""
    pass


class DatabaseError(ApplicationError):
    """Исключения, связанные с базой данных."""
    pass


class ValidationError(ApplicationError):
    """Исключения, связанные с валидацией данных."""
    pass


# Использование
def connect_to_database():
    raise DatabaseError("Не удалось подключиться к базе данных")

try:
    connect_to_database()
except ApplicationError as e:
    # Поймает и DatabaseError, и ValidationError
    print(f"Произошла ошибка приложения: {e}")
```

> Создавайте собственные исключения, когда встроенных недостаточно для описания специфики вашей бизнес-логики.

Все тонкости и детали можно познать только на практике.

---

## Практика на занятии

### Задание 1. Телефон (базовые классы и инкапсуляция)

Создайте класс `Phone`:
- Поле `number` для номера телефона
- Защищённое поле `_call_count` для счётчика входящих звонков (изначально 0)
- Метод `set_number(number)` для установки номера
- Метод `get_call_count()` — возвращает количество принятых звонков
- Метод `receive_call()` — увеличивает счётчик на 1

```python
# Пример использования:
phone1 = Phone()
phone1.set_number("+380501234567")
phone1.receive_call()
phone1.receive_call()
print(phone1.get_call_count())  # 2
```

Создайте три объекта телефона, установите им разные номера, примите разное количество звонков.

Напишите функцию `total_calls(phones: list) -> int`, которая принимает список телефонов и возвращает общее количество звонков со всех телефонов.

### Задание 2. Животные (наследование и полиморфизм)

Создайте базовый класс `Animal`:
- Атрибут `name`
- Метод `speak()` — возвращает строку (в базовом классе можно вернуть `"..."`)

Создайте классы-наследники:
- `Dog` — метод `speak()` возвращает `"Гав!"`
- `Cat` — метод `speak()` возвращает `"Мяу!"`
- `Cow` — метод `speak()` возвращает `"Муу!"`

```python
# Пример использования:
animals = [Dog("Бобик"), Cat("Мурка"), Cow("Бурёнка")]
for animal in animals:
    print(f"{animal.name}: {animal.speak()}")
# Бобик: Гав!
# Мурка: Мяу!
# Бурёнка: Муу!
```

Напишите функцию `animal_chorus(animals: list) -> str`, которая возвращает строку со всеми звуками через пробел.

---

## Домашняя работа

### Задание 1. Шахматные фигуры (наследование, абстракция, полиморфизм)

Создайте базовый класс `ChessPiece`:
- Атрибуты: `color` (белый/чёрный), `position` (кортеж из двух чисел 0-7)
- Метод `change_color()` — меняет цвет на противоположный
- Метод `set_position(x, y)` — устанавливает позицию (с проверкой границ 0-7)
- Защищённый метод `_is_valid_position(x, y)` — проверяет, что координаты в пределах доски
- Абстрактный метод `can_move_to(x, y)` — проверяет, может ли фигура пойти на указанную клетку

Создайте классы-наследники для каждой фигуры:
- `Pawn` (пешка) — ходит на 1 клетку вперёд (направление зависит от цвета)
- `Rook` (ладья) — ходит по горизонтали или вертикали
- `Knight` (конь) — ходит буквой «Г»
- `Bishop` (слон) — ходит по диагонали
- `Queen` (ферзь) — ходит как ладья + слон
- `King` (король) — ходит на 1 клетку в любом направлении

```python
# Пример использования:
rook = Rook("white", (0, 0))
print(rook.can_move_to(0, 5))  # True (по вертикали)
print(rook.can_move_to(3, 3))  # False (по диагонали нельзя)

knight = Knight("black", (1, 0))
print(knight.can_move_to(2, 2))  # True (буква «Г»)
```

Напишите функцию `pieces_that_can_reach(pieces: list, x: int, y: int) -> list`, которая возвращает список фигур, способных достичь указанной клетки за один ход.

### Задание 2. Student и Group (подготовка к следующему занятию)

Создайте класс `Student`:
- Атрибуты: `name`, `age`, `grades` (список оценок)
- Метод `add_grade(grade)` — добавляет оценку
- Метод `average_grade()` — возвращает средний балл

Создайте класс `Group`:
- Атрибуты: `name` (название группы), `students` (список студентов)
- Метод `add_student(student)` — добавляет студента
- Метод `remove_student(name)` — удаляет студента по имени

**Эти классы понадобятся на следующем занятии для изучения магических методов!**

### Задание 3. Миксин для логирования

Создайте миксин `LoggableMixin`, который добавляет возможность логирования:
- Метод `log(message)` — печатает сообщение с именем класса и временем

```python
from datetime import datetime

class LoggableMixin:
    def log(self, message: str):
        class_name = self.__class__.__name__
        time = datetime.now().strftime("%H:%M:%S")
        print(f"[{time}] {class_name}: {message}")
```

Создайте класс `Order`, который наследуется от `LoggableMixin`:
- Атрибуты: `order_id`, `items` (список товаров), `status`
- Метод `add_item(item)` — добавляет товар и логирует это
- Метод `set_status(status)` — меняет статус и логирует

```python
# Пример использования:
order = Order(order_id=123)
order.add_item("Laptop")
# [14:30:15] Order: Added item: Laptop
order.set_status("shipped")
# [14:30:16] Order: Status changed to: shipped
```

### Задание 4. Собственные исключения

Создайте иерархию исключений для системы валидации:

```python
class ValidationError(Exception):
    """Базовое исключение валидации"""
    pass

class EmptyValueError(ValidationError):
    """Значение пустое"""
    pass

class InvalidRangeError(ValidationError):
    """Значение вне допустимого диапазона"""
    pass
```

Создайте класс `User`:
- Атрибуты: `username`, `age`, `email`
- В `__init__` валидируйте данные:
  - `username` не должен быть пустым → `EmptyValueError`
  - `age` должен быть от 0 до 150 → `InvalidRangeError`
  - `email` должен содержать `@` → `ValidationError`

```python
# Пример использования:
try:
    user = User("", 25, "test@mail.com")
except EmptyValueError as e:
    print(f"Ошибка: {e}")  # Ошибка: username cannot be empty

try:
    user = User("john", 200, "test@mail.com")
except InvalidRangeError as e:
    print(f"Ошибка: {e}")  # Ошибка: age must be between 0 and 150
```

### Задание 5. ⭐ Банковская система (комплексное)

Создайте систему банковских счетов:

**Исключения:**
- `BankError` — базовое исключение
- `InsufficientFundsError` — недостаточно средств
- `InvalidAmountError` — некорректная сумма (отрицательная или ноль)

**Базовый класс `Account`:**
- Атрибуты: `account_number`, `owner_name`, `_balance` (защищённый)
- Метод `deposit(amount)` — пополнение (с валидацией суммы)
- Метод `withdraw(amount)` — снятие (с проверкой баланса)
- Метод `get_balance()` — возвращает баланс
- Метод `transfer(other_account, amount)` — перевод на другой счёт

**Класс `SavingsAccount(Account)`:**
- Дополнительный атрибут `interest_rate` (процентная ставка)
- Метод `add_interest()` — начисляет проценты на баланс
- Переопределите `withdraw()` — нельзя снять больше 50% баланса за раз

**Класс `CheckingAccount(Account)`:**
- Дополнительный атрибут `overdraft_limit` (лимит овердрафта)
- Переопределите `withdraw()` — можно уходить в минус до лимита овердрафта

```python
# Пример использования:
savings = SavingsAccount("001", "Alice", interest_rate=0.05)
savings.deposit(1000)
savings.add_interest()
print(savings.get_balance())  # 1050.0

checking = CheckingAccount("002", "Bob", overdraft_limit=500)
checking.deposit(100)
checking.withdraw(400)  # OK, баланс = -300 (в пределах овердрафта)
print(checking.get_balance())  # -300

try:
    checking.withdraw(300)  # Превысит лимит овердрафта
except InsufficientFundsError as e:
    print(e)
```

---

[← Лекция 8: Git. Удаленный репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.](lesson08.md) | [Лекция 10: Magic methods. Итераторы и генераторы. →](lesson10.md)