# Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты.

### Оглавление курса

- Блок 1 — Python Basic (1–6):
  - [Лекция 1. Введение. Типизации. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.](lesson02.md)
  - [Лекция 3: None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter.](lesson05.md)
  - [Лекция 6. Рекурсия. Алгоритмы. Бинарный поиск, сортировки](lesson06.md)
- Блок 2 — Git (7–8):
  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md)
  - [Лекция 8. Git. Удаленный репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.](lesson08.md)
- Блок 3 — Python Advanced (9–14):
  - ▶ **Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты.**
  - [Лекция 10. Множественное наследование. MRO. Magic methods.](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - [Лекция 14. Проектирование. Паттерны. SOLID.](lesson14.md)
- Блок 4 — SQL (15–17):
  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи.](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. Group by. Joins.](lesson16.md)
  - [Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup](lesson17.md)
- Вне блоков:
  - [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv.](lesson18.md)
- Блок 5 — Django (19–26):
  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy.](lesson21.md)
  - [Лекция 22. Django ORM.](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication.](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
- Блок 6 — Django Rest Framework (27–30):
  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework.](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST аутентификация. Авторизация. Permissions. Фильтрация.](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API.](lesson30.md)
- Блок 7 — Python async (31–33):
  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Асинхронное программирование в Python. Корутины. Asyncio.](lesson32.md)
  - [Лекция 33. Сокеты. Django channels.](lesson33.md)
- Блок 8 — Deployment (34–35):
  - [Лекция 34. Linux. Все что нужно знать для деплоймента.](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
- Вне блоков:
  - [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


![](https://i.pinimg.com/originals/81/a4/77/81a477d2cb7daf3443c8438ec897db1f.png)

## Что такое ООП, и что же такое класс и объект.

Объектно-ориентированное программирование (в дальнейшем - ООП) — парадигма программирования, в которой основными
концепциями являются понятия объектов и классов. Взаимодействие между операциями при помощи объектов.

Если говорить человеческим языком, то в обычной жизни мы не оперируем понятиями строка или кортеж, мы оперируем
объектами.

Мы говорим: "Подай чашку", "Пришли фотку", "Прикольный стол" и т. д. Так вот чашка, фотка и стол в этих примерах будут
являться объектами. Объекты могут обладать некоторыми атрибутами (цвет, название, размер и т. д.) и методами (они же
действия, например, на кнопку можно нажать, автомобиль может ехать, карандаш может писать и т. д.)

![](https://static.tildacdn.com/tild6133-3934-4363-a236-636439333831/Smartiqa_Python_Obje.png)

В центре ООП находится понятие `объекта`.

Объекты создаются на основе `классов`.

Класс - это шаблон для создания объекта. Допустим, у нас есть класс автомобиль, автомобиль - это класс, а конкретный
Lexus, синего цвета и 2015 года выпуска - это уже объект класса автомобиль.

Объект — это сущность, экземпляр класса, содержащий свои атрибуты и свои методы, созданный при помощи шаблона (т. е.
класса).

Атрибут класса — это данные, принадлежащие самому классу (общие для всех экземпляров, пока не переопределены в экземпляре).
Атрибут экземпляра хранится в самом объекте и может отличаться от значения в классе.

Метод — это функция, определённая внутри класса. Обычно её вызывают у экземпляра (объекта), чтобы выполнить действие.
Например: кофемашина делает кофе.

![](https://skillbox.ru/upload/setka_images/10060020022023_ee673444daa2c4c150863fb4fe2e59385df85324.png)

### Ключевое слово `self`

Что такое `self`? `self` - это специальный аргумент в методах класса, который является ссылкой на экземпляр.

В большинстве случаев (когда нет, обсудим отдельно на следующих занятиях), первым аргументом любого метода будет `self`.
Он обязательный. Чисто технически можно написать любое слово первым аргументом, и это тоже будет работать. Но не надо
так делать. Не сбивайте ни себя, ни других разработчиков. Первый аргумент большинства методов это `self`.

`self` - это конкретный объект внутри метода класса.

Если у нас есть класс студент, то через `self` мы можем получить доступ ко всем атрибутам и методам конкретного
студента, например, списку оценок или методу "прогулять занятие".

Доступ к атрибутам и методам предоставляется через точку.

Еще про `self`:

- Метод определяется в классе, а вызывается, как правило, у экземпляра: cat.murchalo().
- Внутри метода первый параметр — это `self`: ссылка на тот экземпляр, для которого вызван метод.
- Технически тот же код можно вызвать через класс, но тогда экземпляр нужно передать явно: Cat.murchalo(cat).
- Важно: вызов метода у конкретного объекта не «запускает» его для всех — работает только с тем экземпляром, который передан как `self`.

Вот [тут](https://stackoverflow.com/questions/2709821/what-is-the-purpose-of-the-self-parameter-why-is-it-needed) хорошо
на английском написано.

Наконец, к коду:

```python
# Используем ключевое слово `class`
class Car:
   # Опишем класс Машина, у которого будет два атрибута: цвет и максимальная скорость.
   # Я указал для них типы данных, но для Python это не обязательно, скорее, удобный инструмент.
   # И я указал значения по умолчанию при помощи =. Но это тоже не обязательно, можно было не указывать
   # Обратите внимание: названия классов пишутся с большой буквы и без дополнительных символов вроде _
   color: str = 'red'
   top_speed: int = 250

   # И несколько методов.

   # Вернуть строку с максимальной скоростью и цветом
   def find_color_and_top_speed(self) -> str:
      return f"This car's top speed is {self.top_speed} and color is {self.color}"

   # Вернуть булево значение, которое отвечает на вопрос, может ли машина ехать с указанной скоростью
   def is_car_can_go_with_needed_speed(self, speed: int) -> bool:
      return speed < self.top_speed

   # Назначить максимальную скорость
   def set_top_speed(self, speed: int) -> None:
      self.top_speed = speed

   # Назначить количество колес. Обратите внимания,
   # такого атрибута изначально вообще не было
   # (лучше так не делать, но технически нет никаких ограничений)
   def set_count_of_wheels(self, wheels: int) -> None:
      self.wheels = wheels


# Как создать объект? Для этого нужно просто "вызвать" класс

lamborghini = Car()
print(lamborghini.find_color_and_top_speed())  # This car's top speed is 250 and color is red
# Когда мы вызываем метод у объекта lamborghini, сам объект lamborghini передается в качестве аргумента self!!
print(lamborghini.is_car_can_go_with_needed_speed(200))  # True
# Доступ к атрибутам можно получить напрямую
print(lamborghini.top_speed)  # 250
lamborghini.set_top_speed(150)  # Назначаем новую максимальную скорость для этого объекта
print(lamborghini.is_car_can_go_with_needed_speed(200))  # False
cherry = Car()
print(cherry.find_color_and_top_speed())  # This car's top speed is 250 and color is red
# Когда мы вызываем метод у объекта cherry, сам объект cherry передается в качестве аргумента self!!
cherry.top_speed = 140
cherry.color = 'yellow'
print(cherry.wheels)  # ВЫЗОВЕТ ОШИБКУ, у нас нет такого атрибута
cherry.set_count_of_wheels(4)
print(cherry.wheels)  # Все ок, напечатает 4
cherry.size = 'small'  # Можно добавлять атрибуты к любому объекту если это необходимо, у ламборгини такого атрибута не будет, но делать так тоже обычно не стоит
```

## Объекты

**В python вообще все является объектом**

И строка, и число, и список и т. д.

И функция, и метод...

И None, и сами типы данных...

И вообще все к чему вы сможете дотянуться. Эта информация понадобится нам в дальнейшем.

## Парадигмы ООП

![](https://img1.joyreactor.cc/pics/post/%D0%BA%D0%BE%D0%BB%D0%B0-%D0%9E%D0%9E%D0%9F-geek-2269253.jpeg)

ООП держится на трёх основных и одной второстепенной парадигме.

### Наследование

![](https://studfile.net/html/71636/410/html_jr0To65ZHB.44IR/htmlconvd-QCA4hj_html_fadf8074562f39b7.png)

`Наследование` — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или
полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или
родительским. Новый класс — потомком, наследником или производным классом.

Например, у нас есть базовый класс автомобиль и три наследника, легковой, самосвал и фура. Все три класса могут иметь
общие атрибуты, например, двигатель или материал лобового стекла, или методы, например, газ и тормоз, но при этом иметь
свои особенные атрибуты или методы, например, только у фуры будет больше 4 колес, у самосвала будет метод
поднять кузов, или у фуры - отцепить груз.

При описании ООП мне очень нравятся бытовые примеры на автомобилях. Представьте, что при разработке новой модели BMW,
конструкторы решили бы начисто забыть о том, что у них уже были предыдущие модели. Тогда им пришлось бы абсолютно
каждую новую модель разрабатывать с нуля. Возможно ли это? Конечно. Есть ли в этом необходимость? Очень сомнительно.
Если можно взять прошлую модель, немного изменить дизайн, поменять систему тормозов и вставить новые фары, и вуаля,
новая модель готова при минимальных затратах и максимальном результате. С наследованием точно также, можно описывать все
классы с нуля, но часто это очень неудобно и затратно.

#### Пример кода

```python
class Car:
    wheels = 4
    doors = 4
    current_speed = 0
    max_speed = 200

    def go(self):
        self.current_speed = self.max_speed / 2

    def stop(self):
        self.current_speed = 0


# тут класс унаследовал атрибуты wheels и current_speed, а также все методы
class Truck(Car):
    doors = 2
    max_speed = 120


# а тут класс унаследовал все атрибуты кроме max_speed, а также все методы
class SportCar(Car):
    max_speed = 350


truck = Truck()
sport = SportCar()

truck.go()
sport.go()
print(truck.current_speed)  # 60
print(sport.current_speed)  # 175
```

### Метод `super()`

Практически всегда, когда нам нужно в дочернем классе выполнить такое же действие, как и в родительском, нам необходимо
основываться на данных из родительского (в конце блока вы узнаете, что это даже целое правило).

Но как вызвать код из другого класса? Нам поможет метод `super()`.

Допустим, у нас есть класс, который занимается тем, что просто возвращает нам цену продукта.
И еще два класса, которые вычисляют скидку 10%. И второй класс отнимает еще 20% уже от уменьшенной цены.

```python
class PriceCounter:
    price = 100

    def calculate_price(self):
        print('In PriceCounter calculate price:')
        return self.price


class DiscountCounter(PriceCounter):

    def calculate_price(self):
        print('In DiscountCounter calculate price: ')
        return super().calculate_price() * 0.9


class SuperDiscountCounter(DiscountCounter):

    def calculate_price(self):
        print('In SuperDiscountCounter calculate price: ')
        return super().calculate_price() * 0.8


price_counter = PriceCounter()
discount_counter = DiscountCounter()
super_discount_counter = SuperDiscountCounter()

print(price_counter.calculate_price())
"""
In PriceCounter calculate price:
100
"""
print(discount_counter.calculate_price())
"""
In DiscountCounter calculate price:
In PriceCounter calculate price:
90.0
"""
print(super_discount_counter.calculate_price())
"""
In SuperDiscountCounter calculate price:
In DiscountCounter calculate price:
In PriceCounter calculate price:
72.0
"""
```

#### Устаревшие синтаксисы

Для Python существуют несколько различных версий, включая 2.х и 3.х.

Версии 2.х считаются устаревшими, но все-таки иногда можно встретить код на Python 2.x или "отнаследовавшийся от
него".
В Python 3 все классы — «new‑style», поэтому явно наследоваться от `object` не требуется; оба варианта ниже корректны.


```python
class A():  # Лишние скобки — не ошибка, но стиль спорный; в Python 3 это обычный класс
    pass


class B(object):
    """
    Вариант, который тоже будет работать
    и на самом деле показывает нам суть любого класса и объекта в Python,
    вообще все унаследовано от объекта.
    """


class C:  # Традиционный способ для объявления класса в python3
    pass
```

Заодно познакомились с ключевым словом `pass`, которое нужно в качестве `заглушки`, так как класс или функция не могут
быть пустыми, но могут быть с такой заглушкой. Вместо заглушки лучше все-таки ставить комментарий, если есть
необходимость создать пустой класс (а она вполне бывает).

### Методы `type()`, `isinstance()` и `issubclass()`

У любого объекта всегда есть тип данных. И по факту этим типом данных всегда является класс (да, `str`, `int`, `list`
и т. д. и даже функции - это тоже классы)

Чтобы узнать тип данных любого объекта, необходимо вызвать метод `type()`.

```python
class A:
    pass


a = A()
num = 10
text = 'test_str'
collection = [1, 2, 3]


def some_func():
    pass


print(type(a))  # <class '__main__.A'>
print(type(num))  # <class 'int'>
print(type(text))  # <class 'str'>
print(type(collection))  # <class 'list'>
print(type(some_func))  # <class 'function'>
```

Для того чтобы сравнить и узнать, является ли объект подклассом, существует специальная функция `isinstance()`. Она
принимает на вход объект и класс, либо кортеж из классов, а возвращает булево значение.

И есть такая же функция, которая принимает не объект, а сам класс: `issubclass()`.

```python
class A:
    pass


class B(A):
    pass


class C(B):
    pass


a = A()
b = B()
c = C()

print(isinstance(a, A))  # True
print(isinstance(a, B))  # False
print(isinstance(b, A))  # True
print(isinstance(c, (A, C)))  # True
print(issubclass(type(a), A))  # True
print(issubclass(B, A))  # True
print(issubclass(A, C))  # False
print(issubclass(type(a), (B, C)))  # False
```

### Абстракция

![](https://static.tildacdn.com/tild3939-6466-4061-a132-656632333864/Smartiqa_OOP_Abstrac.png)

Абстракция в объектно-ориентированном программировании — это использование только тех характеристик объекта, которые с
достаточной точностью представляют его в данной системе.

Часто говорят, что абстракция - это не обязательная парадигма ООП.

Вернемся к примерам с автомобилями. Когда мы управляем автомобилем, мы часто используем руль и поворотники, но часто ли
мы меняем настройку зеркал или подогрева сидений? Не особо. Так вот абстракция о том, чтобы выделять главное и не
тратить лишние ресурсы на второстепенное.

Если говорить простыми словами, то это возможность описать реализацию метода только в том классе, где это необходимо. А
в родительском только описать название и, возможно, какие-то комментарии к будущей реализации.

```python
class Animal:

    def sound(self):
        raise NotImplementedError  # Вызвать ошибку, как это работает, рассмотрим через несколько занятий.


class Mouse(Animal):

    def sound(self):
        return 'pee pee'


class Lion(Animal):

    def sound(self):
        return 'roar'

```

Если в этом примере не описать метод `sound()`, то технически все будет работать, но любая IDE будет подсвечивать, что
вы не описали абстрактный метод.

### Полиморфизм

![](https://cdn.javarush.com/images/article/5d67355f-5702-4ba8-b1c2-5eb3f27fa5b5/800.jpeg)

Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
структуре объекта, т. е. способность одной функции (метода), действовать по-разному в зависимости от обстоятельств
(которые мы сами указываем).

По сути, это возможность использовать одни и те же методы или интерфейсы к различным структурам, например, обычный
знак `+`, ведь мы можем сложить числа, а можем и строки, и получим разный результат, но применим один и тот же метод.

```python
"1" + "1" # "11"
1 + 1 #2
# А ведь это один и тот же плюс
```

В примере с автомобилем, если мы умеем водить мерседес, то скорее всего у нас не вызовет проблем управлять тойотой или
фордом. Ведь для управления мы будем использовать точно те же самые интерфейсы (руль, педали, поворотники и т. д.)

```python
class English:

    def greeting(self):
        print("Hello")


class French:

    def greeting(self):
        print("Bonjour")


def intro(language):
    language.greeting()


flora = English()
michelle = French()

intro(flora)
intro(michelle)
```

Прошлый пример из абстракции тоже подходит, ведь разные звери издают разные звуки. А для нас это не имеет значения, мы
всего лишь вызовем метод `sound()`.

### Инкапсуляция

![](https://cdn.javarush.com/images/article/a3a32228-a349-4de8-b402-16c19fc4db88/1024.jpeg)

`Инкапсуляция` - принцип "убирания с глаз" функционала или данных с предоставлением только входных и выходных
параметров. Например, если в автомобиле повернуть руль налево, то колёса тоже повернутся налево, но как именно это
происходит от нас скрыто, мы не знаем, какие именно рычаги и шестерёнки в этот момент двигаются внутри автомобиля.
Можем ли мы разобрать и посмотреть? Можем, а надо ли оно нам?

Так же, например, с кофемашиной, мы знаем, что если нажать кнопку с капучино, то мы получим чашку кофе. Какие в этот
момент процессы происходят внутри, нас практически не интересует. Что-то нагревается, где-то по трубкам бежит жидкость.
Но нас интересует только результат. Могу ли я разобрать кофемашину и посмотреть, из чего она состоит? Могу, но у меня
нет в этом необходимости.

Так же и в программировании, мы можем "скрыть" внутренние процессы.

![](https://senior.ua/storage/article/651ea79a-83e1-4f4a-9ca4-8968b7ae86f9.jpeg)

В Python инкапсуляция очень условная (всегда можно получить доступ куда угодно, было бы желание). Как сказал создатель
языка, Гвидо Ван Россум: "Мы все же взрослые люди, зачем мы будем кого-то ограничивать?"

В первую очередь код пишется для людей, поэтому и разделение существует на уровне понимания людей.

Существует три вида состояния атрибутов и свойств, и для их разделения используется специальный синтаксис.

1. Без начального подчёркивания (`name`) — условно `public`. Доступны везде (в объекте, классе, наследниках).

2. С одним подчёркиванием (`_name`) — условно `protected`: по соглашению используем внутри класса и его наследников, а не снаружи.

3. С двумя подчёркиваниями (`__name`) — условно `private`: по соглашению используем внутри самого класса;
   снаружи к ним обращаются через переименование имени (name mangling) — `_ИмяКласса__attr`.

#### Пример кода

```python
class Car:
    color = 'red'
    _top_speed = 250
    __max_carrying = 1000

    def find_color_and_top_speed(self):
        return f"This car's top speed is {self._top_speed} and color is {self.color}."

    def can_go_with_needed_speed(self, speed):
        return speed < self._top_speed

    def can_get_weight(self, weight):
        return self.__max_carrying > weight

    def change_max_carrying(self, new_carrying):
        self.__max_carrying = new_carrying

    def __private_method(self):
        print('This is private method')

    def _this_is_protected_method(self):
        print('This is protected method')

    def run_hidden_and_protected_methods(self):
        self.__private_method()
        self._this_is_protected_method()


class Truck(Car):
    def _this_is_protected_method(self):
       super()._this_is_protected_method() # все хорошо

    def __private_method(self):
       super().__private_method() # не заработает

car = Car()
car.color  # всё нормально
car._top_speed  # сработает, но мы же сами описали это свойство так, чтобы сообщить, что не надо так его использовать
car.__max_carrying  # не сработает (будет ошибка, что этот атрибут не найден)
car._Car__max_carrying  # Сработает, и это как раз описание того, что добраться можно куда угодно. Но сам синтаксис нам говорит, что мы что-то не то делаем
car.__max_carrying = 800  # создаст НОВЫЙ атрибут у экземпляра; реальный "приватный" не изменится
car.change_max_carrying(800)  # сработает
car.__private_method()  # не сработает (AttributeError из‑за name mangling)
car._this_is_protected_method()  # сработает, но опять же не надо этого делать
car.run_hidden_and_protected_methods()  # сработает и вызовет защищенный и приватный методы
```

![](https://miro.medium.com/v2/resize:fit:1400/1*4TQU8gAHJAJasc-Lwx2APw.png)

Все тонкости и детали можно познать только на практике! Так что задачи на практику/домашние:

1. Описываем телефон:

   Класс телефон. У него должны быть:
    - Поле для описания номера.
    - Метод, чтобы задать номер телефона.
    - Защищенное поле для счетчика входящих звонков.
    - Метод, который вернет нам количество принятых звонков.
    - Метод принять звонок, который добавляет к счетчику единицу.

   Создайте три разных объекта телефона.

   Поменяйте всем изначальный номер.

   Примите по несколько звонков на каждом (разное количество)

   Напишите функцию, которая принимает список из объектов телефонов, а возвращает общее количество принятых звонков
   со всех телефонов.

2. Опишите класс для шахматной фигуры.

   Фигура должна содержать такие атрибуты:
    - Цвет (белый или черный).
    - Место на доске (тут есть варианты, или два отдельных поля, для описания координат или одно, но, например, кортеж
      из двух чисел).
      И такие методы как:
    - Изменить цвет (ничего не принимает, только меняет цвет на противоположный).
    - Изменить место на доске (принимает или две переменные, или один кортеж из двух элементов), не забудьте проверить,
      что мы не пытаемся поставить фигуру за пределы доски (оба значения от 0 до 7).
    - Абстрактный метод проверки потенциального хода (детали ниже).
      На данном этапе фигуры могут стоять на одной и той же клетке, пока нам это не важно.

   Опишите классы для пешки, коня, офицера, ладьи, ферзя и короля.
   Все, что в них нужно добавить - это один метод для проверки,
   возможно, ли за один ход поменять место фигуры на доске (все ходят по-разному, у пешек будет еще и разница от цвета).
   Метод принимает опять же или две цифры, или один кортеж. И опять же проверяем, не выходит ли значение за пределы
   доски (Так как нам необходим этом функционал дважды, я бы делал его как отдельный защищенный метод в родительском
   классе)

   И функцию, которая принимает список фигур и потенциальную новую клетку, а возвращает список из фигур. Но только тех,
   которые могут за один ход добраться до этой клетки.

3. Создайте класс `Student` с такими полями:
   - Имя
   - Возраст
   - Список оценок

   И класс `Group`:
   - список `Student`
   - название

   **Эти два класса нам понадобятся на следующем занятии**