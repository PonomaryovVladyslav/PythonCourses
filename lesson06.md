# Лекция 6. Рекурсия. Алгоритмы. Бинарный поиск, сортировки

![](https://avatars.mds.yandex.net/get-lpc/1220100/0bd6f82a-a6b6-4b4e-b85f-c6185cbd5a67/orig)

## Зачем нужны алгоритмы

Алгоритмы лежат в основе программирования и помогают решать задачи эффективно по времени и памяти.
Они применяются повсюду: от простой обработки данных до сложных систем.

1. Эффективное решение проблем — быстрее и с меньшими ресурсами.
2. Оптимизация программ — правильный выбор алгоритма ускоряет код.
3. Понимание сложных систем — легче разбираться в устройстве ПО.
4. Универсальность — применимы в анализе данных, ML, играх и многом другом.

## Ассимптотика: Big-O “на ладони”

О большое (Big O notation) — это математическое обозначение, используемое для описания эффективности алгоритма, особенно
его временной и пространственной сложности. Оно позволяет оценить, как изменяется время выполнения или объем
используемой памяти по мере роста размера входных данных.

### Основные виды временной сложности:

- **O(1)** — Постоянное время: Время выполнения не зависит от размера входных данных.
- **O(log n)** — Логарифмическое время: Время выполнения растет логарифмически по мере увеличения входных данных.
- **O(n)** — Линейное время: Время выполнения растет линейно по мере увеличения входных данных.

#### Визуализация роста функций (Big-O)

```text
Рост (условный)
|
|           O(2^n)
|        O(n^2)
|     O(n log n)
|   O(n)
|  O(log n)
| O(1)
+----------------------> n (размер входа)
```

![](https://upload.wikimedia.org/wikipedia/commons/7/7e/Comparison_computational_complexity.svg)

> График выше иллюстрирует, как быстро растёт время/память в зависимости от класса сложности. Он важен для интуиции, но помните: Big‑O — это оценка порядка роста, а не точное время.

- **O(n log n)** — Линейно-логарифмическое время: Время выполнения растет быстрее, чем линейно, но медленнее, чем
  квадратично.
- **O(n^2)** — Квадратичное время: Время выполнения растет квадратично по мере увеличения входных данных.
- **O(2^n)** — Экспоненциальное время: Время выполнения растет экспоненциально по мере увеличения входных данных.


## Рекурсия

Рекурсия - это концепция в программировании, при которой функция вызывает саму себя внутри своего тела. Это мощный
инструмент, который позволяет решать задачи, которые могут быть разбиты на более мелкие подзадачи того же типа. Рекурсия
в Python работает аналогично рекурсии в математике.

### Основные элементы рекурсии

1. **Базовый случай (Base Case)**: Это условие, при котором рекурсия завершается и функция больше не вызывает саму себя.
   Без базового случая рекурсивная функция будет вызывать себя бесконечно.

2. **Рекурсивный случай (Recursive Case)**: Это условие, при котором функция вызывает саму себя для решения более мелкой
   подзадачи. Рекурсивный случай должен быть сформулирован так, чтобы в конечном итоге привести к базовому случаю.

### Пример: Вычисление факториала с использованием рекурсии

Давайте рассмотрим пример рекурсивной функции для вычисления факториала числа. Факториал числа `n` (обозначается
как `n!`) - это произведение всех положительных целых чисел от 1 до `n`.

```python
def factorial(n: int) -> int:
    # Валидация: факториал определён для n >= 0
    if n < 0:
        raise ValueError("n must be >= 0")
    # Базовый случай: 0! и 1! равны 1
    if n < 2:
        return 1
    # Рекурсивный случай
    return n * factorial(n - 1)


# Пример использования
result = factorial(5)
print(result)  # 120
```


> Примечание: в Python глубина рекурсии ограничена (RecursionError при слишком глубокой рекурсии), а оптимизация хвостовой рекурсии не применяется. Для простых задач чаще предпочтительны итеративные решения.

### Преимущества и ограничения рекурсии

Преимущества:

- Рекурсия может сделать код более читаемым и интуитивно понятным, особенно для задач, связанных с древовидными или
  рекурсивными структурами данных.
- Она может предоставить более лаконичное и элегантное решение для некоторых задач.

Ограничения:

- Рекурсия может быть менее эффективной по сравнению с итеративными методами в некоторых случаях из-за накладных
  расходов на вызов функций.
- Слишком глубокая рекурсия может вызвать переполнение стека вызовов (stack overflow), что приведет к ошибке.

При использовании рекурсии важно правильно формулировать базовый и рекурсивный случаи, чтобы функция завершилась и не
вошла в бесконечный цикл.

## Алгоритм бинарного поиска

Для понимания, что такое сложность, давайте рассмотрим один из базовых алгоритмов, бинарный поиск.

Предположим нам нужно угадать какое число загадал пользователь в диапазоне от 1 до 100. И пользователь говорит нам, его
число, больше, меньше или мы угадали.

У нас есть несколько стратегий для решения этой задачи. Первая это решение `в лоб`. Мы просто перебираем все варианты от
1 до 100. Но при этом в худшем случае, мы выполним 100 запросов. А что если диапазон будет до 1000? а до 10000000?
При таком подходе у нас увеличивается кол-во действий которые нужно сделать вместе с кол-вом данных для которых мы это
выполняем. Такие алгоритмы имеют сложность `O(n)`. Увеличение объема данных увеличивает сложность ровно во столько же
раз, как и увеличился объем данных.

А можно ли выполнить этот же поиск за меньшее кол-во действий? Можно! Для этого нам поможет бинарный поиск.

Мы можем разделить весь наш интервал пополам, и начать поиск с 50. Узнать что искомый элемент больше. Ок, тогда мы берем
середину от оставшихся значений (от 50 до 100) и проверяем 75. И делаем так до тех пор не найдем искомое значение.

Такие алгоритмы имеют сложность `O(log n)`. Для диапазона от 1 до 100, нам понадобится в худшем случае (log 100 ==
6,644) 7 попыток.
Лучше чем 100, правда? А для диапазона от 1 до 1000 (log 1000 == 9,966) всего 10 попыток! мы увеличили входные данные в
10 раз, а сложность вычисления увеличилась всего в полтора раза!

Для очень большого количества задач уже существуют оптимальные алгоритмы; если их знать и уметь использовать, ваш код будет
гораздо эффективнее.

Давайте посмотрим, как это можно реализовать.

Бинарный поиск — это алгоритм для поиска элемента в отсортированном списке. Он работает по принципу "разделяй и
властвуй", разделяя массив на половины до тех пор, пока не найдет искомый элемент.

### Принцип работы:

1. Найдите средний элемент списка.
2. Если средний элемент равен искомому, верните его индекс.
3. Если искомый элемент меньше среднего, повторите поиск для левой половины списка.
4. Если искомый элемент больше среднего, повторите поиск для правой половины списка.
5. Продолжайте до тех пор, пока не найдете элемент или не исчерпаете список.

### Пример:

```python
def binary_search(arr: list[int], target: int) -> int:
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1  # Элемент не найден


# Пример использования
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
target = 7
print(f"Элемент найден на индексе: {binary_search(arr, target)}")
```

Или пример через рекурсию:

```python
def binary_search_recursive(arr: list[int], target: int, left: int, right: int) -> int:
    if left > right:
        return -1  # Элемент не найден

    mid = (left + right) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)


# Пример использования
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
target = 7
result = binary_search_recursive(arr, target, 0, len(arr) - 1)

print(f"Элемент найден на индексе: {result}")
```

#### Примечание: модуль bisect

Иногда удобнее не реализовывать бинарный поиск вручную, а использовать стандартный модуль bisect.
Он помогает быстро находить позицию вставки элемента в отсортированный список.

```python
from bisect import bisect_left, bisect_right

arr = [1, 3, 3, 5]
i = bisect_left(arr, 3)   # 1 — индекс первого вхождения 3
j = bisect_right(arr, 3)  # 3 — индекс после последнего вхождения 3
# Вставка с сохранением порядка:
arr.insert(i, 3)
```

> Важно: бинарный поиск корректен, только если массив уже отсортирован.


## Алгоритмы сортировки

Огромным пластом алгоритмов являются алгоритмы сортировки. Давайте посмотрим на некоторые из них.

### Пузырьковая сортировка (Bubble Sort)

Пузырьковая сортировка — это простой алгоритм сортировки, который многократно проходит по списку, сравнивает соседние
элементы и меняет их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока
список не будет отсортирован.

![](https://media.proglib.io/wp-uploads/-000//1/596b722779f8b_Yb6G53y.gif)

### Принцип работы:

1. Сравнивайте каждый элемент списка с его соседним.
2. Меняйте их местами, если они в неправильном порядке.
3. Повторяйте процесс до тех пор, пока не будет произведен проход по списку без единой перестановки.

### Пример на Python:

```python
def bubble_sort(arr: list[int]) -> list[int]:
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr


# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
print(f"Отсортированный массив: {bubble_sort(arr)}")
```

### Сортировка слиянием (Merge Sort)

Сортировка слиянием — это эффективный алгоритм сортировки, который использует принцип "разделяй и властвуй". Он
рекурсивно делит массив пополам, сортирует каждую половину и затем объединяет их.

![](https://media.proglib.io/wp-uploads/-000//1/596b722dc99d1_3qHz285.gif)

### Принцип работы:

1. Разделите массив на две половины.
2. Рекурсивно отсортируйте каждую половину.
3. Объедините две отсортированные половины в один отсортированный массив.

### Пример на Python:

```python
def merge_sort(arr: list[int]) -> list[int]:
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])

    return merge(left_half, right_half)


def merge(left: list[int], right: list[int]) -> list[int]:
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result


# Пример использования
arr = [38, 27, 43, 3, 9, 82, 10]
print(f"Отсортированный массив: {merge_sort(arr)}")
```

### Быстрая сортировка (Quick Sort)

Быстрая сортировка — это еще один эффективный алгоритм сортировки, который использует принцип "разделяй и властвуй". Он
выбирает опорный элемент (пивот) и разделяет массив на две части: элементы, меньшие пивота, и элементы, большие пивота.
Затем рекурсивно сортирует каждую часть.

![](https://media.proglib.io/wp-uploads/-000//1/596b722a05151_A0eQUHL.gif)

### Принцип работы:

1. Выберите опорный элемент (пивот).
2. Переставьте элементы массива так, чтобы элементы, меньшие пивота, были слева от него, а элементы, большие пивота,
   были справа.
3. Рекурсивно примените те же шаги к подмассивам слева и справа от пивота.

### Пример на Python:



```python
def quick_sort(arr: list[int]) -> list[int]:
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)


# Пример использования
arr = [3, 6, 8, 10, 1, 2, 1]
print(f"Отсортированный массив: {quick_sort(arr)}")
```


### Встроенная сортировка Python (Timsort)

Встроенные функции `sorted()` и метод `list.sort()` используют алгоритм Timsort — стабильную сортировку со средней
сложностью O(n log n), очень эффективную на «почти отсортированных» данных.

- `sorted(iterable, key=..., reverse=...)` — возвращает новый список
- `list.sort(key=..., reverse=...)` — сортирует список на месте (in-place), возвращает `None`

```python
students = [
    {"name": "Alice", "age": 20, "grade": 5},
    {"name": "Bob",   "age": 22, "grade": 5},
    {"name": "Eve",   "age": 19, "grade": 4},
]
# Стабильная сортировка по нескольким ключам: сначала по grade (возр.), затем по age (убыв.)
students.sort(key=lambda s: (s["grade"], -s["age"]))
# Или: sorted(students, key=..., reverse=...) — когда нужен новый список
```

> Примечание: «стабильная» означает, что относительный порядок равных по ключу элементов сохраняется.

## Заключение

Изучение алгоритмов и их эффективная реализация является ключевой частью программирования. Понимание различных
алгоритмов сортировки и поиска, таких как бинарный поиск, пузырьковая сортировка, сортировка слиянием и быстрая
сортировка, поможет вам писать более эффективный и оптимизированный код. Экспериментируйте с этими алгоритмами, чтобы
лучше понять их работу и области применения.

Знать эту тему важно, чтобы понимать, является ли ваш код эффективным, уметь оценить сложность собственного
кода, и не придумывать велосипед, когда ваша задача попадает под стандартные алгоритмы.

Рекомендую хотя бы поверхностно ознакомиться с алгоритмами поиска пути, динамического программирования, подходом «двойных указателей» и т. д.

> Нельзя закончить изучать алгоритмы, можно только перестать

На этом мы заканчиваем изучение базовых знаний по Python.

## Практика

1. Реализуйте бинарный поиск (итеративно). Продумайте поведение при дубликатах: какой индекс возвращать?
2. Перепишите бинарный поиск рекурсивно и сравните читаемость и сложность.
3. Используя bisect_left, вставьте элемент в отсортированный список, сохраняя порядок.
4. Реализуйте функцию fib(n) итеративно. Оцените сложность и сравните время для n=30–40 с наивной рекурсией.
5. Реализуйте merge_sort и кратко опишите временную и пространственную сложность.
6. Отсортируйте список словарей студентов по (grade возр., age убыв.) с помощью key=lambda s: (s['grade'], -s['age']).
7. Мини‑вопросы по Big‑O: укажите порядок роста для: a) двойного вложенного цикла; b) бинарного поиска; c) сортировки слиянием.


Переходим к [первому модульному заданию](module1.md)


