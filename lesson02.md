# Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.

![](https://cdn.buttercms.com/LUta2G5oQ0iKH4DLd6jm)

Что такое исключение?

Исключения — это события, которые нарушают нормальный поток выполнения программы. Они возникают, когда программа
сталкивается с ошибкой, которую она не может обработать в обычном режиме. Например, попытка деления на ноль или
преобразование строки к числу когда она не является числом могут вызвать исключения.

Если говорить доступным языком, то исключения это попытка выполнить то, что у языка выполнить не получится.

Иерархия исключений выглядит вот так:

![](https://w3.cs.jmu.edu/lam2mo/cs240_2014_08/images/exception_hierarchy.png)

Это очень примерная картинка, актуальный список всех исключений всегда можно посмотреть
вот [тут](https://docs.python.org/3/library/exceptions.html#exception-hierarchy) выбрав актуальную для вас версию
python.

Начнем со знакомства с самыми обычными исключениями, которые вы увидите в Python. Обратите внимание на то, что ошибка и
исключение – два разных слова, описывающих одно и то же в контексте обработки исключений.

## Основные исключения на данном этапе

Их прям много, детально разберем с чем мы можем столкнуться на данном этапе

`Exception` – то, на чем фактически строятся все остальные ошибки;

`KeyboardInterrupt` – возникает, когда пользователь нажимает клавишу прерывания (обычно `Delete` или `Ctrl+C`);

`NameError` – возникает, когда локальное или глобальное имя не найдено;

`SyntaxError` — возникает, когда синтаксическая ошибка встречается синтаксическим анализатором;

`TypeError` – возникает, когда операция или функция применяется к объекту несоответствующего типа. Связанное значение
представляет собой строку, в которой приводятся подробные сведения о несоответствии типов;

`ValueError` – возникает, когда встроенная операция или функция получают аргумент, тип которого правильный, но
неправильно значение, и ситуация не может быть описана более точно, как при возникновении `IndexError` (Дальше опишу это
человекочитаемым языком, не пугаемся);

`ZeroDivisionError` – возникает, когда второй аргумент операции division или modulo равен нулю;

По мере изучения разных аспектов и типов данных мы будем разбирать и какие исключения могут с ними произойти

## В каких случаях мы уже можем столкнуться с этими исключениями?

### NameError

Эта ошибка возникает когда вы пытаетесь обратиться к переменной которой не существует.

```python
some_variable = 123
print(variable_doesnt_exist)
```

Вы увидите ошибку:

```shell
NameError: name 'variable_doesnt_exist' is not defined
```

Эта ошибка явно означает, что вам надо проверить имена своих переменных и скорее всего вы или где-то опечатались, или
просто явно совершили ошибку.

### SyntaxError

Эта ошибка возможна в любом случае, когда вы пытаетесь набрать что-либо, что не допустимо в python-е и он вас просто не
понимает, не знает что именно ему делать.

```python
5 +
*5
```

Или например:

```python
if:
    print('aaa')
```

Вариантов очень много, любые синтаксические ошибки будут вызывать это исключение. (Кстати, из-за чего ошибка в последнем
примере?)

Исключение:

```
SyntaxError: invalid syntax
```

Это исключение всегда обозначает, что вы где-то не то напечатали, внимательно посмотрите на то место о котором пытается
сообщить вам python и постарайтесь исправить ошибку.

### TypeError

Происходит в случае когда вы пытаетесь произвести не допустимые действия с объектами разного типа, например, сложить
строку и число

```python
"a" + 5
```

Исключение:

```shell
TypeError: can only concatenate str (not "int") to str
```

### ValueError

Это исключение пока что вы будете видеть только в случае когда пытаетесь преобразовать что-то что невозможно
преобразовать. На самом деле это исключение случается гораздо чаще, что вы и увидите при дальнейшем изучении

```python
int("abc")
```

Исключение:

```shell
ValueError: invalid literal for int() with base 10: 'abc'
```

### ZeroDivisionError

Все очень просто, появляется при попытке делить на 0

```python
1 / 0
```

Исключение:

```shell
ZeroDivisionError: division by zero
```

## Как обрабатывать исключения? Можно ли что-то с этим сделать?

Обработка исключений в Python – это очень просто. Потратим немного времени и напишем несколько примеров, которые их
вызовут. Мы начнем с одной из самых элементарных проблем: деление на ноль.

```python
1 / 0
```

За обработку исключений в python отвечают ключевые слова **try**/**except**.

```python
try:
    1 / 0
except ZeroDivisionError:
    print("You cannot divide by zero!")

```

Если мы обратимся к урокам элементарной математики, то вспомним, что на ноль делить нельзя. В Python данная операция
вызовет ошибку, как мы можем видеть в примере выше. Чтобы поймать ошибку, мы завернем операцию в оператор try/except.

В блоке **try** должен выполняться код в котором мы ожидаем какое-либо исключение. И если исключение происходит, то код
перестает выполняться, и переходит к блоку/блокам **except**, и пытается понять произошло ли то исключение, которое
описано в блоке **except**

Блоков **except** может быть любое количество, так же в одном блоке **except** может быть больше одного исключения, если
вам для разных ошибок нужны одинаковые действия, такие исключения должны быть указаны в скобках и через запятую.
Рассмотрим такой пример:

```python
bottles_of_beer = 10
try:
    amount_of_people = int(input("Please input amount of people:"))
    bottle_per_person = bottles_of_beer / amount_of_people
    print(bottle_per_person)
except (ValueError, ZeroDivisionError):
    print('Incorrect amount of people!')
```

В этом случае когда мы введем не число, или введем 0, программа продолжит работу, потому что мы обработали исключение и
описали что код должен сделать

Или вот такой:

```python
bottles_of_beer = 10
try:
    amount_of_people = int(input("Please input amount of people:"))
    bottle_per_person = bottles_of_beer / amount_of_people
    print(bottle_per_person)
except ValueError:
    print('Your input is not a number')
except ZeroDivisionError:
    print('You are trying divide to zero')
```

Как и тут, мы тоже все обработали

Комбинировать можно любое количество исключений.

А что произойдет если сделать вот так?

```python
try:
    bottles_of_beer = 10
    amount_of_people = int(input("Please input amount of people:"))
    bottle_per_person = bottles_of_beer / bottles_of_beer
    print(bottle_per_person)
except SyntaxError:
    print('Your input is not a number')
```

Произойдет следующее, если мы не введем буквы или 0, то ничего страшного, ведь исключение не произошло. А если ввели, то
python попытается обработать исключение, но не найдет подходящий эксепшен, и просто завершит программу с ошибкой, как
будто исключение и не было обработано

### «Голое» исключение

Есть еще один способ поймать ошибку:

```python
try:
    1 / 0
except:
    print("You cannot divide by zero!")
# ЭТО СРАБОТАЕТ, НО ТАК ДЕЛАТЬ НЕЛЬЗЯ
```

На жаргоне Python это известно как "голое исключение", что означает, что будут найдены вообще все исключения. Причина,
по которой так делать не рекомендуется, заключается в том, что вы не узнаете, что именно за исключение вы выловите.
Когда у вас возникло что-то в духе `ZeroDivisionError`, вы хотите выявить фрагмент, в котором происходит деление на
ноль. В написанном выше коде вы не можете указать, что именно вам нужно выявить. Хорошие программисты четко указывают
какую ошибку, ожидают, и что с ней делать

## Оператор finally

Оператор `finally` очень прост в использовании. Давайте взглянем на нижеизложенный пример:

```python

try:
    value = int("ABC")
except ValueError:
    print("A ValueError occurred!")
finally:
    print("The finally statement has executed!")
```

Что произойдет? Часть `finally` выполниться вообще всегда, хоть попали в исключение хоть нет.

## Оператор else

Оператор `try/except` также имеет блок `else`. Он работает только в том случае, если в вашем коде нет ни единой ошибки.
Давайте потратим немного времени и взглянем на парочку примеров:

```python

try:
    value = int(input("Please enter value"))
except ValueError:
    print("A ValueError occurred!")
else:
    print("No error occurred!")
```

В этом примере, если мы введем число, то исключения не случится, и это именно тот случай когда мы попадем в `else`.

## Вся конструкция целиком try-except-else-finally:

Целиком вся конструкция состоит из 4 блоков

```python

try:
    value = int(input("Please enter value"))
except ValueError:
    print("A ValueError occurred!")
else:
    print("No error occurred!")
finally:
    print("The finally statement ran!")
```

В данном коде работают и оператор `else`, и `finally` если введете число или `except` и `finally` если букву. Большую
часть времени вы не будете сталкиваться с оператором `else`, используемым в том или ином коде, который следует за
оператором `try/except`, если ни одна ошибка не была найдена. Единственное полезное применение оператора `else`, которое
я видел, — это когда вы хотите запустить вторую часть кода, в которой может быть ошибка. Конечно, если ошибка возникает
в `else`, то она не будет поймана.

### Оператор raise

Если в вашем коде какие-либо данные не соответствуют вашим ожиданиям, вы всегда можете вызвать исключение, если вам это
необходимо, для этого используется ключевое слово `raise`.

```python
if odds % 2 != 1:
    raise ValueError("Did not get an odd number")
```

> Эта конструкция и ключевое слово нам понадобится после того как мы разберем функции, пока я могу показать только одно
> полезное применение.

Технически всегда можно обработать исключение и вызвать его же еще раз. Зачем такое может быть надо? В случае когда нам
не надо предотвращать ошибку, а только записать о том что ошибка случилась (так часто делается), тогда можно записать
информацию и вызвать эту же ошибку еще раз

```python
try:
    5 / 0
except ZeroDivisionError as e:
    raise ZeroDivisionError("Got an error", e)
```

в переменной `e` будет храниться вся информация об исключении, и таким способом мы вызовем нужный нам тип исключения, с
нашим комментарием и всей системной информацией, делать это через ключевое слово `as` не обязательно, можно и без этого,
но такой способ дает нам больше возможностей.

В качестве практики нужно взять все задания из прошлых двух лекций и попробовать покрыть весь код возможными
исключениями.

## Списки (Lists)

Список - это упорядоченная коллекция элементов, которая может содержать объекты разных типов. Они очень полезны при
работе с множеством данных.

Вместе со строками в нашу жизнь приходят такие термины как изменяемые и не изменяемые типы данных. Пока что, нам не
очень
важно знать детали того, что это такое. Но уже необходимо запомнить, что все типы данных в питоне делятся на изменяемые
и
не изменяемые. Все что мы учили до этого были не изменяемыми типами, а списки изменяемые.

> Строки, числа, булеаны (на самом деле булеан вообще является частным случаем числа), не изменяемые, списки изменяемые,
> это важно!
> А почему важно узнаете дальше.

### Создание списков

Создать список можно, заключив элементы в квадратные скобки `[]` и разделив их запятыми.

```python
fruits = ['яблоко', 'банан', 'груша', 'апельсин']
numbers = [1, 2, 3, 4, 5]
mixed_list = [1, 'два', 3.0, True]
```

Список может содержать в себе объекты любых типов.

### Доступ к элементам списка

Чтобы получить доступ к элементам списка, используйте индексацию (обращение к элементам по номеру). Нумерация в списках
начинается с 0. Если вам нужен 4-ый элемент коллекции его индекс будет 3. Синтаксис обращения по индексу, через
квадратные скобки `[]`

```python
print(fruits[0])  # Вывод: 'яблоко'
print(numbers[2])  # Вывод: 3
```

### Изменение элементов списка

Списки можно изменять, например мы можем заменить объект по индексу

```python
fruits[1] = 'киви'
print(fruits)  # Вывод: ['яблоко', 'киви', 'груша', 'апельсин']
```

### Ремарка про методы

> Практически у любого объекта в питоне есть возможность с ним совершить какие-то дополнительные действия. Обычно для
> этого используются методы (детально мы будем рассматривать эту тему дальше), что бы вызвать какой-либо метод,
> необходимо
> обратиться к объекту через точку, указать какой именно метод вам нужен, и если необходимо в скобках указать параметры
> для этого вызова

```python
obj.method(params)  # Параметры не обязательны
```

### Добавление и удаление элементов

Чтобы добавить элемент в конец списка, используйте метод `append()`.

```python
fruits.append('ананас')
print(fruits)  # Вывод: ['яблоко', 'киви', 'груша', 'апельсин', 'ананас']
```

Чтобы удалить элемент по индексу, используйте `del`.

```python
del fruits[2]
print(fruits)  # Вывод: ['яблоко', 'киви', 'апельсин', 'ананас']
```

### Методы списков

Мы уже поговорили про `append`, но методов у списков гораздо больше, давайте их рассмотрим.

#### `clear()`

Метод очищает список. Параметров нет.

```python
l = [1, 2, 3]
l.clear()
print(l)  # []
```

#### `copy()`

Метод возвращает копию списка. Параметров нет.

```python
l = [1, 2, 3]
l2 = l.copy()
print(l is l2)  # False Вернемся к этому оператору после функций
print(l == l2)  # True
```

#### `count(elem)`

Метод считает сколько раз в списке встречается указанный элемент. Параметр один, что ищем.

```python
l = [1, 2, 3, 1, 1]
print(l.count(1))  # 3
print(l.count(2))  # 1
print(l.count(5))  # 0
```

#### `extend(collection)`

Метод расширяет список другой коллекцией (пока читаем другим списком). Параметр один, принимает коллекцию (например
список).

```python
l1 = [1, 2, 3]
l2 = ['a', 'b']
l1.extend(l2)
print(l1)  # [1,2,3,'a','b']
```

#### `index(elem)`

Метод возвращает индекс указанного элемента, если элемент не найден, вызывает исключение ValueError. Параметр один, что
ищем, можно указать дополнительные параметры через запятую, от какого элемента искать, и до какого.

```python
l = [1, 2, 3]
print(l.index(2))  # 1 - помним что счет начинается с 0
print(l.index(4))  # Вызовет ValueError
l.index(3, 0, 1)  # Вызовет ValueError, потому что в списке ограниченном индексами 0 и 1 нет элемента 3
```

#### `insert(pos, elem)`

Метод добавляет объект на указанное место. Параметра два, на какое место, и какой элемент добавить.

```python
l = [1, 2, 3]
l.insert(1, 4)
print(l)  # [1, 4, 2, 3]
```

Поддерживает механику обратных индексов, о ней дальше

#### `pop(pos)`

Метод "вытаскивает" элемент из указанной позиции, если позиция не указана, вытаскивает последний. Параметр один, позиция
элемента и он не обязательный.

```python
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]
last_elem = l.pop()
elem_num_4 = l.pop(3)
print(l)  # [1,2,3,5,6,7,8]
print(last_elem)  # 9
print(elem_num_4)  # 4
```

Поддерживает механику обратных индексов, о ней дальше

#### `remove(elem)`

Метод удаляет элемент есть находит его в списке. Параметр один, значение элемента.

```python
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]
l.remove(4)
print(l)  # [1,2,3,5,6,7,8,9]
l.remove('a')  # вызовет ValueError
```

#### `reverse()`

Метод разворачивает список. Параметров нет.

```python
l = [1, 2, 3, 4, 5, 6, 7, 8, 9]
l.reverse()
print(l)  # [9, 8, 7, 6, 5, 4, 3, 2, 1]
```

> Внимание reverse() ничего не возвращает, если сделать ```a=l.reverse()``` в переменной **a** не будет списка!
> Измениться оригинал

#### `sort()`

Метод сортирует список. Параметров два, но детально мы будем его рассматривать в лекции по алгоритмам, там много
деталей.

```python
l = [3, 5, 1, 2]
l.sort()
print(l)  # [1, 2, 3, 5]
```

> Тут тоже меняется оригинал

### Основные возможные исключения связанные со списками

В случае работы со списками могут произойти ранее не рассмотренное исключения.

- `IndexError` - Случается когда мы пытаемся получить объект по индексу, а такого индекса не существует

```python
l = [1, 2, 3]
print(l[5])  # IndexError
```

## Строки как коллекции

На самом деле строки в python-е являются коллекциями, а это значит что к ним применимы многие практики из списков,
например к ним применимы методы `count` и `index`

### Доступ к символам строки

Для доступа к символам строки используйте индексацию, так же как и для списков.

```python
text = "Hello, World!"
print(text[0])  # Вывод: 'H'
```

У строк очень много разных полезных методов, и особенностей, мы рассмотрим только основные, хотя их там много, кто хочет
детально почитать про все [тыц](https://www.w3schools.com/python/python_ref_string.asp) сюда

### Умножение строк

Вы можете умножить строку на число, чтобы повторить ее несколько раз.

```python
text = "Привет"
result = text * 3  # Результат: "ПриветПриветПривет"
```

Python предоставляет множество методов для работы со строками. Ниже представлены некоторые из наиболее часто
используемых методов.

### `str.upper()` и `str.lower()`

Метод `upper()` преобразует все символы строки в верхний регистр, а `lower()` - в нижний.

```python
text = "Привет, мир!"
uppercase = text.upper()  # Результат: "ПРИВЕТ, МИР!"
lowercase = text.lower()  # Результат: "привет, мир!"
```

### `str.strip()`

Метод `strip()` удаляет пробелы и символы перевода строки с начала и конца строки.

```python
text = "   Текст с лишними пробелами   "
stripped_text = text.strip()  # Результат: "Текст с лишними пробелами"
```

### `str.split()`

Метод `split()` разбивает строку на список подстрок, используя разделитель.

```python
text = "Яблоки, Груши, Бананы"
fruits = text.split(", ")  # Результат: ['Яблоки', 'Груши', 'Бананы']
```

### `str.replace()`

Метод `replace()` заменяет все вхождения подстроки на другую подстроку.

```python
text = "Привет, мир!"
new_text = text.replace("мир", "вселенная")  # Результат: "Привет, вселенная!"
```

### `str.find()` и `str.index()`

Методы `find()` и `index()` находят первое вхождение подстроки в строку и возвращают индекс этого вхождения. Разница
между ними в том, что `find()` возвращает -1, если подстрока не найдена, а `index()` вызывает исключение.

```python
text = "Это пример текста с примерами"
index1 = text.find("пример")  # Результат: 4
index2 = text.index("пример")  # Результат: 4
index3 = text.find("нет")  # Результат: -1
# index4 = text.index("нет")  # Вызовет ValueError
```

### `str.count()`

Метод `count()` подсчитывает количество вхождений подстроки в строку.

```python
text = "Это пример текста с примерами"
count = text.count("пример")  # Результат: 2
```

### `str.startswith()` и `str.endswith()`

Методы `startswith()` и `endswith()` проверяют, начинается ли строка с указанной подстроки или заканчивается ей.

```python
text = "Это пример текста"
starts_with = text.startswith("Это")  # Результат: True
ends_with = text.endswith("текста")  # Результат: True
```

### `str.join()`

Метод `join()` объединяет список строк с помощью текущей строки в качестве разделителя.

```python
fruits = ['Яблоки', 'Груши', 'Бананы']
text = ', '.join(fruits)  # Результат: "Яблоки, Груши, Бананы"
```

> Split превратит строку в список, join превратит список в строку

## Форматирование строк

Мы обсудили что строки можно конкатенировать. Это далеко не единственная возможность для форматирования строк в
python всего их вроде 5, но мы рассмотрим два основных, современный и слегка устаревший, но все еще часто применяемый.

### F-строки

Python 3.6 и выше поддерживают f-строки (f-strings), которые представляют собой удобный способ вставки переменных и
выражений в строки. Самый распространенный способ форматирования строк на данный момент

```python
name = "Иван"
age = 30
text = f"Привет, меня зовут {name} и мне {age} лет."
print(text)  # Привет, меня зовут Иван и мне 30 лет.
```

F-строки начинаются с буквы `f` перед открывающей кавычкой, и в фигурных скобках `{}` можно вставлять переменные или
выражения, которые будут вычислены и подставлены в строку.

### Использование метода `str.format()`.

```python
name = "Иван"
age = 30
text = "Привет, меня зовут {} и мне {} лет.".format(name, age)
# Результат: "Привет, меня зовут Иван и мне 30 лет."
```

Для его использования вам необходимо указать в строке символы `{}` для обозначения места куда будут подставлены данные,
и после вызвать метод `.format()` куда передать значения которые необходимо подставить, кол-во элементов должно
совпадать с количеством скобок. Там довольно много деталей, можете изучить их самостоятельно

> Мы будем много использовать оба способа форматирования, а иногда даже сталкиваться с более старыми способами, так что
> рекомендую разобраться как это работает

## Обратная индексация

Для многих коллекций к которым применим индекс (для нас пока это строки и списки) можно использовать обратный индекс.
Что это такое? Это указание индекса от конца к началу.

```python
l = [1, 2, 3]
print(l[-1])  # 3
print(l[-2])  # 2
print(l[-4])  # IndexError
```

Этот инструмент дает довольно много интересных особенностей с которыми мы будем сталкиваться в дальнейшем

### Срезы

Срез позволяет получить часть коллекции из коллекции, чаще всего применяются к строкам или спискам.

Синтаксис среза: `строка[начало:конец:шаг]`.

```python
text = "Hello, World!"

substring = text[2:5]  # Получение подстроки "llo"
print(substring)  # Вывод: 'llo'

substring = text[7:]  # Получение подстроки с 7-го символа до конца
print(substring)  # Вывод: 'World!'

substring = text[:5]  # Получение подстроки с начала до 5-го символа
print(substring)  # Вывод: 'Hello'

substring = text[::2]  # Получение каждого второго символа
print(substring)  # Вывод: 'Hlo ol!'

copy = text[:]  # получение копии строки
```

Срезы можно комбинировать с обратными индексами!

```python
text = "Hello, World!"

substring = text[:-3]  # Получение подстроки "Hello, Wor" (без 3-х последних символов)

substring = text[-3:]  # Получение подстроки из 3-х последних символов
print(substring)  # Вывод: 'ld!'

substring = text[-5:-1]  # Получение 5 последних символов без последнего
print(substring)  # Вывод: 'orld'

substring = text[::-1]  # Получение строки в обратном порядке
print(substring)  # Вывод: '!dlroW ,olleH'

```

## Циклы

Циклы позволяют выполнять повторяющиеся операции.

### Цикл `for`

Цикл `for` используется для итерации по коллекциям, таким как списки и строки (и не только).

```python
fruits = ['яблоко', 'киви', 'груша', 'апельсин']

for fruit in fruits:
    print(fruit)
```

### Цикл `while`

Цикл `while` выполняется до тех пор, пока условие истинно.

```python
count = 0

while count < 5:
    print(count)
    count += 1
```

### Ключевое слово `break`

`break` используется для выхода из цикла досрочно, даже если условие цикла остается истинным. Обычно `break`
используется внутри условия, чтобы определить момент завершения цикла.

Пример с циклом `while`:

```python
count = 0

while count < 5:
    if count == 3:
        break  # Выход из цикла, если count равно 3
    print(count)
    count += 1
```

Пример с циклом `for`:

```python
fruits = ['яблоко', 'киви', 'груша', 'апельсин']

for fruit in fruits:
    if fruit == 'груша':
        break  # Выход из цикла при нахождении 'груши'
    print(fruit)
```

### Ключевое слово `continue`

`continue` используется для перехода к следующей итерации цикла, игнорируя оставшуюся часть текущей итерации.
Обычно `continue` используется внутри условия для пропуска определенных действий.

Пример с циклом `while`:

```python
count = 0

while count < 5:
    count += 1
    if count == 3:
        continue  # Пропустить вывод числа 3
    print(count)
```

Пример с циклом `for`:

```python
fruits = ['яблоко', 'киви', 'груша', 'апельсин']

for fruit in fruits:
    if fruit == 'груша':
        continue  # Пропустить вывод 'груши'
    print(fruit)
```

Ключевые слова `break` и `continue` полезны при создании более сложной логики в циклах и позволяют управлять потоком
выполнения программы в более гибком стиле.

### Бесконечные циклы

Иногда может потребоваться создать бесконечный цикл, который будет выполняться до тех пор, пока его не прервут. Для
этого используется конструкция `while True`.

```python
while True:
    # Этот цикл будет выполняться бесконечно
    user_input = input("Введите что-нибудь (для выхода наберите 'q'): ")
    if user_input == 'q':
        break  # Выход из цикла при вводе 'q'
```

Бесконечные циклы могут быть полезными в тех случаях, когда нужно создать программу, которая работает в фоновом режиме и
ожидает какого-либо события, либо когда нужно регулярно выполнять какую-то задачу, например, мониторинг сенсоров или
сетевых подключений.

Не забывайте, что бесконечные циклы должны иметь какой-то механизм для прерывания, иначе программа будет выполняться
бесконечно и может привести к зависанию.

Практика:

1. Создайте список numbers с числами от 1 до 10. Используя цикл for, выведите каждое число из списка numbers,
   возведенное в квадрат. Используя цикл for, найдите сумму всех чисел в списке numbers.
2. Создайте строку text с произвольным текстом. Используя цикл for, выведите каждый символ из строки text.
3. Используя срезы, выведите первые 5 символов и последние 5 символов из строки text.
4. Создайте список чисел от 1 до 20. Используя цикл for, выведите все числа из списка, которые делятся на 3 без остатка.
5. Используя цикл while, найдите сумму всех чисел от 1 до 100.
6. Создайте бесконечный цикл с использованием while True, который будет предлагать пользователю ввод числа и выводить
   квадрат этого числа. Добавьте условие для выхода из цикла
   при вводе значения "0" или "exit".
7. Создайте список слов words, включая некоторые повторяющиеся слова. Используя цикл for, выведите все уникальные слова
   из списка.
8. Подсчет гласных букв: Попросите пользователя ввести строку текста, а затем используйте методы строк для подсчета
   количества гласных букв (а, е, и, о, у) в этой строке.
9. Замена слов: Создайте строку, содержащую предложение, и попросите пользователя ввести слово. Затем замените все
   вхождения этого слова в предложении на слово "заменено". Выведите измененное предложение.
10. Создайте список с повторяющимися элементами. Используйте методы списков для удаления дубликатов и выведите
    измененный
    список.
11. Создать список со случайными числами. Найти самое большое и самое маленькое число (пользоваться встроенными методами
    для их поиска запрещено)

12. FizzBuzz - классическая задача с легких собеседований: Задача заключается в написании программы, которая выводит
    числа от 1 до n, заменяя некоторые из них на определенные слова в зависимости от их делимости.
    Условия:

- Программа должна выводить числа от 1 до n (включительно).
- Для чисел, кратных 3, вместо числа должно выводиться слово "Fizz".
- Для чисел, кратных 5, вместо числа должно выводиться слово "Buzz".
- Для чисел, кратных и 3, и 5, вместо числа должно выводиться слово "FizzBuzz".
- Для всех остальных чисел должно выводиться само число.

Пример. Для n = 15 вывод программы должен быть следующим:

```
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
```

12.1 сделать так что бы пользователь вводил руками оба делителя и `n`. Не 3, 5 и 15, а любые числа введенные
пользователем.
