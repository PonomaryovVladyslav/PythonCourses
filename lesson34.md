# Урок 34. Куки, сессии, кеш

## Куки и сессии

### Что такое куки(печеньки) и причём тут сессия?

Понятие "Сессий" основано на том, что состояние пользователя каким-то образом сохраняется, когда он переходит с одной
страницы на другую. Вспомните, что HTTP не сохраняет состояний, поэтому только браузер или ваше приложение может
"запомнить" то, что нужно запомнить.

## Куки

Куки — это пары данных по типу "ключ-значение", которые сохраняются в браузере пользователя до истечения какого-то
определенного срока. Они применимы практически для любой задачи, но чаще всего их используют, чтобы сохранить
пользователя в том же месте веб-страницы, если он потеряет интернет-соединение, или, чтобы хранить простые настройки
отображения сайта. Например, корзины интернет магазинов чаще всего делают именно через куки, ведь вы не теряете данные,
при переходе со страницы на страницу, а хранить данные что вы набираете в корзину в базе данных, это слишком избыточно.
Вы можете также хранить в них данные пользователя или даже пароли, но это не очень хорошая идея, не стоит хранить в
обычных куках браузера информацию, которая должна быть защищенной или сохраняться между сессиями браузера. Пользователь
может легко потерять данные, очистив кэш, или украсть/использовать незащищенные данные из куков.

![](https://static.issue.life/Content/img/13-03-2019/636880833560890859.png)

Куки добавляются в request/response для хранения абсолютно разных данных. Например, стандартная джанго авторизация
добавляет куку с данными о пользователя, что бы можно было определить кто именно делает запрос. Поэтому там и нужны csrf
токены в формах или просто токены в рест запросах, так как перехватить значение куки при запросе очень просто, а мы
должны быть уверенны, что запрос пришел именно от авторизированного пользователя (Куки хранит информацию, кто это, а
токены позволяют проверить, что это был именно этот пользователь.).

### Сессия

Задумайтесь о том, каким образом браузеры следят, что пользователь залогинен, когда страница перезагружается. HTTP
запросы не имеют состояний, так как же вы определите, что запрос пришел именно от залогиненого пользователя? Вот почему
важны куки — они позволяют вам отслеживать пользователя от запроса к запросу, пока не истечет их срок действия.

Особый случай — это когда вы хотите отслеживать данные пользовательской "сессии", которая включает все, что пользователь
делает, пока вы хотите "запоминать" это, обычно до тех пор, пока пользователь не закроет окно браузера. В этом случае
каждая страница, которую пользователь посетил до закрытия браузера будет частью одной сессии.

Если упростить, сессия это набор запросов от одного и того же пользователя (Или от разных в рамках одного процесса).

В случае с джанго, при стандартных настройках, сессия хранит набор куки, которые храняться в формате JSON. (А значит,
что данные можно сериализовать)

### Как этим пользоваться?

В джанго сессия всегда храниться в реквесте, `request.session` в виде словаря.

Рассмотрим несколько примеров.

```python
>> > request.session[0] = 'bar'
>> >  # subsequent requests following serialization & deserialization
>> >  # of session data
>> > request.session[0]  # KeyError
>> > request.session['0']
'bar'
``` 

Данные хранятся в формате JSON, а значит что ключи будут преобразованы в строки.

Допустим вам нужно "запомнить" комментировал ли этот пользователь только что статью, что бы не позволить написать
большое кол-во комментариев подряд. Конечно можно сохранить эти данные в базе, но зачем? Проще воспользоваться сессией:

```python
def post_comment(request, new_comment):
    if request.session.get('has_commented', False):
        return HttpResponse("You've already commented.")
    c = comments.Comment(comment=new_comment)
    c.save()
    request.session['has_commented'] = True
    return HttpResponse('Thanks for your comment!')
```

Сохраним это состояние в сессии и будем перепроверять именно его.

Допустим вам нужно хранить сколько времени назад пользователь последний раз совершал действие после логина.

```python
request.session['last_action'] = timezone.now()
```

Теперь мы можем проверить когда было выполнено последнее действие и добавить любую нужную нам логику.

Если нам нужно воспользоваться сессией вне мест, где есть доступ к реквесту:

```python
from django.contrib.sessions.backends.db import SessionStore

s = SessionStore()
# stored as seconds since epoch since datetimes are not serializable in JSON.
s['last_login'] = 1376587691
s.create()
s.session_key
'2b1189a188b44ad18c35e113ac6ceead'
SessionStore(session_key='2b1189a188b44ad18c35e113ac6ceead')
s['last_login']
1376587691
```

Мы можем получить сессию по ключу (Любая созданная джанго сессия автоматически хранит переменную `session_key`) по
которой получить нужные нам данные.

Данные в любой сессии хранятся в кодированном виде, что бы получить все данные сессии, не зная конкретного ключа их
можно получить через метод `.get_decoded()`

```python
s.session_data
'KGRwMQpTJ19hdXRoX3VzZXJfaWQnCnAyCkkxCnMuMTExY2ZjODI2Yj...'
s.get_decoded()
{'user_id': 42}
```

Сохранение данных в сессии происходит только тогда когда меняется значение request.session :

```python
# Session is modified.
request.session['foo'] = 'bar'

# Session is modified.
del request.session['foo']

# Session is modified.
request.session['foo'] = {}

# Gotcha: Session is NOT modified, because this alters
# request.session['foo'] instead of request.session.
request.session['foo']['bar'] = 'baz'
```

В последнем случае данные не будут сохранены, т.к. модифицируется не request.session, а `request.session['foo']`

Это поведение можно изменить, если добавить настройку в `settings.py`  `SESSION_SAVE_EVERY_REQUEST = True` тогда запись
в сессию будет происходить каждый запрос, а не только в момент изменения.

Для очистки данных сессии можно воспользоваться мендж командой `python manage.py clearsessions`

Некоторые настройки можно поменять и перенастроить, как и полностью кастомизировать любые действия с сессиями. Подробнее
об этом [Тут](https://docs.djangoproject.com/en/3.1/topics/http/sessions/)

## Кеш

Официальная документация [Тут](https://docs.djangoproject.com/en/3.1/topics/cache/)

Что такое кеш?

Кеш — промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей
вероятностью. Доступ к данным в кэше осуществляется быстрее, чем выборка исходных данных из более медленной памяти или
удалённого источника, однако её объём существенно ограничен по сравнению с хранилищем исходных данных.

Если упростить, то это хранилище для часто запрашиваемых данных.

Предположим мы разрабатываем новостной сайт, и знаем, что новости у нас обновляются раз в час.

В течение часа, пока новости не обновятся, абсолютно каждый пользователь заходящий на сайт, будет видеть один и тот же
набор статей, а значит нам необязательно каждый раз доставать этот набор из базы данных, мы можем закешировать его!

Для использования кеша, мы можем воспользоваться огромным кол-вом заранее заготовленных решений для кеша.

Как часто бывает в джанго кеш настраивается через `settings.py`

Хранение данных с использованием Memcached (Стандартный кеш для джанго), на отдельном для этого порту 11211:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': '127.0.0.1:11211',
    }
}
```

Хранение в файле сокета (временный файл хранилище в юникс системах):

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': 'unix:/tmp/memcached.sock',
    }
}
```

Хранение на несольких серверах, для уменьшения нагрузки:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': [
            '172.19.26.240:11211',
            '172.19.26.242:11211',
        ]
    }
```

Можно хранить кеш прям в базе данных, для этого нужно указать таблицу в которую складывать кеш:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',
    }
}
```

Для использования кеша через базу, таблицу нужно предварительно создать, сделать это можно при помощи менедж команды:

```python manage.py createcachetable```

Можно хранить кеш в обычном файле:

Линукс\мак:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    }
}
```

Виндовс:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': 'c:/foo/bar',
    }
}
```

Можно хранить в оперативной памяти сервера:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake',
    }
}
```

Есть упрощенная схема кеширования для разработки:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}
```

Как и всё остальное, кеш можно кастомизировать написав собственные классы для управления кешем:

```python
CACHES = {
    'default': {
        'BACKEND': 'path.to.backend',
    }
}
```

Любой тип кеширования поддерживает большое кол-во доп настроек, подробно о которых в документации.

### Как же этим пользоваться?

Существует два основных способа использовать кеш.

Кешировать весь сайт, или кешировать конкретную вью.

Для того что бы кешировать весь сайт, нужно добавить две мидлвары (Как это работает, на следующем занятии), до и
после `CommonMiddleware` (это важно, иначе работать не будет):

В `settings.py`

```python
MIDDLEWARE = [
    ...
    'django.middleware.cache.UpdateCacheMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.cache.FetchFromCacheMiddleware',
    ...
]
```

Время кеширование или ограничения на кеш выставляются через переменные `settings.py`, подробно в документации.

Для того, что бы кешировать, отдельный метод или класс используется декоратор `cache_page`

```python
from django.views.decorators.cache import cache_page


@cache_page(60 * 15)
def my_view(request):
    ...
```

В скобках указывается время которое кеш должен хранится, обычно записывается в виде умножения на секунды\минуты, для
простоты чтения (15*60 это 15 минут, никакой разницы от того что бы записать 900, но так проще воспринимать на вид).

Чаще всего декоратор используется в урлах:

```python
from django.views.decorators.cache import cache_page

urlpatterns = [
    path('foo/<int:code>/', cache_page(60 * 15)(my_view)),
]
```

Для кеширования class base view кешируется весь класс:

```python
from django.views.decorators.cache import cache_page

url(r'^my_url/?$', cache_page(60 * 60)(MyView.as_view())),
```

Так же можно закешировать часть темплейта при помощи темплейт тега `cache`:

```html
{ % load cache %}
{ % cache 500 sidebar %}
..sidebar..
{ % endcache %}
```

В кеш можно записать любые кастомные данные, если это необходимо

```python
from django.core.cache import cache

cache.set('my_key', 'hello, world!', 30)
cache.get('my_key')
'hello, world!'
# Wait 30 seconds for 'my_key' to expire...
cache.get('my_key')
None

cache.set('add_key', 'Initial value')
cache.add('add_key', 'New value')
# .add() сработает только если в указанном ключе ничего не было
cache.get('add_key')
'Initial value'

cache.get_or_set('my_new_key', 'my new value', 100)
'my new value'

import datetime

cache.get_or_set('some-timestamp-key', datetime.datetime.now)
datetime.datetime(2014, 12, 11, 0, 15, 49, 457920)

cache.set('a', 1)
cache.set('b', 2)
cache.set('c', 3)
cache.get_many(['a', 'b', 'c'])
{'a': 1, 'b': 2, 'c': 3}

cache.set_many({'a': 1, 'b': 2, 'c': 3})
cache.get_many(['a', 'b', 'c'])
{'a': 1, 'b': 2, 'c': 3}

cache.delete('a')
cache.delete_many(['a', 'b', 'c'])

cache.clear()

cache.touch('a', 10)  # Обновить время хранения
```

И многие другие тонкости и особенности, например декоратор `from django.views.decorators.cache import never_cache`
который можно использовать, что бы не кешировать данные, если вы уже кешируете весь сайт. И многое другое, подробности в
документации.

Практика:

1. Пользователь открывает одну и туже страницу. Каждый четвертый раз когда он открывает страницу добавте вверху
   надпись, "Это был 4-ый раз", если обновить страницу еще раз, то счёт 4-ех открытий начинаем сначала.

2. Множество пользователей открывает одну и туже страницу, каждый 10-ый кто открывает страницу должен видеть надпись, "
   Вы наш 10-ый покупатель" (Если один пользователь открыл 10 раз, это тоже подходит, один пользователь 6 раз и еще один
   4 раза, тоже ок)
   
