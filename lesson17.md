# Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup

### Оглавление курса

<details>
  <summary>Блок 1 — Python Basic (1–6)</summary>

  - [Лекция 1. Введение. Типизации. Переменные. Строки и числа. Булева алгебра. Ветвление](lesson01.md)
  - [Лекция 2. Обработка исключений. Списки, строки детальнее, срезы, циклы.](lesson02.md)
  - [Лекция 3. None. Range, list comprehension, sum, max, min, len, sorted, all, any. Работа с файлами](lesson03.md)
  - [Лекция 4. Хэш-таблицы. Set, frozenset. Dict. Tuple. Немного об импортах. Namedtuple, OrderedDict](lesson04.md)
  - [Лекция 5. Функции, типизация, lambda. Map, zip, filter.](lesson05.md)
  - [Лекция 6. Алгоритмы и структуры данных](lesson06.md)
</details>

<details>
  <summary>Блок 2 — Git (7–8)</summary>

  - [Лекция 7. Git. История системы контроля версий. Локальный репозиторий. Базовые команды управления репозиторием.](lesson07.md)
  - [Лекция 8. Git. Удаленный репозиторий. Remote, push, pull. GitHub, Bitbucket, GitLab, etc. Pull request.](lesson08.md)
</details>

<details>
  <summary>Блок 3 — Python Advanced (9–14)</summary>

  - [Лекция 9. Введение в ООП. Основные парадигмы ООП. Классы и объекты. Множественное наследование.](lesson09.md)
  - [Лекция 10. Magic methods. Итераторы и генераторы.](lesson10.md)
  - [Лекция 11. Imports. Standard library. PEP 8](lesson11.md)
  - [Лекция 12. Декораторы. Декораторы с параметрами. Декораторы классов (staticmethod, classmethod, property)](lesson12.md)
  - [Лекция 13. Тестирование](lesson13.md)
  - [Лекция 14. Проектирование. Паттерны. SOLID.](lesson14.md)
</details>

<details open>
  <summary>Блок 4 — SQL (15–17)</summary>

  - [Лекция 15. СУБД. PostgreSQL. SQL. DDL. Пользователи. DCL. DML. Связи.](lesson15.md)
  - [Лекция 16. СУБД. DQL. SELECT. Индексы. GROUP BY. Joins.](lesson16.md)
  - ▶ **Лекция 17. СУБД. Нормализация. Аномалии. Транзакции. ACID. TCL. Backup**
</details>

- [Лекция 18. Virtual env. Pip. Устанавливаемые модули. Pyenv.](lesson18.md)

<details>
  <summary>Блок 5 — Django (19–26)</summary>

  - [Лекция 19. Знакомство с Django](lesson19.md)
  - [Лекция 20. Templates. Static](lesson20.md)
  - [Лекция 21. Модели. Связи. Meta. Abstract, proxy.](lesson21.md)
  - [Лекция 22. Django ORM.](lesson22.md)
  - [Лекция 23. Forms, ModelForms. User, Authentication.](lesson23.md)
  - [Лекция 24. ClassBaseView](lesson24.md)
  - [Лекция 25. NoSQL. Куки, сессии, кеш](lesson25.md)
  - [Лекция 26. Логирование. Middleware. Signals. Messages. Manage commands](lesson26.md)
</details>

<details>
  <summary>Блок 6 — Django Rest Framework (27–30)</summary>

  - [Лекция 27. Что такое API. REST и RESTful. Django REST Framework.](lesson27.md)
  - [Лекция 28. @api_view, APIView, ViewSets, Pagination, Routers](lesson28.md)
  - [Лекция 29. REST-аутентификация. Авторизация. Permissions. Фильтрация.](lesson29.md)
  - [Лекция 30. Тестирование. Django, REST API.](lesson30.md)
</details>

<details>
  <summary>Блок 7 — Python async (31–33)</summary>

  - [Лекция 31. Celery. Multithreading. GIL. Multiprocessing](lesson31.md)
  - [Лекция 32. Asyncio. Aiohttp. Асинхронное программирование на практике.](lesson32.md)
  - [Лекция 33. Сокеты. Django Channels.](lesson33.md)
</details>

<details>
  <summary>Блок 8 — Deployment (34–35)</summary>

  - [Лекция 34. Linux. Всё, что нужно знать для деплоймента.](lesson34.md)
  - [Лекция 35. Deployment](lesson35.md)
</details>

- [Лекция 36. Методологии разработки. CI/CD. Монолит и микросервисы. Docker](lesson36.md)


![](https://bigdataschool.ru/wp-content/uploads/2020/10/e00b424fd21a4f6f0091c7c1003453a8.jpg)

## Нормализация базы данных

Нормализация — это процесс организации данных в базе данных, чтобы они были свободны от избыточности и зависимости. Она
помогает устранить несоответствия и аномалии данных, тем самым улучшая целостность данных. Нормализация представляет
собой набор правил или руководств по проектированию схемы базы данных таким образом, чтобы избежать дублирования данных,
избыточности данных и несоответствий данных.

> Основная цель нормализации базы данных — избежать сложностей, устранить дублирование и организовать данные в
> согласованной форме. Нормализация уменьшает избыточность и зависимость данных, делая базу данных более эффективной,
> гибкой и масштабируемой. Она также помогает поддерживать согласованность и точность данных, обеспечивая правильное
> обработку обновлений и удалений.

Существует 6 + 3 **нормальные формы**, но на практике дальше, чем 3-я нормальная форма, почти никогда не применяется, и они
нужны скорее для академических исследований либо для очень специфических случаев.

Нормализованные таблицы:

- Легче понять
- Легче улучшать и расширять
- Защищены от:
    - аномалий вставки
    - аномалий обновления
    - аномалий удаления

## Аномалии

А кто такие вообще аномалии и зачем от них защищаться?

Аномалии — это ситуации, которые вызывают неожиданное поведение из-за неправильной структуры. Давайте разберёмся.

### Аномалии вставки

Существуют обстоятельства, при которых определённые факты невозможно записать. Например, каждая запись в отношении
«Преподаватели и их курсы» может содержать **ID преподавателя**, **Имя преподавателя** и **Код курса**. Следовательно,
детали любого преподавателя, который преподаёт хотя бы один курс, могут быть записаны. Но недавно нанятый преподаватель,
которому ещё не назначены курсы, не может быть записан, за исключением установки кода курса в `NULL`.

| ID преподавателя | Имя преподавателя | Код курса |
|------------------|-------------------|-----------|
| 389              | Dr. Headstrong    | ENG-206   |
| 407              | Dr. Mugwort       | CMP-101   |
| 407              | Dr. Mugwort       | CMP-201   |

| ID преподавателя | Имя преподавателя | Код курса |
|------------------|-------------------|-----------|
| 321              | Dr. Newone        | ???       |

В этой ситуации мы получаем `NULL` там, где мы его не ожидали, либо ошибку, если у поля есть модификатор `NOT NULL`.

### Аномалии обновления

Одна и та же информация может быть выражена в нескольких строках, поэтому обновление отношения может привести к
логической несогласованности.

Например, каждая запись в отношении «Навыки работников» может содержать **идентификатор работника**, **Адрес работника**
и **Навык**. Таким образом, может возникнуть потребность в обновлении адреса для определённого
работника в нескольких записях (по одной для каждого навыка).

Если обновление происходит лишь частично — адрес работника обновляется в одних записях,
но не в других — то отношение остаётся в несогласованном состоянии. В частности,
отношение даёт противоречивые ответы на вопрос о том, каков адрес конкретного работника.

Вот таблица с данными:

| Employee ID | Employee Address      | Skill           |
|-------------|-----------------------|-----------------|
| 426         | 230 Parkland Crescent | typing          |
| 426         | 230 Parkland Crescent | shorthand       |
| 529         | 158 Watkins Place     | public speaking |
| 529         | 108 Church Street     | carpentry       |

У нас в данный момент две записи для сотрудника с номером `529` и разные адреса.

### Аномалии удаления

При определённых обстоятельствах удаление данных, представляющих определённые факты, приводит к удалению данных,
представляющих совсем другие факты. Отношение «Преподаватели и их курсы», описанное в предыдущем примере, страдает этим
типом аномалии, так как, если преподаватель временно перестаёт быть назначен на любой курс, последняя запись, в которой
он появляется, должна быть удалена, фактически удаляя и самого преподавателя.

| ID преподавателя | Имя преподавателя | Код курса |
|------------------|-------------------|-----------|
| 389              | Dr. Headstrong    | ENG-206   |
| 407              | Dr. Mugwort       | CMP-101   |
| 407              | Dr. Mugwort       | CMP-201   |

Удаляем первую строку, и вместе с курсом удаляем и самого преподавателя.

## Как избежать аномалий или нормализация

Именно для того, чтобы избежать аномалий, нам необходимо приводить все данные в 3-ю нормальную форму.

> Каждая следующая нормальная форма может быть достигнута, только когда данные приведены в предыдущую нормальную форму!!

> Нельзя из 1-й перейти в 3-ю или вообще без нормализации сразу во 2-ю.
> Только по очереди. Привели к 1-й. Привели ко 2-й. Привели к 3-й.

> Опытные разработчики сразу продумывают данные в 3-й нормальной форме.

### Первая нормальная форма (1NF)

Первая нормальная форма требует, чтобы:

- Все атрибуты должны быть атомарными. (Нельзя хранить списки или любые другие коллекции в одной ячейке.)
- Порядок строк не должен использоваться для передачи информации.
- Каждая запись в таблице должна быть уникальной. (Таблицы должны иметь первичные ключи — это гарантирует, что запись является
  уникальной.)
- Значения в колонках должны быть однотипными. (Типы данных не должны смешиваться в одном столбце (и СУБД не позволит
  вам этого сделать в любом случае), но всегда можно нарушить это правило, сохраняя числа в виде строки.)

### Общее описание

Допустим, мы разрабатываем базу данных для онлайн-игры, и нам надо хранить информацию о персонажах, их инвентаре и уровне.

Наша базовая таблица будет выглядеть так:

| Username   | Inventory                       | Level    | Skill level |
|------------|---------------------------------|----------|-------------|
| prombery87 | 2 амулета, 3 кольца             | 9        | Advanced    |
| wheed1997  | 18 медных монет, 1 лук, 5 стрел | almost 5 | Medium      |
| acen1999   | 1 меч, 1 щит, 4 кольца          | 2.5      | Beginner    |

Здесь `username` — это имя пользователя, `inventory` — инвентарь пользователя, `level` — уровень
персонажа, `skill level` — уровень продвинутости персонажа (зависит от его уровня: пусть будет 1–3 — это `Beginner`, 4–6 —
это `Medium`, 7–9 — это `Advanced`).

Давайте разбираться, что с этой таблицей не так и как мы можем привести её к первой нормальной форме.

#### Все атрибуты должны быть атомарны

Все ли атрибуты у нас не содержат никаких коллекций? Нет, у нас инвентарь содержит не атомарную информацию!

Давайте это изменим. Нужно вынести коллекции в отдельные записи. Заменим инвентарь, на две колонки, `item`
и `item_quantity`:

| Username   | Item          | Item quantity | Level    | Skill level |
|------------|---------------|---------------|----------|-------------|
| prombery87 | амулет        | 2             | 9        | Advanced    |
| prombery87 | кольцо        | 3             | 9        | Advanced    |
| wheed1997  | медные монеты | 18            | almost 5 | Medium      |
| wheed1997  | лук           | 1             | almost 5 | Medium      |
| wheed1997  | стрелы        | 5             | almost 5 | Medium      |
| acen1999   | меч           | 1             | 2.5      | Beginner    |
| acen1999   | щит           | 1             | 2.5      | Beginner    |
| acen1999   | кольцо        | 4             | 2.5      | Beginner    |

#### Порядок строк

В нашем случае мы не используем порядок строк для передачи информации. Тут ничего менять не надо.

#### Каждая запись в таблице была уникальной

Является ли каждая запись в нашей таблице уникальной? По сути, да — мы можем в качестве первичного ключа использовать
сочетание `username` и `item`.

В реальности там с вероятностью в 99% был бы ещё `id`, так как он сильно упрощает использование таблиц. Поэтому давайте
мы тоже его добавим.

| id | Username   | Item          | Item quantity | Level    | Skill level |
|----|------------|---------------|---------------|----------|-------------|
| 1  | prombery87 | амулет        | 2             | 9        | Advanced    |
| 2  | prombery87 | кольцо        | 3             | 9        | Advanced    |
| 3  | wheed1997  | медные монеты | 18            | almost 5 | Medium      |
| 4  | wheed1997  | лук           | 1             | almost 5 | Medium      |
| 5  | wheed1997  | стрелы        | 5             | almost 5 | Medium      |
| 6  | acen1999   | меч           | 1             | 2.5      | Beginner    |
| 7  | acen1999   | щит           | 1             | 2.5      | Beginner    |
| 8  | acen1999   | кольцо        | 4             | 2.5      | Beginner    |

#### Значения в колонках должны быть однотипными

Являются ли наши значения однотипными? Нет, в колонке `level` мы храним и целое число, и дробное, и строку. Так быть не
должно — давайте всё-таки преобразуем эту колонку в целочисленный тип.

| id | Username   | Item          | Item quantity | Level | Skill level |
|----|------------|---------------|---------------|-------|-------------|
| 1  | prombery87 | амулет        | 2             | 9     | Advanced    |
| 2  | prombery87 | кольцо        | 3             | 9     | Advanced    |
| 3  | wheed1997  | медные монеты | 18            | 4     | Medium      |
| 4  | wheed1997  | лук           | 1             | 4     | Medium      |
| 5  | wheed1997  | стрелы        | 5             | 4     | Medium      |
| 6  | acen1999   | меч           | 1             | 3     | Beginner    |
| 7  | acen1999   | щит           | 1             | 3     | Beginner    |
| 8  | acen1999   | кольцо        | 4             | 3     | Beginner    |

> Теперь наша таблица приведена в первую нормальную форму

### Вторая нормальная форма (2NF)

Вторая нормальная форма требует выполнения условий первой нормальной формы, а также чтобы каждый неключевой атрибут
зависел от всего ключа.

В первую очередь нам надо понять, что такое неключевой атрибут и что мы можем с этим сделать.

Для этого нам надо понять, что именно мы вообще храним в таблице и для чего она нам нужна.

Данная таблица хранит слишком много информации...

Тут мы храним и данные о персонаже, и его инвентарь.

А это значит, что мы, как минимум, должны разнести данные по разным таблицам. Потому что в данный момент нашим ключевым
атрибутом является `id` и мы даже не можем сказать идентификатор чего это вообще.

В первую очередь нам надо определить зависимости между полями.

```shell
username -> level -> skill_level; # уровень навыков зависит от уровня персонажа, а уровень в свою очередь от имени персонажа. Мы же не можем сказать, что кто-то 5-ого уровня, а кто мы понятия не имеем
username + item -> item_quantity; # Какой-то персонаж владеет каким‑то количеством объектов, значит, нам надо сохранить информацию о том, кто и чем владеет, а также сохранить информацию о количестве в этой таблице.
```

Таблица для персонажей:

| id | Username   | Level | Skill level |
|----|------------|-------|-------------|
| 1  | prombery87 | 9     | Advanced    |
| 2  | wheed1997  | 4     | Medium      |
| 3  | acen1999   | 3     | Beginner    |

Таблица для инвентаря

| id | user_id | Item          | Item quantity |
|----|---------|---------------|---------------|
| 1  | 1       | амулет        | 2             |
| 2  | 1       | кольцо        | 3             |
| 3  | 2       | медные монеты | 18            |
| 4  | 2       | лук           | 1             |
| 5  | 2       | стрелы        | 5             |
| 6  | 3       | меч           | 1             |
| 7  | 3       | щит           | 1             |
| 8  | 3       | кольцо        | 4             |

Но объект `item` тоже не является ключевым элементом, а значит, должен быть вынесен в отдельную таблицу!

Таблица для персонажей:

| id | Username   | Level | Skill level |
|----|------------|-------|-------------|
| 1  | prombery87 | 9     | Advanced    |
| 2  | wheed1997  | 4     | Medium      |
| 3  | acen1999   | 3     | Beginner    |

Таблица для предметов:

| id | Item          |
|----|---------------|
| 1  | амулет        |
| 2  | кольцо        |
| 3  | медные монеты |
| 4  | лук           |
| 5  | стрелы        |
| 6  | меч           |
| 7  | щит           |

Таблица для инвентаря

| id | user_id | Item | Item quantity |
|----|---------|------|---------------|
| 1  | 1       | 1    | 2             |
| 2  | 1       | 2    | 3             |
| 3  | 2       | 3    | 18            |
| 4  | 2       | 4    | 1             |
| 5  | 2       | 5    | 5             |
| 6  | 3       | 6    | 1             |
| 7  | 3       | 7    | 1             |
| 8  | 3       | 2    | 4             |

Теперь наши данные находятся во второй нормальной форме!

### Третья нормальная форма (3NF)

Третья нормальная форма требует выполнения условий второй нормальной формы и отсутствия транзитивных зависимостей.

#### Транзитивная зависимость

**Транзитивная зависимость** возникает в реляционной базе данных, когда один неключевой атрибут (колонка) зависит от
другого неключевого атрибута, а тот, в свою очередь, зависит от первичного ключа.

То есть, если в таблице есть атрибуты A, B и C, и если:

- A -> B (B зависит от A)
- B -> C (C зависит от B)

Тогда можно сказать, что A транзитивно определяет C через B (A -> C через B).

#### Пример транзитивной зависимости

Предположим, у нас есть таблица студентов с информацией о факультетах:

| Student_ID | Student_Name | Faculty_ID | Faculty_Name |
|------------|--------------|------------|--------------|
| 1          | Alice        | F1         | Engineering  |
| 2          | Bob          | F2         | Science      |
| 3          | Charlie      | F1         | Engineering  |

В этой таблице транзитивная зависимость выглядит так:

- Student_ID -> Faculty_ID (каждый студент связан с конкретным факультетом)
- Faculty_ID -> Faculty_Name (каждый факультет имеет уникальное название)

Таким образом, Student_ID транзитивно определяет Faculty_Name через Faculty_ID.

#### Пример приведения к 3NF

Изначальная таблица содержит транзитивные зависимости:

| Student_ID | Student_Name | Faculty_ID | Faculty_Name |
|------------|--------------|------------|--------------|
| 1          | Alice        | F1         | Engineering  |
| 2          | Bob          | F2         | Science      |
| 3          | Charlie      | F1         | Engineering  |

Для приведения к 3NF, мы разделим таблицу на две:

Таблица Студенты:

| Student_ID | Student_Name | Faculty_ID |
|------------|--------------|------------|
| 1          | Alice        | F1         |
| 2          | Bob          | F2         |
| 3          | Charlie      | F1         |

Таблица Факультеты:

| Faculty_ID | Faculty_Name |
|------------|--------------|
| F1         | Engineering  |
| F2         | Science      |

Теперь у нас нет транзитивных зависимостей, и обе таблицы находятся в 3NF.

### Обратно к нашему примеру

Вернёмся к нашей игре.

Есть ли у нас транзитивные зависимости?

Есть — и я её описал уже на этапе второй формы!

```shell
username -> level -> skill_level
```

То, что мы вынесли всю цепочку в отдельную таблицу, не позволяет нам сказать, что мы избавились от зависимости!

Что же нужно сделать? Нужно вынести связь между уровнями и навыком в отдельную таблицу!

Таблица для зависимости уровня от навыка:

> Для этого примера я не буду создавать отдельное поле `id` (на самом деле в некоторых примерах выше (item, user, даже
> для инвентаря) можно было тоже обойтись без него, достаточно того, чтобы у нас был уникальный атрибут или
> совокупность
> атрибутов)

| level | skill level |
|-------|-------------|
| 1     | Beginner    |
| 2     | Beginner    |
| 3     | Beginner    |
| 4     | Medium      |
| 5     | Medium      |
| 6     | Medium      |
| 7     | Advanced    |
| 8     | Advanced    |
| 9     | Advanced    |

Таблица для персонажей:

| id | Username   | Level |
|----|------------|-------|
| 1  | prombery87 | 9     |
| 2  | wheed1997  | 4     |
| 3  | acen1999   | 3     |

#### Остальные таблицы

Таблица для предметов:

| id | Item          |
|----|---------------|
| 1  | амулет        |
| 2  | кольцо        |
| 3  | медные монеты |
| 4  | лук           |
| 5  | стрелы        |
| 6  | меч           |
| 7  | щит           |

Таблица для инвентаря

| id | user_id | Item | Item quantity |
|----|---------|------|---------------|
| 1  | 1       | 1    | 2             |
| 2  | 1       | 2    | 3             |
| 3  | 2       | 3    | 18            |
| 4  | 2       | 4    | 1             |
| 5  | 2       | 5    | 5             |
| 6  | 3       | 6    | 1             |
| 7  | 3       | 7    | 1             |
| 8  | 3       | 2    | 4             |

> Наши данные теперь приведены к 3-й нормальной форме! И они защищены от аномалий вставки, обновления и удаления!

### Денормализация

Денормализация — это намеренное нарушение нормальных форм для повышения производительности чтения.

#### Когда применять денормализацию

- **Частые сложные JOIN** — если запрос постоянно соединяет 5+ таблиц
- **Аналитические запросы** — агрегации по большим объёмам данных
- **Кэширование вычислений** — хранение предрассчитанных значений
- **Высокая нагрузка на чтение** — когда чтений в 100+ раз больше, чем записей

#### Примеры денормализации

**1. Дублирование данных:**

```sql
-- Нормализованная структура
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    total_amount NUMERIC
);

-- Денормализованная — добавляем имя пользователя
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    user_name VARCHAR(100),  -- Дублирование!
    total_amount NUMERIC
);
```

**2. Предрассчитанные агрегаты:**

```sql
-- Вместо COUNT(*) каждый раз
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    orders_count INTEGER DEFAULT 0  -- Обновляется триггером
);
```

**3. Материализованные представления:**

```sql
CREATE MATERIALIZED VIEW monthly_sales AS
SELECT
    DATE_TRUNC('month', created_at) AS month,
    SUM(total_amount) AS total
FROM orders
GROUP BY 1;
```

#### Цена денормализации

| Преимущество                | Недостаток                              |
|-----------------------------|-----------------------------------------|
| Быстрее чтение              | Медленнее запись                        |
| Меньше JOIN                 | Дублирование данных                     |
| Проще запросы               | Риск рассинхронизации                   |
| Меньше нагрузка на CPU      | Больше места на диске                   |

> Денормализация — это компромисс. Применяйте её осознанно, когда есть измеримая проблема производительности, и
> обеспечьте механизмы поддержания консистентности (триггеры, очереди, REFRESH MATERIALIZED VIEW).

## Транзакции

### Что такое Транзакция?

Транзакция — это последовательность одной или нескольких операций с базой данных, которые выполняются как единое
логическое целое. Транзакция должна либо выполниться полностью, либо не выполниться вовсе. Это гарантирует целостность и
консистентность данных в базе данных.

#### Пример типичной транзакции

- Начало транзакции.
- Выполнение одной или нескольких операций (например, `INSERT`, `UPDATE`, `DELETE`).
- Фиксация изменений (команда `COMMIT`) или откат изменений (команда `ROLLBACK`).

### TCL (Transaction control language) (Язык контроля транзакций)

`TCL` — это часть языка `SQL`, отвечающая за транзакции.

#### Основные ключевые слова TCL

В `TCL` используются следующие ключевые слова для управления транзакциями:

1. **BEGIN TRANSACTION** или **START TRANSACTION**
2. **COMMIT**
3. **ROLLBACK**
4. **SAVEPOINT**
5. **RELEASE SAVEPOINT**
6. **SET TRANSACTION**

#### BEGIN TRANSACTION / START TRANSACTION

Эти ключевые слова используются для явного начала новой транзакции. В большинстве баз данных транзакция начинается
автоматически, когда выполняется первая команда `SQL`, и завершается при выполнении `COMMIT` или `ROLLBACK`.

> В PostgreSQL `BEGIN` и `START TRANSACTION` — синонимы. Многие клиенты работают в режиме автокоммита: для явной транзакции используйте `BEGIN`/`COMMIT`.
> При ошибке внутри транзакции она помечается как прерванная; до `ROLLBACK` (или `ROLLBACK TO SAVEPOINT`) последующие команды завершатся ошибкой.

**Пример:**

```sql
BEGIN TRANSACTION;
-- или
START TRANSACTION;
```

### COMMIT

`COMMIT` используется для фиксации всех изменений, сделанных в рамках текущей транзакции. Это означает, что все
операции, выполненные после начала транзакции, станут постоянными и будут видны другим пользователям.

**Пример:**

```sql
BEGIN TRANSACTION;
INSERT INTO accounts (name, balance)
VALUES ('Alice', 1000);
INSERT INTO accounts (name, balance)
VALUES ('Bob', 500);
COMMIT;
```

### ROLLBACK

`ROLLBACK` откатывает все изменения, сделанные в рамках текущей транзакции, возвращая базу данных в состояние до начала
транзакции.

**Пример:**

```sql
BEGIN TRANSACTION;
UPDATE accounts
SET balance = balance - 100
WHERE name = 'Alice';
UPDATE accounts
SET balance = balance + 100
WHERE name = 'Bob';
ROLLBACK;
```

### SAVEPOINT

`SAVEPOINT` используется для создания промежуточной точки в транзакции, к которой можно откатиться, не отменяя всю
транзакцию.

**Пример:**

```sql
BEGIN TRANSACTION;
INSERT INTO accounts (name, balance)
VALUES ('Charlie', 700);
SAVEPOINT savepoint1;
INSERT INTO accounts (name, balance)
VALUES ('Dave', 300);
ROLLBACK TO savepoint1;
COMMIT;
```

### RELEASE SAVEPOINT

`RELEASE SAVEPOINT` используется для удаления указанного savepoint. После этого откат к этому savepoint станет
невозможным.

**Пример:**

```sql
BEGIN TRANSACTION;
INSERT INTO accounts (name, balance)
VALUES ('Eve', 400);
SAVEPOINT savepoint2;
UPDATE accounts
SET balance = balance + 100
WHERE name = 'Eve';
RELEASE SAVEPOINT savepoint2;
COMMIT;
```

### SET TRANSACTION

`SET TRANSACTION` используется для установки уровня изоляции транзакции (обсудим ниже) или других параметров транзакции.

**Пример:**

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;
INSERT INTO accounts (name, balance)
VALUES ('Frank', 600);
COMMIT;
```

### Примеры использования TCL

#### Пример 1: Успешная транзакция

```sql
BEGIN TRANSACTION;
INSERT INTO products (name, price)
VALUES ('Product1', 100);
INSERT INTO products (name, price)
VALUES ('Product2', 150);
COMMIT;
```

Все изменения будут сохранены в базе данных.

#### Пример 2: Транзакция с откатом

```sql
BEGIN TRANSACTION;
UPDATE products
SET price = price * 1.1
WHERE category = 'Electronics';
DELETE
FROM products
WHERE price > 1000;
ROLLBACK;
```

Все изменения будут отменены.

#### Пример 3: Транзакция с использованием SAVEPOINT

```sql
BEGIN TRANSACTION;
INSERT INTO orders (customer_id, order_date)
VALUES (1, '2024-08-01');
SAVEPOINT savepoint1;
INSERT INTO order_items (order_id, product_id, quantity)
VALUES (1, 10, 2);
-- Ошибка во вставке данных
ROLLBACK TO savepoint1;
COMMIT;
```

Вставка в таблицу orders будет сохранена, а вставка в order_items отменена.

### Зачем нужен ROLLBACK?

`ROLLBACK` (откат) является важным инструментом в управлении транзакциями, несмотря на то что он откатывает все
изменения. Рассмотрим, почему `ROLLBACK` нужен и какие ситуации делают его применение критически важным.

1. **Обеспечение целостности данных**: В случае ошибок или некорректных изменений `ROLLBACK` позволяет вернуть базу данных
   в состояние до начала транзакции, предотвращая частичные изменения, которые могут нарушить целостность данных.

2. **Корректировка ошибок**: Если в процессе выполнения транзакции обнаруживается ошибка (например, нарушение
   ограничения целостности, синтаксическая ошибка или ошибка логики), `ROLLBACK` позволяет отменить все изменения,
   сделанные в рамках транзакции, и начать с чистого листа.

3. **Обработка исключений**: При возникновении непредвиденных ситуаций, таких как сбои системы, ошибки приложения или
   проблемы с сетевым подключением, `ROLLBACK` позволяет откатить все изменения и избежать некорректных данных в базе.

4. **Проверка данных**: Иногда разработчики и администраторы баз данных используют `ROLLBACK` для тестирования операций.
   Они могут выполнить серию операций, проверить результаты и затем откатить изменения, чтобы база данных осталась
   неизменной.

### Примеры использования `ROLLBACK`

#### Пример 1: Ошибка при обновлении данных

Предположим, у вас есть таблица `employees`, и вы хотите повысить зарплату сотрудникам отдела 'Sales' на 10%. Во время
выполнения обновления происходит ошибка (например, попытка установить отрицательную зарплату). `ROLLBACK` поможет откатить
изменения:

_Пример (PostgreSQL):_

```sql
BEGIN;
SAVEPOINT sp1;
UPDATE employees
SET salary = salary * 1.1
WHERE department = 'Sales';
-- Если сработает ограничение (например, CHECK salary >= 0) или иная ошибка,
-- можно откатиться к savepoint и обработать ситуацию:
ROLLBACK TO SAVEPOINT sp1; -- по необходимости
COMMIT;
```

#### Пример 2: Обнаружение нарушения целостности

Предположим, вы добавляете новые заказы в таблицу `orders` и соответствующие товары в таблицу `order_items`. Если на
каком-то этапе вы обнаруживаете нарушение ограничения целостности (например, отсутствующий продукт), вы можете
использовать ROLLBACK:

```sql
BEGIN;
INSERT INTO orders (customer_id, order_date)
VALUES (1, '2024-08-01');

SAVEPOINT s1;
INSERT INTO order_items (order_id, product_id, quantity)
VALUES (1, 10, 2);

-- Если product_id отсутствует и есть внешний ключ на products(id),
-- вставка завершится ошибкой. Откатываемся к savepoint, чтобы продолжить альтернативный сценарий:
ROLLBACK TO SAVEPOINT s1; -- по необходимости

COMMIT;
```

#### Пример 3: Сбой системы
> Примечание (PostgreSQL): целостность лучше обеспечивать на уровне схемы — через ограничения CHECK и FOREIGN KEY.
> Примеры:
>
> ```sql
> ALTER TABLE employees
>   ADD CONSTRAINT employees_salary_nonnegative CHECK (salary >= 0);
>
> ALTER TABLE order_items
>   ADD CONSTRAINT order_items_product_fk FOREIGN KEY (product_id)
>   REFERENCES products(id);
> ```


Представьте, что во время выполнения транзакции происходит сбой системы (например, отключение питания). В этом случае
благодаря использованию `ROLLBACK` при следующем запуске базы данных изменения будут откатаны, и система вернётся в
согласованное состояние.

### PostgreSQL: паттерн условной логики в транзакции

```sql
BEGIN;
SAVEPOINT sp1;
-- Действие 1
-- Действие 2
-- Проверку условий выполняйте в приложении или в PL/pgSQL (в чистом SQL нет IF)
-- При ошибке или неверном состоянии:
ROLLBACK TO SAVEPOINT sp1;
-- Иначе фиксируем изменения
COMMIT;
```

## ACID

ACID — это набор свойств, которые гарантируют надежность транзакций в базах данных. ACID расшифровывается как:

- **Atomicity (Атомарность)**
- **Consistency (Согласованность)**
- **Isolation (Изоляция)**
- **Durability (Долговечность)**

Рассмотрим каждое из этих свойств более подробно.

### Atomicity (Атомарность)

Атомарность гарантирует, что все операции в транзакции будут выполнены полностью или не будут выполнены вовсе.
Транзакция считается атомарной единицей работы. Если в ходе выполнения транзакции произошёл сбой, все изменения,
сделанные в её рамках, будут отменены.

Пример:

```sql
BEGIN TRANSACTION;

INSERT INTO orders (order_id, customer_id, amount)
VALUES (1, 100, 200);
INSERT INTO order_items (order_id, product_id, quantity)
VALUES (1, 10, 1);

COMMIT;
```

Если вторая операция не выполнится (например, из-за ограничения целостности), первая операция также будет отменена.

### Consistency (Согласованность)

Согласованность гарантирует, что транзакция переводит базу данных из одного согласованного состояния в другое. Это
означает, что после выполнения транзакции все данные будут соответствовать установленным правилам целостности.

Пример:

```sql
BEGIN TRANSACTION;

UPDATE products
SET stock = stock - 1
WHERE product_id = 10;
INSERT INTO order_items (order_id, product_id, quantity)
VALUES (1, 10, 1);

COMMIT;
```

Если `stock` становится отрицательным, это нарушает правило целостности, и транзакция должна быть отклонена.

### Isolation (Изоляция)

Изоляция гарантирует, что параллельные транзакции не будут мешать друг другу. Уровни изоляции определяют, как одна
транзакция видит данные, измененные другой параллельной транзакцией.

Пример:

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN TRANSACTION;

-- Транзакция 1
SELECT balance
FROM accounts
WHERE account_id = 1;
-- Транзакция 2 (зависит от уровня изоляции, сможет или не сможет изменить данные)

COMMIT;
```

> Про эту тему поговорим ниже отдельно

### Durability (Долговечность)

Долговечность гарантирует, что результаты зафиксированной транзакции будут сохранены даже в случае сбоя системы. Это
достигается с помощью журналирования изменений (логирования) и механизмов восстановления.

Пример:

```sql
BEGIN TRANSACTION;

UPDATE accounts
SET balance = balance + 100
WHERE account_id = 1;

COMMIT;
```

После выполнения команды `COMMIT` изменение баланса будет сохранено на диск, и данные останутся в базе данных даже при
отключении питания.

### Примеры Транзакций в SQL

Рассмотрим несколько примеров транзакций с учётом свойств ACID.

1. **Перевод денег между счетами**:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 500 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 500 WHERE account_id = 2;
COMMIT;
```

В этом примере транзакция атомарна, согласована, изолирована (в зависимости от уровня изоляции) и долговечна.

2. **Обновление данных с проверкой целостности**:

```sql
BEGIN;
-- Блокировка строки для корректной проверки
SELECT quantity FROM inventory WHERE product_id = 5 FOR UPDATE;

UPDATE inventory
SET quantity = quantity - 10
WHERE product_id = 5;

-- Проверку ограничения "quantity >= 0" лучше обеспечивать CHECK-constraint
-- или выполнять в приложении/PL/pgSQL с ROLLBACK/COMMIT
COMMIT;
```

Этот пример показывает, как можно обеспечить согласованность данных, проверяя состояние после выполнения операций.

## Отдельно про уровни изоляции транзакций

> Этот вопрос просто убийственный на собеседованиях. Если ты хочешь, чтобы человек не прошёл собеседование, спроси его
> про уровни изоляции транзакций. И, скорее всего, ты своего добьёшься.

![](https://avatars.dzeninfra.ru/get-zen_doc/271828/pub_659ae0bcbffa447dc9de733e_659ae1104fb36f299923cdf1/scale_1200)

В реляционных базах данных транзакции играют ключевую роль в обеспечении целостности данных и управлении
многопользовательским доступом. Одна из важных характеристик транзакций — это уровень изоляции. Уровень изоляции
определяет, как одна транзакция видит данные, изменённые другими транзакциями. SQL-стандарт определяет четыре уровня
изоляции:

1. **Read Uncommitted** (Чтение неподтверждённых данных)
2. **Read Committed** (Чтение подтверждённых данных)
3. **Repeatable Read** (Повторяемое чтение)
4. **Serializable** (Сериализуемость)

### Аномалии транзакций

Прежде чем углубиться в уровни изоляции, необходимо понять, какие аномалии могут возникнуть при работе с транзакциями:

1. **Грязное чтение (Dirty Read)**: Одна транзакция читает данные, которые были изменены, но не подтверждены другой
   транзакцией. Если другая транзакция откатит изменения, прочитанные данные окажутся неверными.

2. **Неповторяющееся чтение (Non-repeatable Read)**: Одна транзакция повторно читает те же данные и получает разные
   значения, так как другая транзакция изменила эти данные и подтвердила изменения между двумя чтениями.

3. **Фантомное чтение (Phantom Read)**: Одна транзакция повторно выполняет запрос, который возвращает набор строк, и
   видит добавленные или удалённые строки, изменённые другой транзакцией.

### Уровни изоляции и борьба с аномалиями

#### 1. Read Uncommitted (Чтение неподтверждённых данных)

- **Описание**: Этот уровень позволяет транзакциям читать данные, которые были изменены, но не подтверждены другими
  транзакциями.
- **Аномалии**:
    - Грязное чтение: возможно.
    - Неповторяющееся чтение: возможно.
    - Фантомное чтение: возможно.
- **Использование**: Обычно используется, когда важна скорость чтения данных и допустимы потенциальные ошибки.
> PostgreSQL: уровень READ UNCOMMITTED фактически эквивалентен READ COMMITTED; грязные чтения недоступны.


#### 2. Read Committed (Чтение подтверждённых данных)

- **Описание**: Транзакции могут читать только те данные, которые были подтверждены другими транзакциями.
- **Аномалии**:
    - Грязное чтение: невозможно.
    - Неповторяющееся чтение: возможно.
    - Фантомное чтение: возможно.
- **Использование**: Является наиболее распространённым уровнем изоляции. Балансирует между целостностью данных и
  производительностью.

#### 3. Repeatable Read (Повторяемое чтение)

- **Описание**: Обеспечивает, что если транзакция читает данные, эти данные не могут быть изменены другими транзакциями
  до завершения первой транзакции.
- **Аномалии**:
    - Грязное чтение: невозможно.
    - Неповторяющееся чтение: невозможно.
    - Фантомное чтение: возможно.
- **Использование**: Используется, когда важно, чтобы данные, прочитанные в начале транзакции, оставались неизменными на
  протяжении всей транзакции.
> PostgreSQL: Repeatable Read реализует snapshot isolation; большинство фантомов предотвращается, а полная сериализуемость обеспечивается уровнем SERIALIZABLE.


#### 4. Serializable (Сериализуемость)

- **Описание**: Обеспечивает максимальный уровень изоляции. Транзакции выполняются так, как если бы они были
  сериализованы (выполнены одна за другой).
- **Аномалии**:
    - Грязное чтение: невозможно.
    - Неповторяющееся чтение: невозможно.
    - Фантомное чтение: невозможно.
- **Использование**: Применяется в случаях, когда требуется максимальная целостность данных и изоляция транзакций,
  несмотря на снижение производительности.

> Выбор уровня изоляции транзакции в SQL зависит от требований конкретного приложения к целостности данных и
> производительности.

> Важно понимать, какие аномалии могут возникнуть при каждом уровне и как они могут повлиять на ваше
> приложение. В большинстве случаев, компромисс между производительностью и изоляцией достигается на уровне Read
> Committed.

> Для критических систем, где требуется абсолютная целостность данных, следует использовать Serializable,
> несмотря на возможное снижение производительности.

### Примеры транзакций с аномалиями

### 1. Read Uncommitted (Чтение неподтверждённых данных)

**Пример**:
Предположим, у нас есть таблица `accounts` с колонками `id` и `balance`.

```sql
-- Транзакция 1
BEGIN TRANSACTION;
UPDATE accounts
SET balance = balance - 100
WHERE id = 1;

-- Транзакция 2
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
BEGIN TRANSACTION;
SELECT balance
FROM accounts
WHERE id = 1;
-- Здесь транзакция 2 может увидеть баланс, уменьшенный на 100, даже если транзакция 1 ещё не подтвердила изменения.
COMMIT;

-- Транзакция 1
ROLLBACK;
-- Если транзакция 1 откатывается, баланс возвращается к исходному значению, но транзакция 2 уже прочитала неверные данные.
```

### 2. Read Committed (Чтение подтверждённых данных)

**Пример**:

```sql
-- Транзакция 1
BEGIN TRANSACTION;
UPDATE accounts
SET balance = balance - 100
WHERE id = 1;

-- Транзакция 2
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN TRANSACTION;
SELECT balance
FROM accounts
WHERE id = 1;
-- Здесь транзакция 2 не увидит изменений, пока транзакция 1 не завершится.
COMMIT;

-- Транзакция 1
COMMIT;
-- После коммита транзакции 1, изменения становятся видимыми для других транзакций.
```

### 3. Repeatable Read (Повторяемое чтение)

**Пример**:

```sql
-- Транзакция 1
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN TRANSACTION;
SELECT balance
FROM accounts
WHERE id = 1;
-- Возвращает баланс, например, 500.

-- Транзакция 2
BEGIN TRANSACTION;
UPDATE accounts
SET balance = balance + 100
WHERE id = 1;
COMMIT;

-- Транзакция 1
SELECT balance
FROM accounts
WHERE id = 1;
-- Возвращает всё тот же баланс 500, несмотря на изменения, сделанные транзакцией 2.
COMMIT;
```

### 4. Serializable (Сериализуемость)

**Пример**:

```sql
-- Транзакция 1
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;
SELECT SUM(balance)
FROM accounts
WHERE balance > 100;
-- Возвращает сумму, например, 300.

-- Транзакция 2
BEGIN TRANSACTION;
INSERT INTO accounts (id, balance)
VALUES (3, 150);
COMMIT;

-- Транзакция 1
SELECT SUM(balance)
FROM accounts
WHERE balance > 100;
-- Возвращает всё ту же сумму 300, даже несмотря на добавление новой строки транзакцией 2.
COMMIT;
```

## Обсуждение аномалий и уровней изоляции

### Read Uncommitted (Чтение неподтверждённых данных)

- **Грязное чтение**: В примере транзакция 2 читает баланс, уменьшенный на 100, даже если транзакция 1 не подтвердила
  изменения и откатила их.

### Read Committed (Чтение подтверждённых данных)

- **Грязное чтение**: В примере транзакция 2 не может видеть изменения, пока транзакция 1 не завершит свои операции.
  Грязное чтение предотвращается.
- **Неповторяющееся чтение**: Если транзакция 1 изменит данные и подтвердит изменения, транзакция 2 может увидеть разные
  значения при повторных чтениях.

### Repeatable Read (Повторяемое чтение)

- **Грязное чтение**: Нет, так как данные, которые читаются, уже подтверждены.
- **Неповторяющееся чтение**: Нет, так как повторные чтения тех же данных вернут одинаковые результаты.
- **Фантомное чтение**: Возможно. В примере фантомное чтение не рассматривается, но при выполнении повторного запроса,
  добавленные строки могут быть видимыми.

### Serializable (Сериализуемость)

- **Грязное чтение**: Нет.
- **Неповторяющееся чтение**: Нет.
- **Фантомное чтение**: Нет. В примере транзакция 1 видит те же данные, несмотря на изменения, сделанные транзакцией 2.

Эти примеры иллюстрируют, как уровни изоляции транзакций помогают справляться с аномалиями и обеспечивать целостность
данных в многопользовательских системах.

## Процедуры (Procedures)

В PostgreSQL 11+ появились процедуры. Главное отличие от функций — процедуры могут управлять транзакциями внутри себя
(выполнять COMMIT и ROLLBACK).

### Когда использовать процедуры

- Когда нужно выполнить несколько операций с промежуточными COMMIT
- Для длительных операций, где важно фиксировать прогресс
- Для миграций данных большими порциями

### Создание процедуры

```sql
CREATE OR REPLACE PROCEDURE transfer_money(
    from_account INTEGER,
    to_account INTEGER,
    amount NUMERIC
)
LANGUAGE plpgsql AS $$
BEGIN
    -- Списываем с одного счёта
    UPDATE accounts SET balance = balance - amount WHERE id = from_account;

    -- Зачисляем на другой
    UPDATE accounts SET balance = balance + amount WHERE id = to_account;

    -- Фиксируем транзакцию
    COMMIT;
END;
$$;

-- Вызов процедуры
CALL transfer_money(1, 2, 100.00);
```

### Процедура с обработкой ошибок

```sql
CREATE OR REPLACE PROCEDURE safe_transfer(
    from_account INTEGER,
    to_account INTEGER,
    amount NUMERIC
)
LANGUAGE plpgsql AS $$
DECLARE
    from_balance NUMERIC;
BEGIN
    -- Проверяем баланс
    SELECT balance INTO from_balance FROM accounts WHERE id = from_account;

    IF from_balance < amount THEN
        RAISE EXCEPTION 'Недостаточно средств на счёте %', from_account;
    END IF;

    UPDATE accounts SET balance = balance - amount WHERE id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE id = to_account;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$;
```

### Процедура для пакетной обработки

```sql
-- Обработка данных порциями с промежуточными COMMIT
CREATE OR REPLACE PROCEDURE archive_old_orders(batch_size INTEGER DEFAULT 1000)
LANGUAGE plpgsql AS $$
DECLARE
    rows_moved INTEGER;
BEGIN
    LOOP
        -- Перемещаем порцию данных
        WITH moved AS (
            DELETE FROM orders
            WHERE created_at < NOW() - INTERVAL '1 year'
            LIMIT batch_size
            RETURNING *
        )
        INSERT INTO orders_archive SELECT * FROM moved;

        GET DIAGNOSTICS rows_moved = ROW_COUNT;

        -- Фиксируем каждую порцию
        COMMIT;

        -- Выходим, если больше нечего обрабатывать
        EXIT WHEN rows_moved < batch_size;
    END LOOP;
END;
$$;

-- Вызов
CALL archive_old_orders(5000);
```

### Отличия функций от процедур

| Функции                              | Процедуры                              |
|--------------------------------------|----------------------------------------|
| Возвращают значение (RETURNS)        | Не возвращают значение                 |
| Вызываются через SELECT              | Вызываются через CALL                  |
| Не могут управлять транзакциями      | Могут делать COMMIT/ROLLBACK           |
| Можно использовать в выражениях      | Нельзя использовать в выражениях       |

```sql
-- Удаление процедуры
DROP PROCEDURE transfer_money(INTEGER, INTEGER, NUMERIC);
```

## Блокировки (Locks)

Блокировки — это механизм, который предотвращает конфликты при одновременном доступе к данным. PostgreSQL использует
различные типы блокировок для обеспечения целостности данных.

### Блокировки на уровне строк

#### FOR UPDATE

Блокирует выбранные строки для обновления. Другие транзакции не смогут изменить или заблокировать эти строки до
завершения текущей транзакции.

```sql
BEGIN;

-- Блокируем строку для обновления
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

-- Теперь можно безопасно обновить
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

COMMIT;
```

#### FOR SHARE

Блокирует строки для чтения. Другие транзакции могут читать, но не могут изменять эти строки.

```sql
BEGIN;

-- Блокируем для чтения
SELECT * FROM accounts WHERE id = 1 FOR SHARE;

-- Другие транзакции могут читать, но не могут UPDATE/DELETE

COMMIT;
```

#### Варианты блокировок

```sql
-- Не ждать, если строка заблокирована (вернёт ошибку)
SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT;

-- Пропустить заблокированные строки
SELECT * FROM accounts WHERE id = 1 FOR UPDATE SKIP LOCKED;

-- Полезно для очередей задач
SELECT * FROM tasks
WHERE status = 'pending'
ORDER BY created_at
LIMIT 1
FOR UPDATE SKIP LOCKED;
```

### Deadlock (Взаимная блокировка)

Deadlock возникает, когда две транзакции ждут друг друга.

```sql
-- Транзакция 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- Ждёт блокировку на id = 2

-- Транзакция 2
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
-- Ждёт блокировку на id = 1

-- Deadlock! PostgreSQL автоматически откатит одну из транзакций
```

**Как избежать deadlock:**
- Всегда блокируйте ресурсы в одинаковом порядке
- Используйте короткие транзакции
- Используйте `NOWAIT` или `SKIP LOCKED`

### Advisory Locks (Рекомендательные блокировки)

Advisory locks — это блокировки на уровне приложения. PostgreSQL не связывает их с конкретными данными — это просто
числовые идентификаторы.

```sql
-- Получить эксклюзивную блокировку (ждать, если занята)
SELECT pg_advisory_lock(12345);

-- Попробовать получить блокировку (не ждать)
SELECT pg_try_advisory_lock(12345);  -- Вернёт true/false

-- Освободить блокировку
SELECT pg_advisory_unlock(12345);

-- Блокировка на уровне сессии (автоматически освобождается при отключении)
SELECT pg_advisory_lock(12345);

-- Блокировка на уровне транзакции (освобождается при COMMIT/ROLLBACK)
SELECT pg_advisory_xact_lock(12345);
```

**Пример использования — предотвращение дублирования задач:**

```sql
-- Только один процесс может выполнять эту задачу
DO $$
BEGIN
    IF pg_try_advisory_lock(hashtext('daily_report')) THEN
        -- Выполняем задачу
        PERFORM generate_daily_report();
        PERFORM pg_advisory_unlock(hashtext('daily_report'));
    ELSE
        RAISE NOTICE 'Task is already running';
    END IF;
END $$;
```

## MVCC (Multi-Version Concurrency Control)

MVCC — это механизм, который PostgreSQL использует для обеспечения изоляции транзакций без блокировки чтения.

### Как работает MVCC

1. **Каждая строка имеет версии** — при UPDATE создаётся новая версия строки, старая помечается как устаревшая
2. **Читатели не блокируют писателей** — транзакция читает снимок данных на момент своего начала
3. **Писатели не блокируют читателей** — изменения видны только после COMMIT

```
Время →

T1: BEGIN ─────────────────────────────────────────── COMMIT
         SELECT balance  (видит 1000)
                                    SELECT balance (всё ещё 1000!)

T2:           BEGIN ─── UPDATE balance=900 ─── COMMIT
```

### Системные столбцы

Каждая строка в PostgreSQL имеет скрытые системные столбцы:

```sql
SELECT xmin, xmax, ctid, * FROM accounts WHERE id = 1;
```

- **xmin** — ID транзакции, создавшей эту версию строки
- **xmax** — ID транзакции, удалившей/обновившей строку (0 если актуальна)
- **ctid** — физическое расположение строки (страница, позиция)

### VACUUM

Из-за MVCC старые версии строк накапливаются. VACUUM очищает их:

```sql
-- Ручная очистка таблицы
VACUUM accounts;

-- Очистка с анализом статистики
VACUUM ANALYZE accounts;

-- Полная очистка (блокирует таблицу, освобождает место на диске)
VACUUM FULL accounts;
```

> PostgreSQL автоматически запускает autovacuum. Для большинства случаев ручной VACUUM не нужен.

## Backup

![](https://cs14.pikabu.ru/post_img/2021/09/17/7/1631876621194950069.jpg)

> Есть два вида людей:
>   - которые делают бекапы
>   - и которые уже делают бекапы
>
> © Джейсон Стетхем,  VI век до нашей эры

### Зачем нужен backup?

`Резервное копирование` — это процесс создания копии данных, которую можно использовать для восстановления базы данных в случае потери данных или повреждения. Основные причины, по которым необходимо делать резервные копии:

1. **Защита от потери данных**: Аппаратные сбои, ошибки пользователей, атаки вирусов и хакеров могут привести к потере данных.
2. **Восстановление после сбоев**: Возможность быстро восстановить работоспособность базы данных после сбоя.
3. **Исторические данные**: Возможность доступа к старым версиям данных для анализа или аудита.
4. **Разработка и тестирование**: Копии данных могут использоваться для разработки, тестирования и экспериментов без риска повреждения основной базы данных.


### pg_dump

`pg_dump` — это утилита для создания резервных копий базы данных PostgreSQL. Она позволяет экспортировать данные и схему базы данных в файл.

#### Основные функции и параметры pg_dump

1. **Экспорт всей базы данных:**
   ```sh
   pg_dump -U username -h hostname -d dbname > backup.sql
   ```
   Параметры:
   - `-U`: имя пользователя.
   - `-h`: хост, на котором работает база данных.
   - `-d`: имя базы данных.

2. **Экспорт в формат tar или custom:**
   ```sh
   pg_dump -U username -h hostname -d dbname -F t > backup.tar
   ```
   Параметр `-F` указывает формат резервной копии:
   - `p`: plain текст (по умолчанию).
   - `c`: custom.
   - `t`: tar.

3. **Экспорт конкретной таблицы:**
   ```sh
   pg_dump -U username -h hostname -d dbname -t tablename > table_backup.sql
   ```
   Параметр `-t` указывает таблицу для экспорта.

4. **Сжатие резервной копии:**
   ```sh
   pg_dump -U username -h hostname -d dbname | gzip > backup.sql.gz
   ```

#### Примеры использования

- Экспорт всей базы данных с указанием формата:
  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -F c > mydatabase.backup
  ```

- Экспорт схемы без данных:
  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -s > schema_only.sql
  ```

- Экспорт данных без схемы:
  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -a > data_only.sql
  ```

#### Восстановление из plain SQL (psql)

```sh
psql -U username -h hostname -d dbname -f backup.sql
```

#### Глобальные объекты (роли, tablespace)

```sh
pg_dumpall -U username -h hostname -g > globals.sql
```

### pg_restore

`pg_restore` — это утилита для восстановления базы данных из резервной копии, созданной с помощью `pg_dump` в формате tar или custom.

#### Основные функции и параметры pg_restore

1. **Восстановление базы данных:**
   ```sh
   pg_restore -U username -h hostname -d dbname backup_file
   ```

2. **Создание новой базы данных и восстановление:**
   ```sh
   createdb -U username -h hostname new_dbname
   pg_restore -U username -h hostname -d new_dbname backup_file
   ```

3. **Восстановление только схемы:**
   ```sh
   pg_restore -U username -h hostname -d dbname -s backup_file
   ```

4. **Восстановление только данных:**
   ```sh
   pg_restore -U username -h hostname -d dbname -a backup_file
   ```

#### Примеры использования

- Восстановление базы данных из tar-архива:
  ```sh
  pg_restore -U postgres -h localhost -d mydatabase mydatabase.backup
  ```

- Восстановление с применением дополнительных параметров:
  ```sh
  pg_restore -U postgres -h localhost -d mydatabase -j 4 --verbose mydatabase.backup
  ```
  Параметр `-j` указывает количество параллельных потоков для ускорения процесса восстановления.

### Практические советы

1. **Планирование резервного копирования**: Регулярно выполняйте резервное копирование базы данных, особенно перед внесением значительных изменений.

2. **Проверка резервных копий**: Периодически проверяйте резервные копии, чтобы убедиться, что они корректно восстанавливаются.

3. **Автоматизация**: Настройте автоматическое резервное копирование с помощью cron или других планировщиков задач.

4. **Безопасность**: Храните резервные копии в безопасных местах и защищайте их паролями или шифрованием.

5. **Документация**: Ведите документацию по процессу резервного копирования и восстановления, чтобы упростить обучение новых сотрудников и улучшить управляемость.

6. **Тестовое восстановление**: Периодически разворачивайте резервные копии в тестовой среде, чтобы убедиться, что процесс восстановления действительно работает.

7. **Физические бэкапы**: Для полной копии кластера и настройки потоковой репликации используйте `pg_basebackup` (физическое резервное копирование).


> Использование `pg_dump` и `pg_restore` позволяет эффективно управлять резервными копиями и восстанавливать данные в PostgreSQL. Эти утилиты предоставляют гибкость и надежность, необходимые для обеспечения безопасности и доступности данных. Регулярное резервное копирование и проверка его целостности — залог стабильной работы любой системы управления базами данных.

### Примеры использования

1. **Регулярное резервное копирование**: В крупных компаниях, где потеря данных может привести к серьёзным финансовым потерям, резервное копирование проводится ежедневно.
2. **Восстановление после сбоя**: Если база данных повреждена из-за сбоя оборудования, можно быстро восстановить данные из последнего бэкапа.
3. **Создание тестовых сред**: Разработчики могут использовать резервные копии для создания тестовых баз данных, что позволяет тестировать новые функции без риска для основной базы.

> Резервное копирование и восстановление — это критически важные процессы для обеспечения безопасности данных в PostgreSQL. Понимание различных методов резервного копирования и восстановления поможет вам эффективно управлять базами данных и минимизировать риски потери данных.

## WAL и Point-in-Time Recovery (PITR)

### WAL (Write-Ahead Logging)

WAL — это журнал, в который PostgreSQL записывает все изменения перед их применением к данным. Это обеспечивает:

- **Durability** — данные не теряются при сбое
- **Атомарность** — транзакции либо полностью применяются, либо полностью откатываются
- **Репликацию** — WAL можно передавать на реплики

```
Запись данных:
1. Записать изменение в WAL
2. Подтвердить транзакцию (COMMIT)
3. Позже применить изменения к файлам данных (checkpoint)
```

### Point-in-Time Recovery (PITR)

PITR позволяет восстановить базу данных на любой момент времени в прошлом.

**Как это работает:**
1. Создаётся базовый бэкап (pg_basebackup)
2. Архивируются WAL-файлы
3. При восстановлении применяются WAL до нужного момента

```bash
# Создание базового бэкапа
pg_basebackup -D /backup/base -Ft -z -P

# Настройка архивации WAL (postgresql.conf)
archive_mode = on
archive_command = 'cp %p /backup/wal/%f'
```

**Восстановление на конкретный момент:**

```bash
# recovery.conf (или postgresql.conf в новых версиях)
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2024-01-15 14:30:00'
```

> PITR критически важен для production-систем. Он позволяет восстановиться после ошибок пользователей (случайный DELETE)
> или повреждения данных.

## Репликация

Репликация — это процесс копирования данных с одного сервера (primary/master) на другие (replica/standby).

### Физическая репликация (Streaming Replication)

Копирует WAL-файлы побайтово. Реплика — точная копия primary.

```
Primary ──WAL──> Replica
```

**Настройка primary (postgresql.conf):**
```
wal_level = replica
max_wal_senders = 3
```

**Настройка replica:**
```bash
pg_basebackup -h primary_host -D /var/lib/postgresql/data -U replicator -P -R
```

**Преимущества:**
- Простота настройки
- Реплика может использоваться для чтения (hot standby)
- Автоматический failover с помощью Patroni, pg_auto_failover

### Логическая репликация

Копирует изменения на уровне строк (INSERT, UPDATE, DELETE). Позволяет:
- Реплицировать отдельные таблицы
- Реплицировать между разными версиями PostgreSQL
- Трансформировать данные при репликации

```sql
-- На primary: создаём публикацию
CREATE PUBLICATION my_pub FOR TABLE users, orders;

-- На replica: создаём подписку
CREATE SUBSCRIPTION my_sub
CONNECTION 'host=primary_host dbname=mydb user=replicator'
PUBLICATION my_pub;
```

### Сравнение

| Характеристика        | Физическая              | Логическая              |
|-----------------------|-------------------------|-------------------------|
| Что копируется        | Весь кластер            | Выбранные таблицы       |
| Версии PostgreSQL     | Одинаковые              | Могут отличаться        |
| Использование реплики | Только чтение           | Чтение и запись         |
| Настройка             | Проще                   | Сложнее                 |
| Производительность    | Выше                    | Ниже                    |

> Для большинства случаев используйте физическую репликацию. Логическая нужна для специфических сценариев: миграция
> между версиями, выборочная репликация, мультимастер.

---

[← Лекция 16: СУБД. DQL. SELECT. Индексы. GROUP BY. Joins.](lesson16.md) | [Лекция 18: Virtual env. Pip. Устанавливаемые модули. Pyenv. →](lesson18.md)
